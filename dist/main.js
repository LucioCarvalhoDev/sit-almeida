/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/charenc/charenc.js":
/*!*****************************************!*\
  !*** ./node_modules/charenc/charenc.js ***!
  \*****************************************/
/***/ ((module) => {

eval("var charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/charenc/charenc.js?");

/***/ }),

/***/ "./node_modules/crypt/crypt.js":
/*!*************************************!*\
  !*** ./node_modules/crypt/crypt.js ***!
  \*************************************/
/***/ ((module) => {

eval("(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/crypt/crypt.js?");

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/***/ ((module) => {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/is-buffer/index.js?");

/***/ }),

/***/ "./node_modules/md5/md5.js":
/*!*********************************!*\
  !*** ./node_modules/md5/md5.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("(function(){\r\n  var crypt = __webpack_require__(/*! crypt */ \"./node_modules/crypt/crypt.js\"),\r\n      utf8 = (__webpack_require__(/*! charenc */ \"./node_modules/charenc/charenc.js\").utf8),\r\n      isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\"),\r\n      bin = (__webpack_require__(/*! charenc */ \"./node_modules/charenc/charenc.js\").bin),\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message) && message.constructor !== Uint8Array)\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if (message === undefined || message === null)\r\n      throw new Error('Illegal argument ' + message);\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/md5/md5.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _js_controller_Controller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./js/controller/Controller.js */ \"./src/js/controller/Controller.js\");\n\r\n\r\nconst table = document.querySelector(\".m_table_orders\");\r\nconst controller = new _js_controller_Controller_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](table);\r\n\r\nconst applyFilter = (e) => {\r\n    e.preventDefault();\r\n    controller.filter();\r\n};\r\n\r\nconst clearFilters = (e) => {\r\n    e.preventDefault();\r\n    controller.clearInputs();\r\n    controller.filter();\r\n};\r\n\r\ndocument.querySelector('.h_form').onsubmit = applyFilter;\r\n\r\ndocument.getElementById('btn-search').onclick = applyFilter;\r\ndocument.getElementById('btn-clear').onclick = clearFilters;\r\ndocument.getElementById('btn-config').onclick = (e) => {\r\n    e.preventDefault();\r\n\r\n    controller.modalController.toggleModal(e);\r\n    controller.openConfig();\r\n};\r\n\r\ndocument.getElementById('add').onclick = (e) => {\r\n    controller.openEditor();\r\n};\r\n\r\ndocument.querySelectorAll('.h_form_filters_cont_label_ipt')\r\n    .forEach(input => {\r\n        input.oninput = applyFilter;\r\n    });\n\n//# sourceURL=webpack://sit-almeida/./src/index.js?");

/***/ }),

/***/ "./src/js/controller/Controller.js":
/*!*****************************************!*\
  !*** ./src/js/controller/Controller.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Controller)\n/* harmony export */ });\n/* harmony import */ var yaml__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yaml */ \"./node_modules/yaml/browser/index.js\");\n/* harmony import */ var _dao_Dao_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dao/Dao.js */ \"./src/js/dao/Dao.js\");\n/* harmony import */ var _helper_Filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helper/Filter.js */ \"./src/js/helper/Filter.js\");\n/* harmony import */ var _model_Order_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/Order.js */ \"./src/js/model/Order.js\");\n/* harmony import */ var _view_TableView_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../view/TableView.js */ \"./src/js/view/TableView.js\");\n/* harmony import */ var _ModalController_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ModalController.js */ \"./src/js/controller/ModalController.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Controller {\r\n    constructor(table) {\r\n        this.dao = new _dao_Dao_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\r\n        this.tableView = new _view_TableView_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](table);\r\n        this.modalController = new _ModalController_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\r\n\r\n        this.orders = [];\r\n\r\n        this.mode = \"settings\";\r\n\r\n        this.inputs = {\r\n            name: document.getElementById('ipt-name'),\r\n            phone: document.getElementById('ipt-phone'),\r\n            description: document.getElementById('ipt-description'),\r\n            price: document.getElementById('ipt-price'),\r\n            date: document.getElementById('ipt-date'),\r\n        };\r\n\r\n        this.init();\r\n    }\r\n\r\n    async init() {\r\n        await this.getOrders();\r\n        // console.log(this.orders[0]);\r\n    }\r\n\r\n    exportData() {\r\n        this.dao.getOrders()\r\n            .then(dataArr => {\r\n                return dataArr.map(data => new _model_Order_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](data));\r\n            })\r\n            .then(orderArr => {\r\n                const now = new Date();\r\n                const content = (0,yaml__WEBPACK_IMPORTED_MODULE_0__.stringify)(orderArr);\r\n\r\n                const link = document.createElement('a');\r\n                link.href = 'data:application/text,' + encodeURIComponent(content);\r\n                link.taget = '_blank';\r\n                link.download = `pedidos_${now.getDate()}-${now.getMonth() + 1}-${now.getUTCFullYear()}.yaml`;\r\n\r\n                link.click();\r\n            });\r\n    }\r\n\r\n    importData(text) {\r\n        const orderArr = (0,yaml__WEBPACK_IMPORTED_MODULE_0__.parse)(text).map(data => new _model_Order_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](data));\r\n        this.dao.importOrders(orderArr)\r\n            .then(() => {\r\n                this.getOrders();\r\n            });\r\n    }\r\n\r\n    clearData() {\r\n        this.dao.clearData();\r\n        this.getOrders();\r\n    }\r\n\r\n    createOrder(data) {\r\n        const order = new _model_Order_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](data);\r\n        this.dao.createOrder(order);\r\n        this.getOrders();\r\n    }\r\n\r\n    getOrders() {\r\n        return new Promise((resolve, reject) => {\r\n            this.orders = [];\r\n            this.dao.getOrders()\r\n                .then(dataArr => {\r\n                    dataArr.forEach(data => {\r\n                        this.orders.push(new _model_Order_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](data));\r\n                    });\r\n                    this.updateView(this.orders);\r\n                    resolve();\r\n                });\r\n        });\r\n    }\r\n\r\n    updateView(orders) {\r\n        const ordersHtml = Array.from(this.tableView.updateView(orders));\r\n\r\n        ordersHtml.forEach(orderElem => orderElem.onclick = (e) => {\r\n            this.dao.get(orderElem.dataset.id)\r\n                .then(order => this.openEditor(order, this.dao.updateOrder));\r\n        });\r\n    }\r\n\r\n    filter() {\r\n        const params = {};\r\n\r\n        for (const input in this.inputs) {\r\n            if (input == \"date\") {\r\n                params[input] = this.inputs[input].value;\r\n                continue;\r\n            }\r\n            params[input] = this.inputs[input].value.toUpperCase().replaceAll(/[\\s-()]/g, '');\r\n        }\r\n\r\n        const objFilter = new _helper_Filter_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](params);\r\n\r\n        const res = this.orders.filter(order => {\r\n            return objFilter.eval(order);\r\n        });\r\n\r\n        this.updateView(res);\r\n    }\r\n\r\n    clearInputs() {\r\n        for (const input in this.inputs) {\r\n            this.inputs[input].value = '';\r\n        }\r\n    }\r\n\r\n    openConfig() {\r\n        this.modalController.openConfig();\r\n\r\n        document.getElementById('btn-export').onclick = this.exportData.bind(this);\r\n        document.getElementById('btn-import').onclick = () => {\r\n\r\n            const elem = document.createElement('input');\r\n            elem.type = 'file';\r\n            elem.accept = '.yaml';\r\n\r\n            elem.onchange = (event) => {\r\n                event.target.files[0]\r\n                    .text()\r\n                    .then(text => this.importData(text));\r\n            };\r\n            elem.click();\r\n        };\r\n\r\n        document.getElementById('btn-clear-data').onclick = (e) => {\r\n            e.preventDefault();\r\n\r\n            this.clearData();\r\n        };\r\n    }\r\n\r\n    openEditor(oldOrder = new _model_Order_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](_model_Order_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].template()), action = () => { }, enableInputs = true) {\r\n        const currentOrder = new _model_Order_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](oldOrder);\r\n\r\n        const editorPromise = this.modalController.openEditor(oldOrder);\r\n        this.modalController.toggleModal();\r\n\r\n        const disableSwitchers = (document.querySelectorAll('[data-fild]'));\r\n        disableSwitchers.forEach(btn => {\r\n            const ipt = btn.previousElementSibling;\r\n            btn.onclick = () => {\r\n                ipt.disabled = !ipt.disabled;\r\n            };\r\n        });\r\n\r\n        if (enableInputs)\r\n            disableSwitchers.forEach(btn => btn.click());\r\n\r\n\r\n        editorPromise\r\n            .then(data => {\r\n                for (let property in data) {\r\n                    currentOrder[property] = data[property];\r\n                }\r\n                // console.log(oldOrder);\r\n                // console.log(currentOrder);\r\n                this.updateOrder(currentOrder);\r\n            });\r\n    }\r\n\r\n    updateOrder(order) {\r\n        this.dao.updateOrder(order.id, order)\r\n            .then(() => {\r\n                this.getOrders();\r\n                this.updateView(this.orders);\r\n            });\r\n    }\r\n}\n\n//# sourceURL=webpack://sit-almeida/./src/js/controller/Controller.js?");

/***/ }),

/***/ "./src/js/controller/ModalController.js":
/*!**********************************************!*\
  !*** ./src/js/controller/ModalController.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ModalController)\n/* harmony export */ });\n/* harmony import */ var dateformat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dateformat */ \"./node_modules/dateformat/lib/dateformat.js\");\n\r\n\r\nclass ModalController {\r\n    constructor() {\r\n        this._modalContainer = document.querySelector('.m_box');\r\n        this._overlay = document.getElementById('overlay');\r\n\r\n        this._configHTML = `\r\n        <div class=\"m_md_bg_config\">\r\n            <h4 class=\"m_md_bg_config_title\">Configurações</h4>\r\n            <div class=\"m_md_bg_config_sec\">\r\n                <input type=\"button\" value=\"Exportar\" id=\"btn-export\"\r\n                    class=\"m_md_bg_config_sec_btn\">\r\n                <input type=\"button\" id=\"btn-import\" class=\"m_md_bg_config_sec_btn\" value=\"Importar\"\r\n                    name=\"file\">\r\n            </div>\r\n            <div class=\"m_md_bg_config_sec\">\r\n                <input type=\"button\" value=\"X\" id=\"btn-clear-data\" class=\"m_md_bg_config_sec_btn\">\r\n            </div>\r\n        </div>`;\r\n\r\n        this._orderHTML = `\r\n        <form class=\"m_md_bg_order\">\r\n            <h4 class=\"m_md_bg_order_title\">order</h4>\r\n            <div class=\"m_md_bg_order_sec\">\r\n                <div class=\"m_md_bg_order_sec_fild\">\r\n                    <label class=\"m_md_bg_order_sec_field_label\" for=\"ipt-order-name\">Nome</label>\r\n                    <input class=\"m_md_bg_order_sec_field_ipt\" disabled type=\"text\" id=\"ipt-order-name\" \r\n                        data-editor-field=\"name\">\r\n                    <span class=\"m_md_bg_order_sec_field_edit\" data-fild=\"off\"><i class=\"fas fa-pen\"></i></span>\r\n                </div>\r\n                <div class=\"m_md_bg_order_sec_fild\">\r\n                    <label class=\"m_md_bg_order_sec_field_label\" for=\"ipt-order-tel\">Tel</label>\r\n                    <input class=\"m_md_bg_order_sec_field_ipt\" disabled type=\"text\" id=\"ipt-order-tel\" \r\n                        data-editor-field=\"phone\">\r\n                    <span class=\"m_md_bg_order_sec_field_edit\" data-fild=\"off\"><i class=\"fas fa-pen\"></i></span>\r\n                </div>\r\n                <div class=\"m_md_bg_order_sec_fild\">\r\n                    <label class=\"m_md_bg_order_sec_field_label\" for=\"ipt-order-des\">des</label>\r\n                    <input class=\"m_md_bg_order_sec_field_ipt\" disabled type=\"text\" id=\"ipt-order-des\" \r\n                        data-editor-field=\"description\">\r\n                    <span class=\"m_md_bg_order_sec_field_edit\" data-fild=\"off\"><i class=\"fas fa-pen\"></i></span>\r\n                </div>\r\n                <div class=\"m_md_bg_order_sec_fild\">\r\n                    <label class=\"m_md_bg_order_sec_field_label\" for=\"ipt-order-price\">R$</label>\r\n                    <input class=\"m_md_bg_order_sec_field_ipt\" disabled type=\"text\" id=\"ipt-order-price\" \r\n                        data-editor-field=\"price\">\r\n                    <span class=\"m_md_bg_order_sec_field_edit\" data-fild=\"off\"><i class=\"fas fa-pen\"></i></span>\r\n                </div>\r\n                <div class=\"m_md_bg_order_sec_fild\">\r\n                    <label class=\"m_md_bg_order_sec_field_label\" for=\"ipt-order-date\">date</label>\r\n                    <input class=\"m_md_bg_order_sec_field_ipt\" disabled type=\"date\" id=\"ipt-order-date\" \r\n                        data-editor-field=\"date\">\r\n                    <span class=\"m_md_bg_order_sec_field_edit\" data-fild=\"off\"><i class=\"fas fa-pen\"></i></span>\r\n                </div>\r\n                <div class=\"m_md_bg_order_sec_fild\">\r\n                    <label class=\"m_md_bg_order_sec_field_label\" for=\"ipt-order-ok\">OK</label>\r\n                    <input class=\"m_md_bg_order_sec_field_ipt\" disabled type=\"checkbox\" id=\"ipt-order-ok\" \r\n                        data-editor-field=\"ok\">\r\n                    <span class=\"m_md_bg_order_sec_field_edit\" data-fild=\"off\"><i class=\"fas fa-pen\"></i></span>\r\n                </div>\r\n            </div>\r\n            <div class=\"m_md_bg_order_sec\">\r\n                <input type=\"button\" class=\"m_md_bg_order_sec_btn\" value=\"Cancelar\" />\r\n                <button class=\"m_md_bg_order_sec_btn\" id=\"btn-editor-submit\">Salvar</button>\r\n            </div>\r\n        </form>`;\r\n\r\n\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this._overlay.onclick = this.toggleModal.bind(this);\r\n    }\r\n\r\n    toggleModal(e) {\r\n        if (this._modalContainer.classList.contains('--hidden')) {\r\n            this._modalContainer.classList.remove('--hidden');\r\n            document.querySelector('body').dataset.modal = \"on\";\r\n\r\n        } else if (e.target.id == \"overlay\") {\r\n            this._modalContainer.classList.add('--hidden');\r\n            document.querySelector('body').dataset.modal = \"off\";\r\n        }\r\n    };\r\n\r\n    openConfig() {\r\n        this._overlay.innerHTML = this._configHTML;\r\n    }\r\n\r\n    openEditor(data) {\r\n        return new Promise((resolve, reject) => {\r\n            this._overlay.innerHTML = this._orderHTML;\r\n            const saveBtn = document.getElementById('btn-editor-submit');\r\n\r\n            // preenche campos do editor com dados fornecidos\r\n            const inputs = this._overlay.querySelectorAll('input:not([type=\"button\"]):not([type=\"submit\"])');\r\n            inputs.forEach(ipt => {\r\n                const propertyName = ipt.dataset.editorField;\r\n\r\n                ipt.value = data[propertyName];\r\n                if (propertyName == 'date') {\r\n                    ipt.value = ((0,dateformat__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(data[propertyName] || new Date(), \"yyyy-mm-dd\"));\r\n                } else if (propertyName == 'ok') {\r\n                    ipt.checked = data[propertyName];\r\n                }\r\n            });\r\n\r\n            saveBtn.addEventListener('mousedown', (e) => {\r\n                e.preventDefault();\r\n\r\n                this._overlay.click();\r\n\r\n                const newData = {};\r\n                inputs.forEach(ipt => {\r\n                    const propertyName = ipt.dataset.editorField;\r\n\r\n                    switch (ipt.propertyName) {\r\n                        case 'ok':\r\n                            newData[propertyName] = ipt.checked;\r\n                        case 'date':\r\n                            newData[propertyName] = ipt.value;\r\n                        default:\r\n                            newData[propertyName] = ipt.value;\r\n                    }\r\n                });\r\n\r\n                resolve(newData);\r\n\r\n            });\r\n        });\r\n\r\n    }\r\n}\n\n//# sourceURL=webpack://sit-almeida/./src/js/controller/ModalController.js?");

/***/ }),

/***/ "./src/js/dao/Dao.js":
/*!***************************!*\
  !*** ./src/js/dao/Dao.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Dao)\n/* harmony export */ });\n/* harmony import */ var dexie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dexie */ \"./node_modules/dexie/dist/modern/dexie.mjs\");\n\r\n\r\nclass Dao {\r\n    constructor() {\r\n        this.db;\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this.db = new dexie__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"Orders\");\r\n\r\n        this.db.version(1).stores({\r\n            orders: `\r\n                id,\r\n                name,\r\n                phone,\r\n                description,\r\n                date,\r\n                price,\r\n                payment,\r\n                ok\r\n            `\r\n        });\r\n\r\n        this.db.open()\r\n            .catch(err => console.log(err));\r\n    }\r\n\r\n    createOrder(order) {\r\n        return new Promise((resolve, reject) => {\r\n            this.db.orders.bulkPut([order])\r\n                .then(res => {\r\n                    resolve(res);\r\n                })\r\n                .catch(err => console.log(err));\r\n        });\r\n    }\r\n\r\n    get(id) {\r\n        return new Promise((resolve, reject) => {\r\n            this.db.orders.get(id)\r\n                .then(order => resolve(order));\r\n        });\r\n    }\r\n\r\n    updateOrder(key, order) {\r\n        return new Promise((resolve, reject) => {\r\n            this.db.orders.update(key, order)\r\n                .then(res => resolve(res));\r\n        });\r\n    }\r\n\r\n    importOrders(orders) {\r\n        return new Promise((resolve, reject) => {\r\n            this.db.orders.bulkPut(orders)\r\n                .then(res => {\r\n                    resolve(res);\r\n                })\r\n                .catch(err => console.log(err));\r\n        });\r\n    }\r\n\r\n    clearData() {\r\n        this.db.orders.clear();\r\n    }\r\n\r\n    getOrders() {\r\n        return new Promise((resolve, reject) => {\r\n\r\n            this.db.table(\"orders\")\r\n                .toArray()\r\n                .then(orders => resolve(orders));\r\n        });\r\n    }\r\n}\n\n//# sourceURL=webpack://sit-almeida/./src/js/dao/Dao.js?");

/***/ }),

/***/ "./src/js/helper/Filter.js":
/*!*********************************!*\
  !*** ./src/js/helper/Filter.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Filter)\n/* harmony export */ });\nclass Filter {\r\n    constructor({ name, phone, description, price, date }) {\r\n        phone ? this.phone = phone.toUpperCase() : '';\r\n        name ? this.name = name.toUpperCase() : '';\r\n        description ? this.description = description.toUpperCase() : '';\r\n        price ? this.price = price.toUpperCase() : '';\r\n        date ? this.date = date.toUpperCase() : '';\r\n    }\r\n\r\n    eval(order) {\r\n        console.log(this);\r\n        for (const prop in this) {\r\n            if (prop == 'date') {\r\n                return new Date(order.date) >= new Date(this[prop]);\r\n            }\r\n            // if (!order[prop].includes(this[prop])) {\r\n            if (order[prop].match(new RegExp(this[prop], 'gi')) == null) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\n\n//# sourceURL=webpack://sit-almeida/./src/js/helper/Filter.js?");

/***/ }),

/***/ "./src/js/model/Order.js":
/*!*******************************!*\
  !*** ./src/js/model/Order.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Order)\n/* harmony export */ });\n/* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! md5 */ \"./node_modules/md5/md5.js\");\n/* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(md5__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var dateformat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dateformat */ \"./node_modules/dateformat/lib/dateformat.js\");\n\r\n\r\n\r\nclass Order {\r\n    constructor({ name, phone, date, description, price, payment, ok, id = undefined }) {\r\n        this.name = name;\r\n        this.phone = phone.replaceAll(/[^0-9]/g, '');\r\n\r\n        this.date = date;\r\n        this.description = description;\r\n        this.price = price;\r\n        this.payment = payment;\r\n        this.ok = ok;\r\n        this.id = id;\r\n\r\n        for (const prop in this) {\r\n            if (prop == 'ok' || prop == 'id') continue;\r\n            this[prop] = String(this[prop]).toUpperCase().trim();\r\n        }\r\n\r\n        this.init();\r\n    }\r\n\r\n    static template() {\r\n        return {\r\n            name: '',\r\n            phone: '',\r\n            date: '',\r\n            description: '',\r\n            price: '',\r\n            payment: '',\r\n            ok: '',\r\n        };\r\n    }\r\n\r\n    init() {\r\n        if (this.id == undefined)\r\n            this.id = md5__WEBPACK_IMPORTED_MODULE_0___default()(JSON.stringify(this));\r\n    }\r\n\r\n    dateForView() {\r\n        const day = new Date(this.date).getDay();\r\n\r\n        return (day == 0 ? \"Dom, \" :\r\n            day == 1 ? \"Seg, \" :\r\n                day == 2 ? \"Ter, \" :\r\n                    day == 3 ? \"Qua, \" :\r\n                        day == 4 ? \"Qui, \" :\r\n                            day == 5 ? \"Sex, \" :\r\n                                day == 6 ? \"Sab, \" : \"Err, \") + (0,dateformat__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.date, 'dd/mm/yyyy');\r\n    }\r\n}\n\n//# sourceURL=webpack://sit-almeida/./src/js/model/Order.js?");

/***/ }),

/***/ "./src/js/view/TableView.js":
/*!**********************************!*\
  !*** ./src/js/view/TableView.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TableView)\n/* harmony export */ });\nclass TableView {\r\n    constructor(target) {\r\n        this.target = target;\r\n    }\r\n\r\n    _templateLine(order, idx) {\r\n        return `\r\n    <div class=\"m_table_orders_order\" data-id=\"${order.id}\">\r\n        <span class=\"m_table_orders_order_field\" data-property=\"name\">\r\n        ${order.name}\r\n        </span>\r\n        <span class=\"m_table_orders_order_field\" data-property=\"phone\">\r\n        ${this._phoneFormatter(order.phone)}\r\n        </span>\r\n        <span class=\"m_table_orders_order_field\" data-property=\"description\">\r\n        ${order.description}\r\n        </span>\r\n        <span type=\"date\" class=\"m_table_orders_order_field\" data-property=\"date\">\r\n        ${order.dateForView()}\r\n        </span>\r\n        <span class=\"m_table_orders_order_field\" data-property=\"price\">\r\n        ${order.price}\r\n        </span>\r\n        <span class=\"m_table_orders_order_field\" data-property=\"payment\">\r\n        ${order.payment}\r\n        </span>\r\n        <input disabled type=\"checkbox\" class=\"m_table_orders_order_field\" data-property=\"ok\" ${order.ok ? 'checked=\"checked\"' : ''}>\r\n        \r\n    </div>`;\r\n    }\r\n\r\n    updateView(orders) {\r\n        this.target.innerHTML = orders.map((order, idx) => {\r\n            return this._templateLine(order, idx);\r\n        }).join('');\r\n\r\n        return this.target.children;\r\n    }\r\n\r\n    _phoneFormatter(rawString) {\r\n        const cleanPhone = rawString.replaceAll(/[^0-9]/g, '').substr(-12);\r\n        const len = cleanPhone.length;\r\n\r\n        let ddd = '71';\r\n        let phone;\r\n\r\n        switch (len) {\r\n            case 8:\r\n                phone = `${ddd} 9 ${cleanPhone.substr(0, 4)}-${cleanPhone.substr(4, 4)}`;\r\n                break;\r\n            case 9:\r\n                phone = `${ddd} 9 ${cleanPhone.substr(1, 4)}-${cleanPhone.substr(5, 4)}`;\r\n                break;\r\n            case 10:\r\n                ddd = cleanPhone.substr(0, 2);\r\n                phone = `${ddd} 9 ${cleanPhone.substr(2, 4)}-${cleanPhone.substr(6, 4)}`;\r\n                break;\r\n            case 11:\r\n                ddd = cleanPhone.substr(0, 2);\r\n                phone = `${ddd} 9 ${cleanPhone.substr(3, 4)}-${cleanPhone.substr(7, 4)}`;\r\n                break;\r\n            default:\r\n                phone = cleanPhone;\r\n        }\r\n\r\n        return phone;\r\n    }\r\n}\n\n//# sourceURL=webpack://sit-almeida/./src/js/view/TableView.js?");

/***/ }),

/***/ "./node_modules/dateformat/lib/dateformat.js":
/*!***************************************************!*\
  !*** ./node_modules/dateformat/lib/dateformat.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ dateFormat),\n/* harmony export */   \"masks\": () => (/* binding */ masks),\n/* harmony export */   \"i18n\": () => (/* binding */ i18n),\n/* harmony export */   \"formatTimezone\": () => (/* binding */ formatTimezone)\n/* harmony export */ });\nvar token=/d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\\1?|W{1,2}|[LlopSZN]|\"[^\"]*\"|'[^']*'/g;var timezone=/\\b(?:[A-Z]{1,3}[A-Z][TC])(?:[-+]\\d{4})?|((?:Australian )?(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time)\\b/g;var timezoneClip=/[^-+\\dA-Z]/g;function dateFormat(date,mask,utc,gmt){if(arguments.length===1&&typeof date===\"string\"&&!/\\d/.test(date)){mask=date;date=undefined}date=date||date===0?date:new Date;if(!(date instanceof Date)){date=new Date(date)}if(isNaN(date)){throw TypeError(\"Invalid date\")}mask=String(masks[mask]||mask||masks[\"default\"]);var maskSlice=mask.slice(0,4);if(maskSlice===\"UTC:\"||maskSlice===\"GMT:\"){mask=mask.slice(4);utc=true;if(maskSlice===\"GMT:\"){gmt=true}}var _=function _(){return utc?\"getUTC\":\"get\"};var _d=function d(){return date[_()+\"Date\"]()};var D=function D(){return date[_()+\"Day\"]()};var _m=function m(){return date[_()+\"Month\"]()};var y=function y(){return date[_()+\"FullYear\"]()};var _H=function H(){return date[_()+\"Hours\"]()};var _M=function M(){return date[_()+\"Minutes\"]()};var _s=function s(){return date[_()+\"Seconds\"]()};var _L=function L(){return date[_()+\"Milliseconds\"]()};var _o=function o(){return utc?0:date.getTimezoneOffset()};var _W=function W(){return getWeek(date)};var _N=function N(){return getDayOfWeek(date)};var flags={d:function d(){return _d()},dd:function dd(){return pad(_d())},ddd:function ddd(){return i18n.dayNames[D()]},DDD:function DDD(){return getDayName({y:y(),m:_m(),d:_d(),_:_(),dayName:i18n.dayNames[D()],short:true})},dddd:function dddd(){return i18n.dayNames[D()+7]},DDDD:function DDDD(){return getDayName({y:y(),m:_m(),d:_d(),_:_(),dayName:i18n.dayNames[D()+7]})},m:function m(){return _m()+1},mm:function mm(){return pad(_m()+1)},mmm:function mmm(){return i18n.monthNames[_m()]},mmmm:function mmmm(){return i18n.monthNames[_m()+12]},yy:function yy(){return String(y()).slice(2)},yyyy:function yyyy(){return pad(y(),4)},h:function h(){return _H()%12||12},hh:function hh(){return pad(_H()%12||12)},H:function H(){return _H()},HH:function HH(){return pad(_H())},M:function M(){return _M()},MM:function MM(){return pad(_M())},s:function s(){return _s()},ss:function ss(){return pad(_s())},l:function l(){return pad(_L(),3)},L:function L(){return pad(Math.floor(_L()/10))},t:function t(){return _H()<12?i18n.timeNames[0]:i18n.timeNames[1]},tt:function tt(){return _H()<12?i18n.timeNames[2]:i18n.timeNames[3]},T:function T(){return _H()<12?i18n.timeNames[4]:i18n.timeNames[5]},TT:function TT(){return _H()<12?i18n.timeNames[6]:i18n.timeNames[7]},Z:function Z(){return gmt?\"GMT\":utc?\"UTC\":formatTimezone(date)},o:function o(){return(_o()>0?\"-\":\"+\")+pad(Math.floor(Math.abs(_o())/60)*100+Math.abs(_o())%60,4)},p:function p(){return(_o()>0?\"-\":\"+\")+pad(Math.floor(Math.abs(_o())/60),2)+\":\"+pad(Math.floor(Math.abs(_o())%60),2)},S:function S(){return[\"th\",\"st\",\"nd\",\"rd\"][_d()%10>3?0:(_d()%100-_d()%10!=10)*_d()%10]},W:function W(){return _W()},WW:function WW(){return pad(_W())},N:function N(){return _N()}};return mask.replace(token,function(match){if(match in flags){return flags[match]()}return match.slice(1,match.length-1)})}var masks={default:\"ddd mmm dd yyyy HH:MM:ss\",shortDate:\"m/d/yy\",paddedShortDate:\"mm/dd/yyyy\",mediumDate:\"mmm d, yyyy\",longDate:\"mmmm d, yyyy\",fullDate:\"dddd, mmmm d, yyyy\",shortTime:\"h:MM TT\",mediumTime:\"h:MM:ss TT\",longTime:\"h:MM:ss TT Z\",isoDate:\"yyyy-mm-dd\",isoTime:\"HH:MM:ss\",isoDateTime:\"yyyy-mm-dd'T'HH:MM:sso\",isoUtcDateTime:\"UTC:yyyy-mm-dd'T'HH:MM:ss'Z'\",expiresHeaderFormat:\"ddd, dd mmm yyyy HH:MM:ss Z\"};var i18n={dayNames:[\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"],monthNames:[\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],timeNames:[\"a\",\"p\",\"am\",\"pm\",\"A\",\"P\",\"AM\",\"PM\"]};var pad=function pad(val){var len=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2;return String(val).padStart(len,\"0\")};var getDayName=function getDayName(_ref){var y=_ref.y,m=_ref.m,d=_ref.d,_=_ref._,dayName=_ref.dayName,_ref$short=_ref[\"short\"],_short=_ref$short===void 0?false:_ref$short;var today=new Date;var yesterday=new Date;yesterday.setDate(yesterday[_+\"Date\"]()-1);var tomorrow=new Date;tomorrow.setDate(tomorrow[_+\"Date\"]()+1);var today_d=function today_d(){return today[_+\"Date\"]()};var today_m=function today_m(){return today[_+\"Month\"]()};var today_y=function today_y(){return today[_+\"FullYear\"]()};var yesterday_d=function yesterday_d(){return yesterday[_+\"Date\"]()};var yesterday_m=function yesterday_m(){return yesterday[_+\"Month\"]()};var yesterday_y=function yesterday_y(){return yesterday[_+\"FullYear\"]()};var tomorrow_d=function tomorrow_d(){return tomorrow[_+\"Date\"]()};var tomorrow_m=function tomorrow_m(){return tomorrow[_+\"Month\"]()};var tomorrow_y=function tomorrow_y(){return tomorrow[_+\"FullYear\"]()};if(today_y()===y&&today_m()===m&&today_d()===d){return _short?\"Tdy\":\"Today\"}else if(yesterday_y()===y&&yesterday_m()===m&&yesterday_d()===d){return _short?\"Ysd\":\"Yesterday\"}else if(tomorrow_y()===y&&tomorrow_m()===m&&tomorrow_d()===d){return _short?\"Tmw\":\"Tomorrow\"}return dayName};var getWeek=function getWeek(date){var targetThursday=new Date(date.getFullYear(),date.getMonth(),date.getDate());targetThursday.setDate(targetThursday.getDate()-(targetThursday.getDay()+6)%7+3);var firstThursday=new Date(targetThursday.getFullYear(),0,4);firstThursday.setDate(firstThursday.getDate()-(firstThursday.getDay()+6)%7+3);var ds=targetThursday.getTimezoneOffset()-firstThursday.getTimezoneOffset();targetThursday.setHours(targetThursday.getHours()-ds);var weekDiff=(targetThursday-firstThursday)/(864e5*7);return 1+Math.floor(weekDiff)};var getDayOfWeek=function getDayOfWeek(date){var dow=date.getDay();if(dow===0){dow=7}return dow};var formatTimezone=function formatTimezone(date){return(String(date).match(timezone)||[\"\"]).pop().replace(timezoneClip,\"\").replace(/GMT\\+0000/g,\"UTC\")};\n\n//# sourceURL=webpack://sit-almeida/./node_modules/dateformat/lib/dateformat.js?");

/***/ }),

/***/ "./node_modules/dexie/dist/modern/dexie.mjs":
/*!**************************************************!*\
  !*** ./node_modules/dexie/dist/modern/dexie.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Dexie\": () => (/* binding */ Dexie$1),\n/* harmony export */   \"RangeSet\": () => (/* binding */ RangeSet),\n/* harmony export */   \"default\": () => (/* binding */ Dexie$1),\n/* harmony export */   \"liveQuery\": () => (/* binding */ liveQuery),\n/* harmony export */   \"mergeRanges\": () => (/* binding */ mergeRanges),\n/* harmony export */   \"rangesOverlap\": () => (/* binding */ rangesOverlap)\n/* harmony export */ });\n/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.0, Thu Nov 18 2021\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj)\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n        }\n        catch (ex) {\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '3.2.0';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&\n            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n        if (compoundIndex && this.db._maxKey !== maxString)\n            return this\n                .where(compoundIndex.name)\n                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = obj => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(e => {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(() => {\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(() => {\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans)) {\n                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(ev => {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(ev => {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }))]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            trans.create();\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    return new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                querying = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    addEventListener('storage', (ev) => {\n        if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n            const data = JSON.parse(ev.newValue);\n            if (data)\n                propagateLocally(data.changedParts);\n        }\n    });\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\n\n//# sourceMappingURL=dexie.mjs.map\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/dexie/dist/modern/dexie.mjs?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/compose-collection.js":
/*!**********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/compose-collection.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"composeCollection\": () => (/* binding */ composeCollection)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _resolve_block_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolve-block-map.js */ \"./node_modules/yaml/browser/dist/compose/resolve-block-map.js\");\n/* harmony import */ var _resolve_block_seq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resolve-block-seq.js */ \"./node_modules/yaml/browser/dist/compose/resolve-block-seq.js\");\n/* harmony import */ var _resolve_flow_collection_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resolve-flow-collection.js */ \"./node_modules/yaml/browser/dist/compose/resolve-flow-collection.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nfunction composeCollection(CN, ctx, token, tagToken, onError) {\r\n    let coll;\r\n    switch (token.type) {\r\n        case 'block-map': {\r\n            coll = (0,_resolve_block_map_js__WEBPACK_IMPORTED_MODULE_2__.resolveBlockMap)(CN, ctx, token, onError);\r\n            break;\r\n        }\r\n        case 'block-seq': {\r\n            coll = (0,_resolve_block_seq_js__WEBPACK_IMPORTED_MODULE_3__.resolveBlockSeq)(CN, ctx, token, onError);\r\n            break;\r\n        }\r\n        case 'flow-collection': {\r\n            coll = (0,_resolve_flow_collection_js__WEBPACK_IMPORTED_MODULE_4__.resolveFlowCollection)(CN, ctx, token, onError);\r\n            break;\r\n        }\r\n    }\r\n    if (!tagToken)\r\n        return coll;\r\n    const tagName = ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));\r\n    if (!tagName)\r\n        return coll;\r\n    // Cast needed due to: https://github.com/Microsoft/TypeScript/issues/3841\r\n    const Coll = coll.constructor;\r\n    if (tagName === '!' || tagName === Coll.tagName) {\r\n        coll.tag = Coll.tagName;\r\n        return coll;\r\n    }\r\n    const expType = (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isMap)(coll) ? 'map' : 'seq';\r\n    let tag = ctx.schema.tags.find(t => t.collection === expType && t.tag === tagName);\r\n    if (!tag) {\r\n        const kt = ctx.schema.knownTags[tagName];\r\n        if (kt && kt.collection === expType) {\r\n            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));\r\n            tag = kt;\r\n        }\r\n        else {\r\n            onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);\r\n            coll.tag = tagName;\r\n            return coll;\r\n        }\r\n    }\r\n    const res = tag.resolve(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options);\r\n    const node = (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isNode)(res)\r\n        ? res\r\n        : new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_1__.Scalar(res);\r\n    node.range = coll.range;\r\n    node.tag = tagName;\r\n    if (tag === null || tag === void 0 ? void 0 : tag.format)\r\n        node.format = tag.format;\r\n    return node;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/compose-collection.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/compose-doc.js":
/*!***************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/compose-doc.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"composeDoc\": () => (/* binding */ composeDoc)\n/* harmony export */ });\n/* harmony import */ var _doc_Document_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../doc/Document.js */ \"./node_modules/yaml/browser/dist/doc/Document.js\");\n/* harmony import */ var _compose_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose-node.js */ \"./node_modules/yaml/browser/dist/compose/compose-node.js\");\n/* harmony import */ var _resolve_end_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolve-end.js */ \"./node_modules/yaml/browser/dist/compose/resolve-end.js\");\n/* harmony import */ var _resolve_props_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resolve-props.js */ \"./node_modules/yaml/browser/dist/compose/resolve-props.js\");\n\r\n\r\n\r\n\r\n\r\nfunction composeDoc(options, directives, { offset, start, value, end }, onError) {\r\n    const opts = Object.assign({ directives }, options);\r\n    const doc = new _doc_Document_js__WEBPACK_IMPORTED_MODULE_0__.Document(undefined, opts);\r\n    const ctx = {\r\n        directives: doc.directives,\r\n        options: doc.options,\r\n        schema: doc.schema\r\n    };\r\n    const props = (0,_resolve_props_js__WEBPACK_IMPORTED_MODULE_3__.resolveProps)(start, {\r\n        indicator: 'doc-start',\r\n        next: value || (end === null || end === void 0 ? void 0 : end[0]),\r\n        offset,\r\n        onError,\r\n        startOnNewline: true\r\n    });\r\n    if (props.found) {\r\n        doc.directives.marker = true;\r\n        if (value &&\r\n            (value.type === 'block-map' || value.type === 'block-seq') &&\r\n            !props.hasNewline)\r\n            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');\r\n    }\r\n    doc.contents = value\r\n        ? (0,_compose_node_js__WEBPACK_IMPORTED_MODULE_1__.composeNode)(ctx, value, props, onError)\r\n        : (0,_compose_node_js__WEBPACK_IMPORTED_MODULE_1__.composeEmptyNode)(ctx, props.end, start, null, props, onError);\r\n    const contentEnd = doc.contents.range[2];\r\n    const re = (0,_resolve_end_js__WEBPACK_IMPORTED_MODULE_2__.resolveEnd)(end, contentEnd, false, onError);\r\n    if (re.comment)\r\n        doc.comment = re.comment;\r\n    doc.range = [offset, contentEnd, re.offset];\r\n    return doc;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/compose-doc.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/compose-node.js":
/*!****************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/compose-node.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"composeEmptyNode\": () => (/* binding */ composeEmptyNode),\n/* harmony export */   \"composeNode\": () => (/* binding */ composeNode)\n/* harmony export */ });\n/* harmony import */ var _nodes_Alias_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Alias.js */ \"./node_modules/yaml/browser/dist/nodes/Alias.js\");\n/* harmony import */ var _compose_collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./compose-collection.js */ \"./node_modules/yaml/browser/dist/compose/compose-collection.js\");\n/* harmony import */ var _compose_scalar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./compose-scalar.js */ \"./node_modules/yaml/browser/dist/compose/compose-scalar.js\");\n/* harmony import */ var _resolve_end_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resolve-end.js */ \"./node_modules/yaml/browser/dist/compose/resolve-end.js\");\n/* harmony import */ var _util_empty_scalar_position_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util-empty-scalar-position.js */ \"./node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst CN = { composeNode, composeEmptyNode };\r\nfunction composeNode(ctx, token, props, onError) {\r\n    const { spaceBefore, comment, anchor, tag } = props;\r\n    let node;\r\n    switch (token.type) {\r\n        case 'alias':\r\n            node = composeAlias(ctx, token, onError);\r\n            if (anchor || tag)\r\n                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');\r\n            break;\r\n        case 'scalar':\r\n        case 'single-quoted-scalar':\r\n        case 'double-quoted-scalar':\r\n        case 'block-scalar':\r\n            node = (0,_compose_scalar_js__WEBPACK_IMPORTED_MODULE_2__.composeScalar)(ctx, token, tag, onError);\r\n            if (anchor)\r\n                node.anchor = anchor.source.substring(1);\r\n            break;\r\n        case 'block-map':\r\n        case 'block-seq':\r\n        case 'flow-collection':\r\n            node = (0,_compose_collection_js__WEBPACK_IMPORTED_MODULE_1__.composeCollection)(CN, ctx, token, tag, onError);\r\n            if (anchor)\r\n                node.anchor = anchor.source.substring(1);\r\n            break;\r\n        default:\r\n            console.log(token);\r\n            throw new Error(`Unsupporten token type: ${token.type}`);\r\n    }\r\n    if (anchor && node.anchor === '')\r\n        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\r\n    if (spaceBefore)\r\n        node.spaceBefore = true;\r\n    if (comment) {\r\n        if (token.type === 'scalar' && token.source === '')\r\n            node.comment = comment;\r\n        else\r\n            node.commentBefore = comment;\r\n    }\r\n    if (ctx.options.keepSourceTokens)\r\n        node.srcToken = token;\r\n    return node;\r\n}\r\nfunction composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {\r\n    const token = {\r\n        type: 'scalar',\r\n        offset: (0,_util_empty_scalar_position_js__WEBPACK_IMPORTED_MODULE_4__.emptyScalarPosition)(offset, before, pos),\r\n        indent: -1,\r\n        source: ''\r\n    };\r\n    const node = (0,_compose_scalar_js__WEBPACK_IMPORTED_MODULE_2__.composeScalar)(ctx, token, tag, onError);\r\n    if (anchor) {\r\n        node.anchor = anchor.source.substring(1);\r\n        if (node.anchor === '')\r\n            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');\r\n    }\r\n    if (spaceBefore)\r\n        node.spaceBefore = true;\r\n    if (comment)\r\n        node.comment = comment;\r\n    return node;\r\n}\r\nfunction composeAlias({ options }, { offset, source, end }, onError) {\r\n    const alias = new _nodes_Alias_js__WEBPACK_IMPORTED_MODULE_0__.Alias(source.substring(1));\r\n    if (alias.source === '')\r\n        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');\r\n    const valueEnd = offset + source.length;\r\n    const re = (0,_resolve_end_js__WEBPACK_IMPORTED_MODULE_3__.resolveEnd)(end, valueEnd, options.strict, onError);\r\n    alias.range = [offset, valueEnd, re.offset];\r\n    if (re.comment)\r\n        alias.comment = re.comment;\r\n    return alias;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/compose-node.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/compose-scalar.js":
/*!******************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/compose-scalar.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"composeScalar\": () => (/* binding */ composeScalar)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _resolve_block_scalar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolve-block-scalar.js */ \"./node_modules/yaml/browser/dist/compose/resolve-block-scalar.js\");\n/* harmony import */ var _resolve_flow_scalar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resolve-flow-scalar.js */ \"./node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js\");\n\r\n\r\n\r\n\r\n\r\nfunction composeScalar(ctx, token, tagToken, onError) {\r\n    const { value, type, comment, range } = token.type === 'block-scalar'\r\n        ? (0,_resolve_block_scalar_js__WEBPACK_IMPORTED_MODULE_2__.resolveBlockScalar)(token, ctx.options.strict, onError)\r\n        : (0,_resolve_flow_scalar_js__WEBPACK_IMPORTED_MODULE_3__.resolveFlowScalar)(token, ctx.options.strict, onError);\r\n    const tagName = tagToken\r\n        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))\r\n        : null;\r\n    const tag = tagToken && tagName\r\n        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)\r\n        : findScalarTagByTest(ctx.schema, value, token.type === 'scalar');\r\n    let scalar;\r\n    try {\r\n        const res = tag.resolve(value, msg => onError(tagToken || token, 'TAG_RESOLVE_FAILED', msg), ctx.options);\r\n        scalar = (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isScalar)(res) ? res : new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_1__.Scalar(res);\r\n    }\r\n    catch (error) {\r\n        const msg = error instanceof Error ? error.message : String(error);\r\n        onError(tagToken || token, 'TAG_RESOLVE_FAILED', msg);\r\n        scalar = new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_1__.Scalar(value);\r\n    }\r\n    scalar.range = range;\r\n    scalar.source = value;\r\n    if (type)\r\n        scalar.type = type;\r\n    if (tagName)\r\n        scalar.tag = tagName;\r\n    if (tag.format)\r\n        scalar.format = tag.format;\r\n    if (comment)\r\n        scalar.comment = comment;\r\n    return scalar;\r\n}\r\nfunction findScalarTagByName(schema, value, tagName, tagToken, onError) {\r\n    var _a;\r\n    if (tagName === '!')\r\n        return schema[_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.SCALAR]; // non-specific tag\r\n    const matchWithTest = [];\r\n    for (const tag of schema.tags) {\r\n        if (!tag.collection && tag.tag === tagName) {\r\n            if (tag.default && tag.test)\r\n                matchWithTest.push(tag);\r\n            else\r\n                return tag;\r\n        }\r\n    }\r\n    for (const tag of matchWithTest)\r\n        if ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value))\r\n            return tag;\r\n    const kt = schema.knownTags[tagName];\r\n    if (kt && !kt.collection) {\r\n        // Ensure that the known tag is available for stringifying,\r\n        // but does not get used by default.\r\n        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));\r\n        return kt;\r\n    }\r\n    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');\r\n    return schema[_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.SCALAR];\r\n}\r\nfunction findScalarTagByTest(schema, value, apply) {\r\n    var _a;\r\n    if (apply) {\r\n        for (const tag of schema.tags) {\r\n            if (tag.default && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value)))\r\n                return tag;\r\n        }\r\n    }\r\n    return schema[_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.SCALAR];\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/compose-scalar.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/composer.js":
/*!************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/composer.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Composer\": () => (/* binding */ Composer)\n/* harmony export */ });\n/* harmony import */ var _doc_directives_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../doc/directives.js */ \"./node_modules/yaml/browser/dist/doc/directives.js\");\n/* harmony import */ var _doc_Document_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../doc/Document.js */ \"./node_modules/yaml/browser/dist/doc/Document.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/yaml/browser/dist/errors.js\");\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../options.js */ \"./node_modules/yaml/browser/dist/options.js\");\n/* harmony import */ var _compose_doc_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./compose-doc.js */ \"./node_modules/yaml/browser/dist/compose/compose-doc.js\");\n/* harmony import */ var _resolve_end_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./resolve-end.js */ \"./node_modules/yaml/browser/dist/compose/resolve-end.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction getErrorPos(src) {\r\n    if (typeof src === 'number')\r\n        return [src, src + 1];\r\n    if (Array.isArray(src))\r\n        return src.length === 2 ? src : [src[0], src[1]];\r\n    const { offset, source } = src;\r\n    return [offset, offset + (typeof source === 'string' ? source.length : 1)];\r\n}\r\nfunction parsePrelude(prelude) {\r\n    var _a;\r\n    let comment = '';\r\n    let atComment = false;\r\n    let afterEmptyLine = false;\r\n    for (let i = 0; i < prelude.length; ++i) {\r\n        const source = prelude[i];\r\n        switch (source[0]) {\r\n            case '#':\r\n                comment +=\r\n                    (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') +\r\n                        (source.substring(1) || ' ');\r\n                atComment = true;\r\n                afterEmptyLine = false;\r\n                break;\r\n            case '%':\r\n                if (((_a = prelude[i + 1]) === null || _a === void 0 ? void 0 : _a[0]) !== '#')\r\n                    i += 1;\r\n                atComment = false;\r\n                break;\r\n            default:\r\n                // This may be wrong after doc-end, but in that case it doesn't matter\r\n                if (!atComment)\r\n                    afterEmptyLine = true;\r\n                atComment = false;\r\n        }\r\n    }\r\n    return { comment, afterEmptyLine };\r\n}\r\n/**\r\n * Compose a stream of CST nodes into a stream of YAML Documents.\r\n *\r\n * ```ts\r\n * import { Composer, Parser } from 'yaml'\r\n *\r\n * const src: string = ...\r\n * const tokens = new Parser().parse(src)\r\n * const docs = new Composer().compose(tokens)\r\n * ```\r\n */\r\nclass Composer {\r\n    constructor(options = {}) {\r\n        this.doc = null;\r\n        this.atDirectives = false;\r\n        this.prelude = [];\r\n        this.errors = [];\r\n        this.warnings = [];\r\n        this.onError = (source, code, message, warning) => {\r\n            const pos = getErrorPos(source);\r\n            if (warning)\r\n                this.warnings.push(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.YAMLWarning(pos, code, message));\r\n            else\r\n                this.errors.push(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.YAMLParseError(pos, code, message));\r\n        };\r\n        this.directives = new _doc_directives_js__WEBPACK_IMPORTED_MODULE_0__.Directives({\r\n            version: options.version || _options_js__WEBPACK_IMPORTED_MODULE_4__.defaultOptions.version\r\n        });\r\n        this.options = options;\r\n    }\r\n    decorate(doc, afterDoc) {\r\n        const { comment, afterEmptyLine } = parsePrelude(this.prelude);\r\n        //console.log({ dc: doc.comment, prelude, comment })\r\n        if (comment) {\r\n            const dc = doc.contents;\r\n            if (afterDoc) {\r\n                doc.comment = doc.comment ? `${doc.comment}\\n${comment}` : comment;\r\n            }\r\n            else if (afterEmptyLine || doc.directives.marker || !dc) {\r\n                doc.commentBefore = comment;\r\n            }\r\n            else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_3__.isCollection)(dc) && !dc.flow && dc.items.length > 0) {\r\n                let it = dc.items[0];\r\n                if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_3__.isPair)(it))\r\n                    it = it.key;\r\n                const cb = it.commentBefore;\r\n                it.commentBefore = cb ? `${comment}\\n${cb}` : comment;\r\n            }\r\n            else {\r\n                const cb = dc.commentBefore;\r\n                dc.commentBefore = cb ? `${comment}\\n${cb}` : comment;\r\n            }\r\n        }\r\n        if (afterDoc) {\r\n            Array.prototype.push.apply(doc.errors, this.errors);\r\n            Array.prototype.push.apply(doc.warnings, this.warnings);\r\n        }\r\n        else {\r\n            doc.errors = this.errors;\r\n            doc.warnings = this.warnings;\r\n        }\r\n        this.prelude = [];\r\n        this.errors = [];\r\n        this.warnings = [];\r\n    }\r\n    /**\r\n     * Current stream status information.\r\n     *\r\n     * Mostly useful at the end of input for an empty stream.\r\n     */\r\n    streamInfo() {\r\n        return {\r\n            comment: parsePrelude(this.prelude).comment,\r\n            directives: this.directives,\r\n            errors: this.errors,\r\n            warnings: this.warnings\r\n        };\r\n    }\r\n    /**\r\n     * Compose tokens into documents.\r\n     *\r\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\r\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\r\n     */\r\n    *compose(tokens, forceDoc = false, endOffset = -1) {\r\n        for (const token of tokens)\r\n            yield* this.next(token);\r\n        yield* this.end(forceDoc, endOffset);\r\n    }\r\n    /** Advance the composer by one CST token. */\r\n    *next(token) {\r\n        switch (token.type) {\r\n            case 'directive':\r\n                this.directives.add(token.source, (offset, message, warning) => {\r\n                    const pos = getErrorPos(token);\r\n                    pos[0] += offset;\r\n                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);\r\n                });\r\n                this.prelude.push(token.source);\r\n                this.atDirectives = true;\r\n                break;\r\n            case 'document': {\r\n                const doc = (0,_compose_doc_js__WEBPACK_IMPORTED_MODULE_5__.composeDoc)(this.options, this.directives, token, this.onError);\r\n                if (this.atDirectives && !doc.directives.marker)\r\n                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end indicator line');\r\n                this.decorate(doc, false);\r\n                if (this.doc)\r\n                    yield this.doc;\r\n                this.doc = doc;\r\n                this.atDirectives = false;\r\n                break;\r\n            }\r\n            case 'byte-order-mark':\r\n            case 'space':\r\n                break;\r\n            case 'comment':\r\n            case 'newline':\r\n                this.prelude.push(token.source);\r\n                break;\r\n            case 'error': {\r\n                const msg = token.source\r\n                    ? `${token.message}: ${JSON.stringify(token.source)}`\r\n                    : token.message;\r\n                const error = new _errors_js__WEBPACK_IMPORTED_MODULE_2__.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\r\n                if (this.atDirectives || !this.doc)\r\n                    this.errors.push(error);\r\n                else\r\n                    this.doc.errors.push(error);\r\n                break;\r\n            }\r\n            case 'doc-end': {\r\n                if (!this.doc) {\r\n                    const msg = 'Unexpected doc-end without preceding document';\r\n                    this.errors.push(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\r\n                    break;\r\n                }\r\n                const end = (0,_resolve_end_js__WEBPACK_IMPORTED_MODULE_6__.resolveEnd)(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\r\n                this.decorate(this.doc, true);\r\n                if (end.comment) {\r\n                    const dc = this.doc.comment;\r\n                    this.doc.comment = dc ? `${dc}\\n${end.comment}` : end.comment;\r\n                }\r\n                this.doc.range[2] = end.offset;\r\n                break;\r\n            }\r\n            default:\r\n                this.errors.push(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));\r\n        }\r\n    }\r\n    /**\r\n     * Call at end of input to yield any remaining document.\r\n     *\r\n     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\r\n     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\r\n     */\r\n    *end(forceDoc = false, endOffset = -1) {\r\n        if (this.doc) {\r\n            this.decorate(this.doc, true);\r\n            yield this.doc;\r\n            this.doc = null;\r\n        }\r\n        else if (forceDoc) {\r\n            const opts = Object.assign({ directives: this.directives }, this.options);\r\n            const doc = new _doc_Document_js__WEBPACK_IMPORTED_MODULE_1__.Document(undefined, opts);\r\n            if (this.atDirectives)\r\n                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\r\n            doc.range = [0, endOffset, endOffset];\r\n            this.decorate(doc, false);\r\n            yield doc;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/composer.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/resolve-block-map.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/resolve-block-map.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveBlockMap\": () => (/* binding */ resolveBlockMap)\n/* harmony export */ });\n/* harmony import */ var _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Pair.js */ \"./node_modules/yaml/browser/dist/nodes/Pair.js\");\n/* harmony import */ var _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nodes/YAMLMap.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLMap.js\");\n/* harmony import */ var _resolve_props_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolve-props.js */ \"./node_modules/yaml/browser/dist/compose/resolve-props.js\");\n/* harmony import */ var _util_contains_newline_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util-contains-newline.js */ \"./node_modules/yaml/browser/dist/compose/util-contains-newline.js\");\n/* harmony import */ var _util_map_includes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util-map-includes.js */ \"./node_modules/yaml/browser/dist/compose/util-map-includes.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst startColMsg = 'All mapping items must start at the same column';\r\nfunction resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {\r\n    var _a;\r\n    const map = new _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_1__.YAMLMap(ctx.schema);\r\n    let offset = bm.offset;\r\n    for (const collItem of bm.items) {\r\n        const { start, key, sep, value } = collItem;\r\n        // key properties\r\n        const keyProps = (0,_resolve_props_js__WEBPACK_IMPORTED_MODULE_2__.resolveProps)(start, {\r\n            indicator: 'explicit-key-ind',\r\n            next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),\r\n            offset,\r\n            onError,\r\n            startOnNewline: true\r\n        });\r\n        const implicitKey = !keyProps.found;\r\n        if (implicitKey) {\r\n            if (key) {\r\n                if (key.type === 'block-seq')\r\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');\r\n                else if ('indent' in key && key.indent !== bm.indent)\r\n                    onError(offset, 'BAD_INDENT', startColMsg);\r\n            }\r\n            if (!keyProps.anchor && !keyProps.tag && !sep) {\r\n                // TODO: assert being at last item?\r\n                if (keyProps.comment) {\r\n                    if (map.comment)\r\n                        map.comment += '\\n' + keyProps.comment;\r\n                    else\r\n                        map.comment = keyProps.comment;\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n        else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)\r\n            onError(offset, 'BAD_INDENT', startColMsg);\r\n        if (implicitKey && (0,_util_contains_newline_js__WEBPACK_IMPORTED_MODULE_3__.containsNewline)(key))\r\n            onError(key, // checked by containsNewline()\r\n            'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');\r\n        // key value\r\n        const keyStart = keyProps.end;\r\n        const keyNode = key\r\n            ? composeNode(ctx, key, keyProps, onError)\r\n            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);\r\n        if ((0,_util_map_includes_js__WEBPACK_IMPORTED_MODULE_4__.mapIncludes)(ctx, map.items, keyNode))\r\n            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\r\n        // value properties\r\n        const valueProps = (0,_resolve_props_js__WEBPACK_IMPORTED_MODULE_2__.resolveProps)(sep || [], {\r\n            indicator: 'map-value-ind',\r\n            next: value,\r\n            offset: keyNode.range[2],\r\n            onError,\r\n            startOnNewline: !key || key.type === 'block-scalar'\r\n        });\r\n        offset = valueProps.end;\r\n        if (valueProps.found) {\r\n            if (implicitKey) {\r\n                if ((value === null || value === void 0 ? void 0 : value.type) === 'block-map' && !valueProps.hasNewline)\r\n                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');\r\n                if (ctx.options.strict &&\r\n                    keyProps.start < valueProps.found.offset - 1024)\r\n                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');\r\n            }\r\n            // value value\r\n            const valueNode = value\r\n                ? composeNode(ctx, value, valueProps, onError)\r\n                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);\r\n            offset = valueNode.range[2];\r\n            const pair = new _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_0__.Pair(keyNode, valueNode);\r\n            if (ctx.options.keepSourceTokens)\r\n                pair.srcToken = collItem;\r\n            map.items.push(pair);\r\n        }\r\n        else {\r\n            // key with no value\r\n            if (implicitKey)\r\n                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');\r\n            if (valueProps.comment) {\r\n                if (keyNode.comment)\r\n                    keyNode.comment += '\\n' + valueProps.comment;\r\n                else\r\n                    keyNode.comment = valueProps.comment;\r\n            }\r\n            const pair = new _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_0__.Pair(keyNode);\r\n            if (ctx.options.keepSourceTokens)\r\n                pair.srcToken = collItem;\r\n            map.items.push(pair);\r\n        }\r\n    }\r\n    map.range = [bm.offset, offset, offset];\r\n    return map;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/resolve-block-map.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/resolve-block-scalar.js":
/*!************************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/resolve-block-scalar.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveBlockScalar\": () => (/* binding */ resolveBlockScalar)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n\r\n\r\nfunction resolveBlockScalar(scalar, strict, onError) {\r\n    const start = scalar.offset;\r\n    const header = parseBlockScalarHeader(scalar, strict, onError);\r\n    if (!header)\r\n        return { value: '', type: null, comment: '', range: [start, start, start] };\r\n    const type = header.mode === '>' ? _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.BLOCK_FOLDED : _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.BLOCK_LITERAL;\r\n    const lines = scalar.source ? splitLines(scalar.source) : [];\r\n    // determine the end of content & start of chomping\r\n    let chompStart = lines.length;\r\n    for (let i = lines.length - 1; i >= 0; --i) {\r\n        const content = lines[i][1];\r\n        if (content === '' || content === '\\r')\r\n            chompStart = i;\r\n        else\r\n            break;\r\n    }\r\n    // shortcut for empty contents\r\n    if (!scalar.source || chompStart === 0) {\r\n        const value = header.chomp === '+' ? '\\n'.repeat(Math.max(0, lines.length - 1)) : '';\r\n        let end = start + header.length;\r\n        if (scalar.source)\r\n            end += scalar.source.length;\r\n        return { value, type, comment: header.comment, range: [start, end, end] };\r\n    }\r\n    // find the indentation level to trim from start\r\n    let trimIndent = scalar.indent + header.indent;\r\n    let offset = scalar.offset + header.length;\r\n    let contentStart = 0;\r\n    for (let i = 0; i < chompStart; ++i) {\r\n        const [indent, content] = lines[i];\r\n        if (content === '' || content === '\\r') {\r\n            if (header.indent === 0 && indent.length > trimIndent)\r\n                trimIndent = indent.length;\r\n        }\r\n        else {\r\n            if (indent.length < trimIndent) {\r\n                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\r\n                onError(offset + indent.length, 'MISSING_CHAR', message);\r\n            }\r\n            if (header.indent === 0)\r\n                trimIndent = indent.length;\r\n            contentStart = i;\r\n            break;\r\n        }\r\n        offset += indent.length + content.length + 1;\r\n    }\r\n    let value = '';\r\n    let sep = '';\r\n    let prevMoreIndented = false;\r\n    // leading whitespace is kept intact\r\n    for (let i = 0; i < contentStart; ++i)\r\n        value += lines[i][0].slice(trimIndent) + '\\n';\r\n    for (let i = contentStart; i < chompStart; ++i) {\r\n        let [indent, content] = lines[i];\r\n        offset += indent.length + content.length + 1;\r\n        const crlf = content[content.length - 1] === '\\r';\r\n        if (crlf)\r\n            content = content.slice(0, -1);\r\n        /* istanbul ignore if already caught in lexer */\r\n        if (content && indent.length < trimIndent) {\r\n            const src = header.indent\r\n                ? 'explicit indentation indicator'\r\n                : 'first line';\r\n            const message = `Block scalar lines must not be less indented than their ${src}`;\r\n            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);\r\n            indent = '';\r\n        }\r\n        if (type === _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.BLOCK_LITERAL) {\r\n            value += sep + indent.slice(trimIndent) + content;\r\n            sep = '\\n';\r\n        }\r\n        else if (indent.length > trimIndent || content[0] === '\\t') {\r\n            // more-indented content within a folded block\r\n            if (sep === ' ')\r\n                sep = '\\n';\r\n            else if (!prevMoreIndented && sep === '\\n')\r\n                sep = '\\n\\n';\r\n            value += sep + indent.slice(trimIndent) + content;\r\n            sep = '\\n';\r\n            prevMoreIndented = true;\r\n        }\r\n        else if (content === '') {\r\n            // empty line\r\n            if (sep === '\\n')\r\n                value += '\\n';\r\n            else\r\n                sep = '\\n';\r\n        }\r\n        else {\r\n            value += sep + content;\r\n            sep = ' ';\r\n            prevMoreIndented = false;\r\n        }\r\n    }\r\n    switch (header.chomp) {\r\n        case '-':\r\n            break;\r\n        case '+':\r\n            for (let i = chompStart; i < lines.length; ++i)\r\n                value += '\\n' + lines[i][0].slice(trimIndent);\r\n            if (value[value.length - 1] !== '\\n')\r\n                value += '\\n';\r\n            break;\r\n        default:\r\n            value += '\\n';\r\n    }\r\n    const end = start + header.length + scalar.source.length;\r\n    return { value, type, comment: header.comment, range: [start, end, end] };\r\n}\r\nfunction parseBlockScalarHeader({ offset, props }, strict, onError) {\r\n    /* istanbul ignore if should not happen */\r\n    if (props[0].type !== 'block-scalar-header') {\r\n        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');\r\n        return null;\r\n    }\r\n    const { source } = props[0];\r\n    const mode = source[0];\r\n    let indent = 0;\r\n    let chomp = '';\r\n    let error = -1;\r\n    for (let i = 1; i < source.length; ++i) {\r\n        const ch = source[i];\r\n        if (!chomp && (ch === '-' || ch === '+'))\r\n            chomp = ch;\r\n        else {\r\n            const n = Number(ch);\r\n            if (!indent && n)\r\n                indent = n;\r\n            else if (error === -1)\r\n                error = offset + i;\r\n        }\r\n    }\r\n    if (error !== -1)\r\n        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);\r\n    let hasSpace = false;\r\n    let comment = '';\r\n    let length = source.length;\r\n    for (let i = 1; i < props.length; ++i) {\r\n        const token = props[i];\r\n        switch (token.type) {\r\n            case 'space':\r\n                hasSpace = true;\r\n            // fallthrough\r\n            case 'newline':\r\n                length += token.source.length;\r\n                break;\r\n            case 'comment':\r\n                if (strict && !hasSpace) {\r\n                    const message = 'Comments must be separated from other tokens by white space characters';\r\n                    onError(token, 'MISSING_CHAR', message);\r\n                }\r\n                length += token.source.length;\r\n                comment = token.source.substring(1);\r\n                break;\r\n            case 'error':\r\n                onError(token, 'UNEXPECTED_TOKEN', token.message);\r\n                length += token.source.length;\r\n                break;\r\n            /* istanbul ignore next should not happen */\r\n            default: {\r\n                const message = `Unexpected token in block scalar header: ${token.type}`;\r\n                onError(token, 'UNEXPECTED_TOKEN', message);\r\n                const ts = token.source;\r\n                if (ts && typeof ts === 'string')\r\n                    length += ts.length;\r\n            }\r\n        }\r\n    }\r\n    return { mode, indent, chomp, comment, length };\r\n}\r\n/** @returns Array of lines split up as `[indent, content]` */\r\nfunction splitLines(source) {\r\n    const split = source.split(/\\n( *)/);\r\n    const first = split[0];\r\n    const m = first.match(/^( *)/);\r\n    const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ['', first];\r\n    const lines = [line0];\r\n    for (let i = 1; i < split.length; i += 2)\r\n        lines.push([split[i], split[i + 1]]);\r\n    return lines;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/resolve-block-scalar.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/resolve-block-seq.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/resolve-block-seq.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveBlockSeq\": () => (/* binding */ resolveBlockSeq)\n/* harmony export */ });\n/* harmony import */ var _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/YAMLSeq.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLSeq.js\");\n/* harmony import */ var _resolve_props_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-props.js */ \"./node_modules/yaml/browser/dist/compose/resolve-props.js\");\n\r\n\r\n\r\nfunction resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {\r\n    const seq = new _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_0__.YAMLSeq(ctx.schema);\r\n    let offset = bs.offset;\r\n    for (const { start, value } of bs.items) {\r\n        const props = (0,_resolve_props_js__WEBPACK_IMPORTED_MODULE_1__.resolveProps)(start, {\r\n            indicator: 'seq-item-ind',\r\n            next: value,\r\n            offset,\r\n            onError,\r\n            startOnNewline: true\r\n        });\r\n        offset = props.end;\r\n        if (!props.found) {\r\n            if (props.anchor || props.tag || value) {\r\n                if (value && value.type === 'block-seq')\r\n                    onError(offset, 'BAD_INDENT', 'All sequence items must start at the same column');\r\n                else\r\n                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');\r\n            }\r\n            else {\r\n                // TODO: assert being at last item?\r\n                if (props.comment)\r\n                    seq.comment = props.comment;\r\n                continue;\r\n            }\r\n        }\r\n        const node = value\r\n            ? composeNode(ctx, value, props, onError)\r\n            : composeEmptyNode(ctx, offset, start, null, props, onError);\r\n        offset = node.range[2];\r\n        seq.items.push(node);\r\n    }\r\n    seq.range = [bs.offset, offset, offset];\r\n    return seq;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/resolve-block-seq.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/resolve-end.js":
/*!***************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/resolve-end.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveEnd\": () => (/* binding */ resolveEnd)\n/* harmony export */ });\nfunction resolveEnd(end, offset, reqSpace, onError) {\r\n    let comment = '';\r\n    if (end) {\r\n        let hasSpace = false;\r\n        let sep = '';\r\n        for (const token of end) {\r\n            const { source, type } = token;\r\n            switch (type) {\r\n                case 'space':\r\n                    hasSpace = true;\r\n                    break;\r\n                case 'comment': {\r\n                    if (reqSpace && !hasSpace)\r\n                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\r\n                    const cb = source.substring(1) || ' ';\r\n                    if (!comment)\r\n                        comment = cb;\r\n                    else\r\n                        comment += sep + cb;\r\n                    sep = '';\r\n                    break;\r\n                }\r\n                case 'newline':\r\n                    if (comment)\r\n                        sep += source;\r\n                    hasSpace = true;\r\n                    break;\r\n                default:\r\n                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);\r\n            }\r\n            offset += source.length;\r\n        }\r\n    }\r\n    return { comment, offset };\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/resolve-end.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/resolve-flow-collection.js":
/*!***************************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/resolve-flow-collection.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveFlowCollection\": () => (/* binding */ resolveFlowCollection)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nodes/Pair.js */ \"./node_modules/yaml/browser/dist/nodes/Pair.js\");\n/* harmony import */ var _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nodes/YAMLMap.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLMap.js\");\n/* harmony import */ var _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../nodes/YAMLSeq.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLSeq.js\");\n/* harmony import */ var _resolve_end_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resolve-end.js */ \"./node_modules/yaml/browser/dist/compose/resolve-end.js\");\n/* harmony import */ var _resolve_props_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./resolve-props.js */ \"./node_modules/yaml/browser/dist/compose/resolve-props.js\");\n/* harmony import */ var _util_contains_newline_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util-contains-newline.js */ \"./node_modules/yaml/browser/dist/compose/util-contains-newline.js\");\n/* harmony import */ var _util_map_includes_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util-map-includes.js */ \"./node_modules/yaml/browser/dist/compose/util-map-includes.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst blockMsg = 'Block collections are not allowed within flow collections';\r\nconst isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');\r\nfunction resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {\r\n    const isMap = fc.start.source === '{';\r\n    const fcName = isMap ? 'flow map' : 'flow sequence';\r\n    const coll = isMap\r\n        ? new _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__.YAMLMap(ctx.schema)\r\n        : new _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_3__.YAMLSeq(ctx.schema);\r\n    coll.flow = true;\r\n    let offset = fc.offset;\r\n    for (let i = 0; i < fc.items.length; ++i) {\r\n        const collItem = fc.items[i];\r\n        const { start, key, sep, value } = collItem;\r\n        const props = (0,_resolve_props_js__WEBPACK_IMPORTED_MODULE_5__.resolveProps)(start, {\r\n            flow: fcName,\r\n            indicator: 'explicit-key-ind',\r\n            next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),\r\n            offset,\r\n            onError,\r\n            startOnNewline: false\r\n        });\r\n        if (!props.found) {\r\n            if (!props.anchor && !props.tag && !sep && !value) {\r\n                if (i === 0 && props.comma)\r\n                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\r\n                else if (i < fc.items.length - 1)\r\n                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);\r\n                if (props.comment) {\r\n                    if (coll.comment)\r\n                        coll.comment += '\\n' + props.comment;\r\n                    else\r\n                        coll.comment = props.comment;\r\n                }\r\n                continue;\r\n            }\r\n            if (!isMap && ctx.options.strict && (0,_util_contains_newline_js__WEBPACK_IMPORTED_MODULE_6__.containsNewline)(key))\r\n                onError(key, // checked by containsNewline()\r\n                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\r\n        }\r\n        if (i === 0) {\r\n            if (props.comma)\r\n                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);\r\n        }\r\n        else {\r\n            if (!props.comma)\r\n                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);\r\n            if (props.comment) {\r\n                let prevItemComment = '';\r\n                loop: for (const st of start) {\r\n                    switch (st.type) {\r\n                        case 'comma':\r\n                        case 'space':\r\n                            break;\r\n                        case 'comment':\r\n                            prevItemComment = st.source.substring(1);\r\n                            break loop;\r\n                        default:\r\n                            break loop;\r\n                    }\r\n                }\r\n                if (prevItemComment) {\r\n                    let prev = coll.items[coll.items.length - 1];\r\n                    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isPair)(prev))\r\n                        prev = prev.value || prev.key;\r\n                    if (prev.comment)\r\n                        prev.comment += '\\n' + prevItemComment;\r\n                    else\r\n                        prev.comment = prevItemComment;\r\n                    props.comment = props.comment.substring(prevItemComment.length + 1);\r\n                }\r\n            }\r\n        }\r\n        if (!isMap && !sep && !props.found) {\r\n            // item is a value in a seq\r\n            // → key & sep are empty, start does not include ? or :\r\n            const valueNode = value\r\n                ? composeNode(ctx, value, props, onError)\r\n                : composeEmptyNode(ctx, props.end, sep, null, props, onError);\r\n            coll.items.push(valueNode);\r\n            offset = valueNode.range[2];\r\n            if (isBlock(value))\r\n                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\r\n        }\r\n        else {\r\n            // item is a key+value pair\r\n            // key value\r\n            const keyStart = props.end;\r\n            const keyNode = key\r\n                ? composeNode(ctx, key, props, onError)\r\n                : composeEmptyNode(ctx, keyStart, start, null, props, onError);\r\n            if (isBlock(key))\r\n                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);\r\n            // value properties\r\n            const valueProps = (0,_resolve_props_js__WEBPACK_IMPORTED_MODULE_5__.resolveProps)(sep || [], {\r\n                flow: fcName,\r\n                indicator: 'map-value-ind',\r\n                next: value,\r\n                offset: keyNode.range[2],\r\n                onError,\r\n                startOnNewline: false\r\n            });\r\n            if (valueProps.found) {\r\n                if (!isMap && !props.found && ctx.options.strict) {\r\n                    if (sep)\r\n                        for (const st of sep) {\r\n                            if (st === valueProps.found)\r\n                                break;\r\n                            if (st.type === 'newline') {\r\n                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');\r\n                                break;\r\n                            }\r\n                        }\r\n                    if (props.start < valueProps.found.offset - 1024)\r\n                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');\r\n                }\r\n            }\r\n            else if (value) {\r\n                if ('source' in value && value.source && value.source[0] === ':')\r\n                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);\r\n                else\r\n                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);\r\n            }\r\n            // value value\r\n            const valueNode = value\r\n                ? composeNode(ctx, value, valueProps, onError)\r\n                : valueProps.found\r\n                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)\r\n                    : null;\r\n            if (valueNode) {\r\n                if (isBlock(value))\r\n                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);\r\n            }\r\n            else if (valueProps.comment) {\r\n                if (keyNode.comment)\r\n                    keyNode.comment += '\\n' + valueProps.comment;\r\n                else\r\n                    keyNode.comment = valueProps.comment;\r\n            }\r\n            const pair = new _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__.Pair(keyNode, valueNode);\r\n            if (ctx.options.keepSourceTokens)\r\n                pair.srcToken = collItem;\r\n            if (isMap) {\r\n                const map = coll;\r\n                if ((0,_util_map_includes_js__WEBPACK_IMPORTED_MODULE_7__.mapIncludes)(ctx, map.items, keyNode))\r\n                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');\r\n                map.items.push(pair);\r\n            }\r\n            else {\r\n                const map = new _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__.YAMLMap(ctx.schema);\r\n                map.flow = true;\r\n                map.items.push(pair);\r\n                coll.items.push(map);\r\n            }\r\n            offset = valueNode ? valueNode.range[2] : valueProps.end;\r\n        }\r\n    }\r\n    const expectedEnd = isMap ? '}' : ']';\r\n    const [ce, ...ee] = fc.end;\r\n    let cePos = offset;\r\n    if (ce && ce.source === expectedEnd)\r\n        cePos = ce.offset + ce.source.length;\r\n    else {\r\n        onError(offset + 1, 'MISSING_CHAR', `Expected ${fcName} to end with ${expectedEnd}`);\r\n        if (ce && ce.source.length !== 1)\r\n            ee.unshift(ce);\r\n    }\r\n    if (ee.length > 0) {\r\n        const end = (0,_resolve_end_js__WEBPACK_IMPORTED_MODULE_4__.resolveEnd)(ee, cePos, ctx.options.strict, onError);\r\n        if (end.comment) {\r\n            if (coll.comment)\r\n                coll.comment += '\\n' + end.comment;\r\n            else\r\n                coll.comment = end.comment;\r\n        }\r\n        coll.range = [fc.offset, cePos, end.offset];\r\n    }\r\n    else {\r\n        coll.range = [fc.offset, cePos, cePos];\r\n    }\r\n    return coll;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/resolve-flow-collection.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js":
/*!***********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveFlowScalar\": () => (/* binding */ resolveFlowScalar)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _resolve_end_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-end.js */ \"./node_modules/yaml/browser/dist/compose/resolve-end.js\");\n\r\n\r\n\r\nfunction resolveFlowScalar(scalar, strict, onError) {\r\n    const { offset, type, source, end } = scalar;\r\n    let _type;\r\n    let value;\r\n    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);\r\n    switch (type) {\r\n        case 'scalar':\r\n            _type = _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.PLAIN;\r\n            value = plainValue(source, _onError);\r\n            break;\r\n        case 'single-quoted-scalar':\r\n            _type = _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.QUOTE_SINGLE;\r\n            value = singleQuotedValue(source, _onError);\r\n            break;\r\n        case 'double-quoted-scalar':\r\n            _type = _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.QUOTE_DOUBLE;\r\n            value = doubleQuotedValue(source, _onError);\r\n            break;\r\n        /* istanbul ignore next should not happen */\r\n        default:\r\n            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);\r\n            return {\r\n                value: '',\r\n                type: null,\r\n                comment: '',\r\n                range: [offset, offset + source.length, offset + source.length]\r\n            };\r\n    }\r\n    const valueEnd = offset + source.length;\r\n    const re = (0,_resolve_end_js__WEBPACK_IMPORTED_MODULE_1__.resolveEnd)(end, valueEnd, strict, onError);\r\n    return {\r\n        value,\r\n        type: _type,\r\n        comment: re.comment,\r\n        range: [offset, valueEnd, re.offset]\r\n    };\r\n}\r\nfunction plainValue(source, onError) {\r\n    let badChar = '';\r\n    switch (source[0]) {\r\n        /* istanbul ignore next should not happen */\r\n        case '\\t':\r\n            badChar = 'a tab character';\r\n            break;\r\n        case ',':\r\n            badChar = 'flow indicator character ,';\r\n            break;\r\n        case '%':\r\n            badChar = 'directive indicator character %';\r\n            break;\r\n        case '|':\r\n        case '>': {\r\n            badChar = `block scalar indicator ${source[0]}`;\r\n            break;\r\n        }\r\n        case '@':\r\n        case '`': {\r\n            badChar = `reserved character ${source[0]}`;\r\n            break;\r\n        }\r\n    }\r\n    if (badChar)\r\n        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);\r\n    return foldLines(source);\r\n}\r\nfunction singleQuotedValue(source, onError) {\r\n    if (source[source.length - 1] !== \"'\" || source.length === 1)\r\n        onError(source.length, 'MISSING_CHAR', \"Missing closing 'quote\");\r\n    return foldLines(source.slice(1, -1)).replace(/''/g, \"'\");\r\n}\r\nfunction foldLines(source) {\r\n    /**\r\n     * The negative lookbehind here and in the `re` RegExp is to\r\n     * prevent causing a polynomial search time in certain cases.\r\n     *\r\n     * The try-catch is for Safari, which doesn't support this yet:\r\n     * https://caniuse.com/js-regexp-lookbehind\r\n     */\r\n    let first, line;\r\n    try {\r\n        first = new RegExp('(.*?)(?<![ \\t])[ \\t]*\\r?\\n', 'sy');\r\n        line = new RegExp('[ \\t]*(.*?)(?:(?<![ \\t])[ \\t]*)?\\r?\\n', 'sy');\r\n    }\r\n    catch (_) {\r\n        first = /(.*?)[ \\t]*\\r?\\n/sy;\r\n        line = /[ \\t]*(.*?)[ \\t]*\\r?\\n/sy;\r\n    }\r\n    let match = first.exec(source);\r\n    if (!match)\r\n        return source;\r\n    let res = match[1];\r\n    let sep = ' ';\r\n    let pos = first.lastIndex;\r\n    line.lastIndex = pos;\r\n    while ((match = line.exec(source))) {\r\n        if (match[1] === '') {\r\n            if (sep === '\\n')\r\n                res += sep;\r\n            else\r\n                sep = '\\n';\r\n        }\r\n        else {\r\n            res += sep + match[1];\r\n            sep = ' ';\r\n        }\r\n        pos = line.lastIndex;\r\n    }\r\n    const last = /[ \\t]*(.*)/sy;\r\n    last.lastIndex = pos;\r\n    match = last.exec(source);\r\n    return res + sep + ((match && match[1]) || '');\r\n}\r\nfunction doubleQuotedValue(source, onError) {\r\n    let res = '';\r\n    for (let i = 1; i < source.length - 1; ++i) {\r\n        const ch = source[i];\r\n        if (ch === '\\r' && source[i + 1] === '\\n')\r\n            continue;\r\n        if (ch === '\\n') {\r\n            const { fold, offset } = foldNewline(source, i);\r\n            res += fold;\r\n            i = offset;\r\n        }\r\n        else if (ch === '\\\\') {\r\n            let next = source[++i];\r\n            const cc = escapeCodes[next];\r\n            if (cc)\r\n                res += cc;\r\n            else if (next === '\\n') {\r\n                // skip escaped newlines, but still trim the following line\r\n                next = source[i + 1];\r\n                while (next === ' ' || next === '\\t')\r\n                    next = source[++i + 1];\r\n            }\r\n            else if (next === '\\r' && source[i + 1] === '\\n') {\r\n                // skip escaped CRLF newlines, but still trim the following line\r\n                next = source[++i + 1];\r\n                while (next === ' ' || next === '\\t')\r\n                    next = source[++i + 1];\r\n            }\r\n            else if (next === 'x' || next === 'u' || next === 'U') {\r\n                const length = { x: 2, u: 4, U: 8 }[next];\r\n                res += parseCharCode(source, i + 1, length, onError);\r\n                i += length;\r\n            }\r\n            else {\r\n                const raw = source.substr(i - 1, 2);\r\n                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\r\n                res += raw;\r\n            }\r\n        }\r\n        else if (ch === ' ' || ch === '\\t') {\r\n            // trim trailing whitespace\r\n            const wsStart = i;\r\n            let next = source[i + 1];\r\n            while (next === ' ' || next === '\\t')\r\n                next = source[++i + 1];\r\n            if (next !== '\\n' && !(next === '\\r' && source[i + 2] === '\\n'))\r\n                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;\r\n        }\r\n        else {\r\n            res += ch;\r\n        }\r\n    }\r\n    if (source[source.length - 1] !== '\"' || source.length === 1)\r\n        onError(source.length, 'MISSING_CHAR', 'Missing closing \"quote');\r\n    return res;\r\n}\r\n/**\r\n * Fold a single newline into a space, multiple newlines to N - 1 newlines.\r\n * Presumes `source[offset] === '\\n'`\r\n */\r\nfunction foldNewline(source, offset) {\r\n    let fold = '';\r\n    let ch = source[offset + 1];\r\n    while (ch === ' ' || ch === '\\t' || ch === '\\n' || ch === '\\r') {\r\n        if (ch === '\\r' && source[offset + 2] !== '\\n')\r\n            break;\r\n        if (ch === '\\n')\r\n            fold += '\\n';\r\n        offset += 1;\r\n        ch = source[offset + 1];\r\n    }\r\n    if (!fold)\r\n        fold = ' ';\r\n    return { fold, offset };\r\n}\r\nconst escapeCodes = {\r\n    '0': '\\0',\r\n    a: '\\x07',\r\n    b: '\\b',\r\n    e: '\\x1b',\r\n    f: '\\f',\r\n    n: '\\n',\r\n    r: '\\r',\r\n    t: '\\t',\r\n    v: '\\v',\r\n    N: '\\u0085',\r\n    _: '\\u00a0',\r\n    L: '\\u2028',\r\n    P: '\\u2029',\r\n    ' ': ' ',\r\n    '\"': '\"',\r\n    '/': '/',\r\n    '\\\\': '\\\\',\r\n    '\\t': '\\t'\r\n};\r\nfunction parseCharCode(source, offset, length, onError) {\r\n    const cc = source.substr(offset, length);\r\n    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\r\n    const code = ok ? parseInt(cc, 16) : NaN;\r\n    if (isNaN(code)) {\r\n        const raw = source.substr(offset - 2, length + 2);\r\n        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);\r\n        return raw;\r\n    }\r\n    return String.fromCodePoint(code);\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/resolve-props.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/resolve-props.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resolveProps\": () => (/* binding */ resolveProps)\n/* harmony export */ });\nfunction resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {\r\n    let spaceBefore = false;\r\n    let atNewline = startOnNewline;\r\n    let hasSpace = startOnNewline;\r\n    let comment = '';\r\n    let commentSep = '';\r\n    let hasNewline = false;\r\n    let reqSpace = false;\r\n    let anchor = null;\r\n    let tag = null;\r\n    let comma = null;\r\n    let found = null;\r\n    let start = null;\r\n    for (const token of tokens) {\r\n        if (reqSpace) {\r\n            if (token.type !== 'space' &&\r\n                token.type !== 'newline' &&\r\n                token.type !== 'comma')\r\n                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\r\n            reqSpace = false;\r\n        }\r\n        switch (token.type) {\r\n            case 'space':\r\n                // At the doc level, tabs at line start may be parsed\r\n                // as leading white space rather than indentation.\r\n                // In a flow collection, only the parser handles indent.\r\n                if (!flow &&\r\n                    atNewline &&\r\n                    indicator !== 'doc-start' &&\r\n                    token.source[0] === '\\t')\r\n                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');\r\n                hasSpace = true;\r\n                break;\r\n            case 'comment': {\r\n                if (!hasSpace)\r\n                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');\r\n                const cb = token.source.substring(1) || ' ';\r\n                if (!comment)\r\n                    comment = cb;\r\n                else\r\n                    comment += commentSep + cb;\r\n                commentSep = '';\r\n                atNewline = false;\r\n                break;\r\n            }\r\n            case 'newline':\r\n                if (atNewline) {\r\n                    if (comment)\r\n                        comment += token.source;\r\n                    else\r\n                        spaceBefore = true;\r\n                }\r\n                else\r\n                    commentSep += token.source;\r\n                atNewline = true;\r\n                hasNewline = true;\r\n                hasSpace = true;\r\n                break;\r\n            case 'anchor':\r\n                if (anchor)\r\n                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');\r\n                anchor = token;\r\n                if (start === null)\r\n                    start = token.offset;\r\n                atNewline = false;\r\n                hasSpace = false;\r\n                reqSpace = true;\r\n                break;\r\n            case 'tag': {\r\n                if (tag)\r\n                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');\r\n                tag = token;\r\n                if (start === null)\r\n                    start = token.offset;\r\n                atNewline = false;\r\n                hasSpace = false;\r\n                reqSpace = true;\r\n                break;\r\n            }\r\n            case indicator:\r\n                // Could here handle preceding comments differently\r\n                if (anchor || tag)\r\n                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);\r\n                found = token;\r\n                atNewline = false;\r\n                hasSpace = false;\r\n                break;\r\n            case 'comma':\r\n                if (flow) {\r\n                    if (comma)\r\n                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);\r\n                    comma = token;\r\n                    atNewline = false;\r\n                    hasSpace = false;\r\n                    break;\r\n                }\r\n            // else fallthrough\r\n            default:\r\n                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);\r\n                atNewline = false;\r\n                hasSpace = false;\r\n        }\r\n    }\r\n    const last = tokens[tokens.length - 1];\r\n    const end = last ? last.offset + last.source.length : offset;\r\n    if (reqSpace &&\r\n        next &&\r\n        next.type !== 'space' &&\r\n        next.type !== 'newline' &&\r\n        next.type !== 'comma' &&\r\n        (next.type !== 'scalar' || next.source !== ''))\r\n        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');\r\n    return {\r\n        comma,\r\n        found,\r\n        spaceBefore,\r\n        comment,\r\n        hasNewline,\r\n        anchor,\r\n        tag,\r\n        end,\r\n        start: start !== null && start !== void 0 ? start : end\r\n    };\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/resolve-props.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/util-contains-newline.js":
/*!*************************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/util-contains-newline.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"containsNewline\": () => (/* binding */ containsNewline)\n/* harmony export */ });\nfunction containsNewline(key) {\r\n    if (!key)\r\n        return null;\r\n    switch (key.type) {\r\n        case 'alias':\r\n        case 'scalar':\r\n        case 'double-quoted-scalar':\r\n        case 'single-quoted-scalar':\r\n            if (key.source.includes('\\n'))\r\n                return true;\r\n            if (key.end)\r\n                for (const st of key.end)\r\n                    if (st.type === 'newline')\r\n                        return true;\r\n            return false;\r\n        case 'flow-collection':\r\n            for (const it of key.items) {\r\n                for (const st of it.start)\r\n                    if (st.type === 'newline')\r\n                        return true;\r\n                if (it.sep)\r\n                    for (const st of it.sep)\r\n                        if (st.type === 'newline')\r\n                            return true;\r\n                if (containsNewline(it.key) || containsNewline(it.value))\r\n                    return true;\r\n            }\r\n            return false;\r\n        default:\r\n            return true;\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/util-contains-newline.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js":
/*!******************************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"emptyScalarPosition\": () => (/* binding */ emptyScalarPosition)\n/* harmony export */ });\nfunction emptyScalarPosition(offset, before, pos) {\r\n    if (before) {\r\n        if (pos === null)\r\n            pos = before.length;\r\n        for (let i = pos - 1; i >= 0; --i) {\r\n            let st = before[i];\r\n            switch (st.type) {\r\n                case 'space':\r\n                case 'comment':\r\n                case 'newline':\r\n                    offset -= st.source.length;\r\n                    continue;\r\n            }\r\n            // Technically, an empty scalar is immediately after the last non-empty\r\n            // node, but it's more useful to place it after any whitespace.\r\n            st = before[++i];\r\n            while ((st === null || st === void 0 ? void 0 : st.type) === 'space') {\r\n                offset += st.source.length;\r\n                st = before[++i];\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return offset;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/compose/util-map-includes.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/compose/util-map-includes.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"mapIncludes\": () => (/* binding */ mapIncludes)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n\r\n\r\nfunction mapIncludes(ctx, items, search) {\r\n    const { uniqueKeys } = ctx.options;\r\n    if (uniqueKeys === false)\r\n        return false;\r\n    const isEqual = typeof uniqueKeys === 'function'\r\n        ? uniqueKeys\r\n        : (a, b) => a === b ||\r\n            ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isScalar)(a) &&\r\n                (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isScalar)(b) &&\r\n                a.value === b.value &&\r\n                !(a.value === '<<' && ctx.schema.merge));\r\n    return items.some(pair => isEqual(pair.key, search));\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/compose/util-map-includes.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/doc/Document.js":
/*!********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/doc/Document.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Document\": () => (/* binding */ Document)\n/* harmony export */ });\n/* harmony import */ var _nodes_Alias_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Alias.js */ \"./node_modules/yaml/browser/dist/nodes/Alias.js\");\n/* harmony import */ var _nodes_Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nodes/Collection.js */ \"./node_modules/yaml/browser/dist/nodes/Collection.js\");\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../nodes/Pair.js */ \"./node_modules/yaml/browser/dist/nodes/Pair.js\");\n/* harmony import */ var _nodes_toJS_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../nodes/toJS.js */ \"./node_modules/yaml/browser/dist/nodes/toJS.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../options.js */ \"./node_modules/yaml/browser/dist/options.js\");\n/* harmony import */ var _schema_Schema_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../schema/Schema.js */ \"./node_modules/yaml/browser/dist/schema/Schema.js\");\n/* harmony import */ var _stringify_stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../stringify/stringify.js */ \"./node_modules/yaml/browser/dist/stringify/stringify.js\");\n/* harmony import */ var _stringify_stringifyDocument_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../stringify/stringifyDocument.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyDocument.js\");\n/* harmony import */ var _anchors_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./anchors.js */ \"./node_modules/yaml/browser/dist/doc/anchors.js\");\n/* harmony import */ var _applyReviver_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./applyReviver.js */ \"./node_modules/yaml/browser/dist/doc/applyReviver.js\");\n/* harmony import */ var _createNode_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./createNode.js */ \"./node_modules/yaml/browser/dist/doc/createNode.js\");\n/* harmony import */ var _directives_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./directives.js */ \"./node_modules/yaml/browser/dist/doc/directives.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Document {\r\n    constructor(value, replacer, options) {\r\n        /** A comment before this Document */\r\n        this.commentBefore = null;\r\n        /** A comment immediately after this Document */\r\n        this.comment = null;\r\n        /** Errors encountered during parsing. */\r\n        this.errors = [];\r\n        /** Warnings encountered during parsing. */\r\n        this.warnings = [];\r\n        Object.defineProperty(this, _nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.NODE_TYPE, { value: _nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.DOC });\r\n        let _replacer = null;\r\n        if (typeof replacer === 'function' || Array.isArray(replacer)) {\r\n            _replacer = replacer;\r\n        }\r\n        else if (options === undefined && replacer) {\r\n            options = replacer;\r\n            replacer = undefined;\r\n        }\r\n        const opt = Object.assign({}, _options_js__WEBPACK_IMPORTED_MODULE_5__.defaultOptions, options);\r\n        this.options = opt;\r\n        let { version } = opt;\r\n        if (options === null || options === void 0 ? void 0 : options.directives) {\r\n            this.directives = options.directives.atDocument();\r\n            if (this.directives.yaml.explicit)\r\n                version = this.directives.yaml.version;\r\n        }\r\n        else\r\n            this.directives = new _directives_js__WEBPACK_IMPORTED_MODULE_12__.Directives({ version });\r\n        this.setSchema(version, options);\r\n        if (value === undefined)\r\n            this.contents = null;\r\n        else {\r\n            this.contents = this.createNode(value, _replacer, options);\r\n        }\r\n    }\r\n    /**\r\n     * Create a deep copy of this Document and its contents.\r\n     *\r\n     * Custom Node values that inherit from `Object` still refer to their original instances.\r\n     */\r\n    clone() {\r\n        const copy = Object.create(Document.prototype, {\r\n            [_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.NODE_TYPE]: { value: _nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.DOC }\r\n        });\r\n        copy.commentBefore = this.commentBefore;\r\n        copy.comment = this.comment;\r\n        copy.errors = this.errors.slice();\r\n        copy.warnings = this.warnings.slice();\r\n        copy.options = Object.assign({}, this.options);\r\n        copy.directives = this.directives.clone();\r\n        copy.schema = this.schema.clone();\r\n        copy.contents = (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isNode)(this.contents)\r\n            ? this.contents.clone(copy.schema)\r\n            : this.contents;\r\n        if (this.range)\r\n            copy.range = this.range.slice();\r\n        return copy;\r\n    }\r\n    /** Adds a value to the document. */\r\n    add(value) {\r\n        if (assertCollection(this.contents))\r\n            this.contents.add(value);\r\n    }\r\n    /** Adds a value to the document. */\r\n    addIn(path, value) {\r\n        if (assertCollection(this.contents))\r\n            this.contents.addIn(path, value);\r\n    }\r\n    /**\r\n     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.\r\n     *\r\n     * If `node` already has an anchor, `name` is ignored.\r\n     * Otherwise, the `node.anchor` value will be set to `name`,\r\n     * or if an anchor with that name is already present in the document,\r\n     * `name` will be used as a prefix for a new unique anchor.\r\n     * If `name` is undefined, the generated anchor will use 'a' as a prefix.\r\n     */\r\n    createAlias(node, name) {\r\n        if (!node.anchor) {\r\n            const prev = (0,_anchors_js__WEBPACK_IMPORTED_MODULE_9__.anchorNames)(this);\r\n            node.anchor =\r\n                !name || prev.has(name) ? (0,_anchors_js__WEBPACK_IMPORTED_MODULE_9__.findNewAnchor)(name || 'a', prev) : name;\r\n        }\r\n        return new _nodes_Alias_js__WEBPACK_IMPORTED_MODULE_0__.Alias(node.anchor);\r\n    }\r\n    createNode(value, replacer, options) {\r\n        let _replacer = undefined;\r\n        if (typeof replacer === 'function') {\r\n            value = replacer.call({ '': value }, '', value);\r\n            _replacer = replacer;\r\n        }\r\n        else if (Array.isArray(replacer)) {\r\n            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;\r\n            const asStr = replacer.filter(keyToStr).map(String);\r\n            if (asStr.length > 0)\r\n                replacer = replacer.concat(asStr);\r\n            _replacer = replacer;\r\n        }\r\n        else if (options === undefined && replacer) {\r\n            options = replacer;\r\n            replacer = undefined;\r\n        }\r\n        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options || {};\r\n        const { onAnchor, setAnchors, sourceObjects } = (0,_anchors_js__WEBPACK_IMPORTED_MODULE_9__.createNodeAnchors)(this, anchorPrefix || 'a');\r\n        const ctx = {\r\n            aliasDuplicateObjects: aliasDuplicateObjects !== null && aliasDuplicateObjects !== void 0 ? aliasDuplicateObjects : true,\r\n            keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,\r\n            onAnchor,\r\n            onTagObj,\r\n            replacer: _replacer,\r\n            schema: this.schema,\r\n            sourceObjects\r\n        };\r\n        const node = (0,_createNode_js__WEBPACK_IMPORTED_MODULE_11__.createNode)(value, tag, ctx);\r\n        if (flow && (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isCollection)(node))\r\n            node.flow = true;\r\n        setAnchors();\r\n        return node;\r\n    }\r\n    /**\r\n     * Convert a key and a value into a `Pair` using the current schema,\r\n     * recursively wrapping all values as `Scalar` or `Collection` nodes.\r\n     */\r\n    createPair(key, value, options = {}) {\r\n        const k = this.createNode(key, null, options);\r\n        const v = this.createNode(value, null, options);\r\n        return new _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_3__.Pair(k, v);\r\n    }\r\n    /**\r\n     * Removes a value from the document.\r\n     * @returns `true` if the item was found and removed.\r\n     */\r\n    delete(key) {\r\n        return assertCollection(this.contents) ? this.contents.delete(key) : false;\r\n    }\r\n    /**\r\n     * Removes a value from the document.\r\n     * @returns `true` if the item was found and removed.\r\n     */\r\n    deleteIn(path) {\r\n        if ((0,_nodes_Collection_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyPath)(path)) {\r\n            if (this.contents == null)\r\n                return false;\r\n            this.contents = null;\r\n            return true;\r\n        }\r\n        return assertCollection(this.contents)\r\n            ? this.contents.deleteIn(path)\r\n            : false;\r\n    }\r\n    /**\r\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\r\n     * scalar values from their surrounding node; to disable set `keepScalar` to\r\n     * `true` (collections are always returned intact).\r\n     */\r\n    get(key, keepScalar) {\r\n        return (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isCollection)(this.contents)\r\n            ? this.contents.get(key, keepScalar)\r\n            : undefined;\r\n    }\r\n    /**\r\n     * Returns item at `path`, or `undefined` if not found. By default unwraps\r\n     * scalar values from their surrounding node; to disable set `keepScalar` to\r\n     * `true` (collections are always returned intact).\r\n     */\r\n    getIn(path, keepScalar) {\r\n        if ((0,_nodes_Collection_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyPath)(path))\r\n            return !keepScalar && (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isScalar)(this.contents)\r\n                ? this.contents.value\r\n                : this.contents;\r\n        return (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isCollection)(this.contents)\r\n            ? this.contents.getIn(path, keepScalar)\r\n            : undefined;\r\n    }\r\n    /**\r\n     * Checks if the document includes a value with the key `key`.\r\n     */\r\n    has(key) {\r\n        return (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isCollection)(this.contents) ? this.contents.has(key) : false;\r\n    }\r\n    /**\r\n     * Checks if the document includes a value at `path`.\r\n     */\r\n    hasIn(path) {\r\n        if ((0,_nodes_Collection_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyPath)(path))\r\n            return this.contents !== undefined;\r\n        return (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isCollection)(this.contents) ? this.contents.hasIn(path) : false;\r\n    }\r\n    /**\r\n     * Sets a value in this document. For `!!set`, `value` needs to be a\r\n     * boolean to add/remove the item from the set.\r\n     */\r\n    set(key, value) {\r\n        if (this.contents == null) {\r\n            this.contents = (0,_nodes_Collection_js__WEBPACK_IMPORTED_MODULE_1__.collectionFromPath)(this.schema, [key], value);\r\n        }\r\n        else if (assertCollection(this.contents)) {\r\n            this.contents.set(key, value);\r\n        }\r\n    }\r\n    /**\r\n     * Sets a value in this document. For `!!set`, `value` needs to be a\r\n     * boolean to add/remove the item from the set.\r\n     */\r\n    setIn(path, value) {\r\n        if ((0,_nodes_Collection_js__WEBPACK_IMPORTED_MODULE_1__.isEmptyPath)(path))\r\n            this.contents = value;\r\n        else if (this.contents == null) {\r\n            this.contents = (0,_nodes_Collection_js__WEBPACK_IMPORTED_MODULE_1__.collectionFromPath)(this.schema, Array.from(path), value);\r\n        }\r\n        else if (assertCollection(this.contents)) {\r\n            this.contents.setIn(path, value);\r\n        }\r\n    }\r\n    /**\r\n     * Change the YAML version and schema used by the document.\r\n     *\r\n     * Overrides all previously set schema options\r\n     */\r\n    setSchema(version, options) {\r\n        let _options;\r\n        switch (String(version)) {\r\n            case '1.1':\r\n                this.directives.yaml.version = '1.1';\r\n                _options = Object.assign({ merge: true, resolveKnownTags: false, schema: 'yaml-1.1' }, options);\r\n                break;\r\n            case '1.2':\r\n                this.directives.yaml.version = '1.2';\r\n                _options = Object.assign({ merge: false, resolveKnownTags: true, schema: 'core' }, options);\r\n                break;\r\n            default: {\r\n                const sv = JSON.stringify(version);\r\n                throw new Error(`Expected '1.1' or '1.2' as version, but found: ${sv}`);\r\n            }\r\n        }\r\n        this.schema = new _schema_Schema_js__WEBPACK_IMPORTED_MODULE_6__.Schema(_options);\r\n    }\r\n    // json & jsonArg are only used from toJSON()\r\n    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {\r\n        const ctx = {\r\n            anchors: new Map(),\r\n            doc: this,\r\n            keep: !json,\r\n            mapAsMap: mapAsMap === true,\r\n            mapKeyWarned: false,\r\n            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,\r\n            stringify: _stringify_stringify_js__WEBPACK_IMPORTED_MODULE_7__.stringify\r\n        };\r\n        const res = (0,_nodes_toJS_js__WEBPACK_IMPORTED_MODULE_4__.toJS)(this.contents, jsonArg || '', ctx);\r\n        if (typeof onAnchor === 'function')\r\n            for (const { count, res } of ctx.anchors.values())\r\n                onAnchor(res, count);\r\n        return typeof reviver === 'function'\r\n            ? (0,_applyReviver_js__WEBPACK_IMPORTED_MODULE_10__.applyReviver)(reviver, { '': res }, '', res)\r\n            : res;\r\n    }\r\n    /**\r\n     * A JSON representation of the document `contents`.\r\n     *\r\n     * @param jsonArg Used by `JSON.stringify` to indicate the array index or\r\n     *   property name.\r\n     */\r\n    toJSON(jsonArg, onAnchor) {\r\n        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });\r\n    }\r\n    /** A YAML representation of the document. */\r\n    toString(options = {}) {\r\n        if (this.errors.length > 0)\r\n            throw new Error('Document with errors cannot be stringified');\r\n        if ('indent' in options &&\r\n            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {\r\n            const s = JSON.stringify(options.indent);\r\n            throw new Error(`\"indent\" option must be a positive integer, not ${s}`);\r\n        }\r\n        return (0,_stringify_stringifyDocument_js__WEBPACK_IMPORTED_MODULE_8__.stringifyDocument)(this, options);\r\n    }\r\n}\r\nfunction assertCollection(contents) {\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isCollection)(contents))\r\n        return true;\r\n    throw new Error('Expected a YAML collection as document contents');\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/doc/Document.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/doc/anchors.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/browser/dist/doc/anchors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"anchorIsValid\": () => (/* binding */ anchorIsValid),\n/* harmony export */   \"anchorNames\": () => (/* binding */ anchorNames),\n/* harmony export */   \"createNodeAnchors\": () => (/* binding */ createNodeAnchors),\n/* harmony export */   \"findNewAnchor\": () => (/* binding */ findNewAnchor)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../visit.js */ \"./node_modules/yaml/browser/dist/visit.js\");\n\r\n\r\n\r\n/**\r\n * Verify that the input string is a valid anchor.\r\n *\r\n * Will throw on errors.\r\n */\r\nfunction anchorIsValid(anchor) {\r\n    if (/[\\x00-\\x19\\s,[\\]{}]/.test(anchor)) {\r\n        const sa = JSON.stringify(anchor);\r\n        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;\r\n        throw new Error(msg);\r\n    }\r\n    return true;\r\n}\r\nfunction anchorNames(root) {\r\n    const anchors = new Set();\r\n    (0,_visit_js__WEBPACK_IMPORTED_MODULE_1__.visit)(root, {\r\n        Value(_key, node) {\r\n            if (node.anchor)\r\n                anchors.add(node.anchor);\r\n        }\r\n    });\r\n    return anchors;\r\n}\r\n/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */\r\nfunction findNewAnchor(prefix, exclude) {\r\n    for (let i = 1; true; ++i) {\r\n        const name = `${prefix}${i}`;\r\n        if (!exclude.has(name))\r\n            return name;\r\n    }\r\n}\r\nfunction createNodeAnchors(doc, prefix) {\r\n    const aliasObjects = [];\r\n    const sourceObjects = new Map();\r\n    let prevAnchors = null;\r\n    return {\r\n        onAnchor(source) {\r\n            aliasObjects.push(source);\r\n            if (!prevAnchors)\r\n                prevAnchors = anchorNames(doc);\r\n            const anchor = findNewAnchor(prefix, prevAnchors);\r\n            prevAnchors.add(anchor);\r\n            return anchor;\r\n        },\r\n        /**\r\n         * With circular references, the source node is only resolved after all\r\n         * of its child nodes are. This is why anchors are set only after all of\r\n         * the nodes have been created.\r\n         */\r\n        setAnchors() {\r\n            for (const source of aliasObjects) {\r\n                const ref = sourceObjects.get(source);\r\n                if (typeof ref === 'object' &&\r\n                    ref.anchor &&\r\n                    ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isScalar)(ref.node) || (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isCollection)(ref.node))) {\r\n                    ref.node.anchor = ref.anchor;\r\n                }\r\n                else {\r\n                    const error = new Error('Failed to resolve repeated object (this should not happen)');\r\n                    error.source = source;\r\n                    throw error;\r\n                }\r\n            }\r\n        },\r\n        sourceObjects\r\n    };\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/doc/anchors.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/doc/applyReviver.js":
/*!************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/doc/applyReviver.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyReviver\": () => (/* binding */ applyReviver)\n/* harmony export */ });\n/**\r\n * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,\r\n * in section 24.5.1.1 \"Runtime Semantics: InternalizeJSONProperty\" of the\r\n * 2021 edition: https://tc39.es/ecma262/#sec-json.parse\r\n *\r\n * Includes extensions for handling Map and Set objects.\r\n */\r\nfunction applyReviver(reviver, obj, key, val) {\r\n    if (val && typeof val === 'object') {\r\n        if (Array.isArray(val)) {\r\n            for (let i = 0, len = val.length; i < len; ++i) {\r\n                const v0 = val[i];\r\n                const v1 = applyReviver(reviver, val, String(i), v0);\r\n                if (v1 === undefined)\r\n                    delete val[i];\r\n                else if (v1 !== v0)\r\n                    val[i] = v1;\r\n            }\r\n        }\r\n        else if (val instanceof Map) {\r\n            for (const k of Array.from(val.keys())) {\r\n                const v0 = val.get(k);\r\n                const v1 = applyReviver(reviver, val, k, v0);\r\n                if (v1 === undefined)\r\n                    val.delete(k);\r\n                else if (v1 !== v0)\r\n                    val.set(k, v1);\r\n            }\r\n        }\r\n        else if (val instanceof Set) {\r\n            for (const v0 of Array.from(val)) {\r\n                const v1 = applyReviver(reviver, val, v0, v0);\r\n                if (v1 === undefined)\r\n                    val.delete(v0);\r\n                else if (v1 !== v0) {\r\n                    val.delete(v0);\r\n                    val.add(v1);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (const [k, v0] of Object.entries(val)) {\r\n                const v1 = applyReviver(reviver, val, k, v0);\r\n                if (v1 === undefined)\r\n                    delete val[k];\r\n                else if (v1 !== v0)\r\n                    val[k] = v1;\r\n            }\r\n        }\r\n    }\r\n    return reviver.call(obj, key, val);\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/doc/applyReviver.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/doc/createNode.js":
/*!**********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/doc/createNode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createNode\": () => (/* binding */ createNode)\n/* harmony export */ });\n/* harmony import */ var _nodes_Alias_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Alias.js */ \"./node_modules/yaml/browser/dist/nodes/Alias.js\");\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n\r\n\r\n\r\n\r\nconst defaultTagPrefix = 'tag:yaml.org,2002:';\r\nfunction findTagObject(value, tagName, tags) {\r\n    if (tagName) {\r\n        const match = tags.filter(t => t.tag === tagName);\r\n        const tagObj = match.find(t => !t.format) || match[0];\r\n        if (!tagObj)\r\n            throw new Error(`Tag ${tagName} not found`);\r\n        return tagObj;\r\n    }\r\n    return tags.find(t => t.identify && t.identify(value) && !t.format);\r\n}\r\nfunction createNode(value, tagName, ctx) {\r\n    var _a, _b;\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isDocument)(value))\r\n        value = value.contents;\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isNode)(value))\r\n        return value;\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isPair)(value)) {\r\n        const map = (_b = (_a = ctx.schema[_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);\r\n        map.items.push(value);\r\n        return map;\r\n    }\r\n    if (value instanceof String ||\r\n        value instanceof Number ||\r\n        value instanceof Boolean ||\r\n        (typeof BigInt === 'function' && value instanceof BigInt) // not supported everywhere\r\n    ) {\r\n        // https://tc39.es/ecma262/#sec-serializejsonproperty\r\n        value = value.valueOf();\r\n    }\r\n    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;\r\n    // Detect duplicate references to the same object & use Alias nodes for all\r\n    // after first. The `ref` wrapper allows for circular references to resolve.\r\n    let ref = undefined;\r\n    if (aliasDuplicateObjects && value && typeof value === 'object') {\r\n        ref = sourceObjects.get(value);\r\n        if (ref) {\r\n            if (!ref.anchor)\r\n                ref.anchor = onAnchor(value);\r\n            return new _nodes_Alias_js__WEBPACK_IMPORTED_MODULE_0__.Alias(ref.anchor);\r\n        }\r\n        else {\r\n            ref = { anchor: null, node: null };\r\n            sourceObjects.set(value, ref);\r\n        }\r\n    }\r\n    if (tagName && tagName.startsWith('!!'))\r\n        tagName = defaultTagPrefix + tagName.slice(2);\r\n    let tagObj = findTagObject(value, tagName, schema.tags);\r\n    if (!tagObj) {\r\n        if (value && typeof value.toJSON === 'function')\r\n            value = value.toJSON();\r\n        if (!value || typeof value !== 'object') {\r\n            const node = new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_2__.Scalar(value);\r\n            if (ref)\r\n                ref.node = node;\r\n            return node;\r\n        }\r\n        tagObj =\r\n            value instanceof Map\r\n                ? schema[_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.MAP]\r\n                : Symbol.iterator in Object(value)\r\n                    ? schema[_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.SEQ]\r\n                    : schema[_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.MAP];\r\n    }\r\n    if (onTagObj) {\r\n        onTagObj(tagObj);\r\n        delete ctx.onTagObj;\r\n    }\r\n    const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode)\r\n        ? tagObj.createNode(ctx.schema, value, ctx)\r\n        : new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_2__.Scalar(value);\r\n    if (tagName)\r\n        node.tag = tagName;\r\n    if (ref)\r\n        ref.node = node;\r\n    return node;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/doc/createNode.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/doc/directives.js":
/*!**********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/doc/directives.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Directives\": () => (/* binding */ Directives)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../visit.js */ \"./node_modules/yaml/browser/dist/visit.js\");\n\r\n\r\n\r\nconst escapeChars = {\r\n    '!': '%21',\r\n    ',': '%2C',\r\n    '[': '%5B',\r\n    ']': '%5D',\r\n    '{': '%7B',\r\n    '}': '%7D'\r\n};\r\nconst escapeTagName = (tn) => tn.replace(/[!,[\\]{}]/g, ch => escapeChars[ch]);\r\nclass Directives {\r\n    constructor(yaml, tags) {\r\n        /**\r\n         * The directives-end/doc-start marker `---`. If `null`, a marker may still be\r\n         * included in the document's stringified representation.\r\n         */\r\n        this.marker = null;\r\n        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);\r\n        this.tags = Object.assign({}, Directives.defaultTags, tags);\r\n    }\r\n    clone() {\r\n        const copy = new Directives(this.yaml, this.tags);\r\n        copy.marker = this.marker;\r\n        return copy;\r\n    }\r\n    /**\r\n     * During parsing, get a Directives instance for the current document and\r\n     * update the stream state according to the current version's spec.\r\n     */\r\n    atDocument() {\r\n        const res = new Directives(this.yaml, this.tags);\r\n        switch (this.yaml.version) {\r\n            case '1.1':\r\n                this.atNextDocument = true;\r\n                break;\r\n            case '1.2':\r\n                this.atNextDocument = false;\r\n                this.yaml = {\r\n                    explicit: Directives.defaultYaml.explicit,\r\n                    version: '1.2'\r\n                };\r\n                this.tags = Object.assign({}, Directives.defaultTags);\r\n                break;\r\n        }\r\n        return res;\r\n    }\r\n    /**\r\n     * @param onError - May be called even if the action was successful\r\n     * @returns `true` on success\r\n     */\r\n    add(line, onError) {\r\n        if (this.atNextDocument) {\r\n            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };\r\n            this.tags = Object.assign({}, Directives.defaultTags);\r\n            this.atNextDocument = false;\r\n        }\r\n        const parts = line.trim().split(/[ \\t]+/);\r\n        const name = parts.shift();\r\n        switch (name) {\r\n            case '%TAG': {\r\n                if (parts.length !== 2) {\r\n                    onError(0, '%TAG directive should contain exactly two parts');\r\n                    if (parts.length < 2)\r\n                        return false;\r\n                }\r\n                const [handle, prefix] = parts;\r\n                this.tags[handle] = prefix;\r\n                return true;\r\n            }\r\n            case '%YAML': {\r\n                this.yaml.explicit = true;\r\n                if (parts.length < 1) {\r\n                    onError(0, '%YAML directive should contain exactly one part');\r\n                    return false;\r\n                }\r\n                const [version] = parts;\r\n                if (version === '1.1' || version === '1.2') {\r\n                    this.yaml.version = version;\r\n                    return true;\r\n                }\r\n                else {\r\n                    onError(6, `Unsupported YAML version ${version}`, true);\r\n                    return false;\r\n                }\r\n            }\r\n            default:\r\n                onError(0, `Unknown directive ${name}`, true);\r\n                return false;\r\n        }\r\n    }\r\n    /**\r\n     * Resolves a tag, matching handles to those defined in %TAG directives.\r\n     *\r\n     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a\r\n     *   `'!local'` tag, or `null` if unresolvable.\r\n     */\r\n    tagName(source, onError) {\r\n        if (source === '!')\r\n            return '!'; // non-specific tag\r\n        if (source[0] !== '!') {\r\n            onError(`Not a valid tag: ${source}`);\r\n            return null;\r\n        }\r\n        if (source[1] === '<') {\r\n            const verbatim = source.slice(2, -1);\r\n            if (verbatim === '!' || verbatim === '!!') {\r\n                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);\r\n                return null;\r\n            }\r\n            if (source[source.length - 1] !== '>')\r\n                onError('Verbatim tags must end with a >');\r\n            return verbatim;\r\n        }\r\n        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);\r\n        if (!suffix)\r\n            onError(`The ${source} tag has no suffix`);\r\n        const prefix = this.tags[handle];\r\n        if (prefix)\r\n            return prefix + decodeURIComponent(suffix);\r\n        if (handle === '!')\r\n            return source; // local tag\r\n        onError(`Could not resolve tag: ${source}`);\r\n        return null;\r\n    }\r\n    /**\r\n     * Given a fully resolved tag, returns its printable string form,\r\n     * taking into account current tag prefixes and defaults.\r\n     */\r\n    tagString(tag) {\r\n        for (const [handle, prefix] of Object.entries(this.tags)) {\r\n            if (tag.startsWith(prefix))\r\n                return handle + escapeTagName(tag.substring(prefix.length));\r\n        }\r\n        return tag[0] === '!' ? tag : `!<${tag}>`;\r\n    }\r\n    toString(doc) {\r\n        const lines = this.yaml.explicit\r\n            ? [`%YAML ${this.yaml.version || '1.2'}`]\r\n            : [];\r\n        const tagEntries = Object.entries(this.tags);\r\n        let tagNames;\r\n        if (doc && tagEntries.length > 0 && (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isNode)(doc.contents)) {\r\n            const tags = {};\r\n            (0,_visit_js__WEBPACK_IMPORTED_MODULE_1__.visit)(doc.contents, (_key, node) => {\r\n                if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isNode)(node) && node.tag)\r\n                    tags[node.tag] = true;\r\n            });\r\n            tagNames = Object.keys(tags);\r\n        }\r\n        else\r\n            tagNames = [];\r\n        for (const [handle, prefix] of tagEntries) {\r\n            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')\r\n                continue;\r\n            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))\r\n                lines.push(`%TAG ${handle} ${prefix}`);\r\n        }\r\n        return lines.join('\\n');\r\n    }\r\n}\r\nDirectives.defaultYaml = { explicit: false, version: '1.2' };\r\nDirectives.defaultTags = { '!!': 'tag:yaml.org,2002:' };\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/doc/directives.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/errors.js":
/*!**************************************************!*\
  !*** ./node_modules/yaml/browser/dist/errors.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"YAMLError\": () => (/* binding */ YAMLError),\n/* harmony export */   \"YAMLParseError\": () => (/* binding */ YAMLParseError),\n/* harmony export */   \"YAMLWarning\": () => (/* binding */ YAMLWarning),\n/* harmony export */   \"prettifyError\": () => (/* binding */ prettifyError)\n/* harmony export */ });\nclass YAMLError extends Error {\r\n    constructor(name, pos, code, message) {\r\n        super();\r\n        this.name = name;\r\n        this.code = code;\r\n        this.message = message;\r\n        this.pos = pos;\r\n    }\r\n}\r\nclass YAMLParseError extends YAMLError {\r\n    constructor(pos, code, message) {\r\n        super('YAMLParseError', pos, code, message);\r\n    }\r\n}\r\nclass YAMLWarning extends YAMLError {\r\n    constructor(pos, code, message) {\r\n        super('YAMLWarning', pos, code, message);\r\n    }\r\n}\r\nconst prettifyError = (src, lc) => (error) => {\r\n    if (error.pos[0] === -1)\r\n        return;\r\n    error.linePos = error.pos.map(pos => lc.linePos(pos));\r\n    const { line, col } = error.linePos[0];\r\n    error.message += ` at line ${line}, column ${col}`;\r\n    let ci = col - 1;\r\n    let lineStr = src\r\n        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])\r\n        .replace(/[\\n\\r]+$/, '');\r\n    // Trim to max 80 chars, keeping col position near the middle\r\n    if (ci >= 60 && lineStr.length > 80) {\r\n        const trimStart = Math.min(ci - 39, lineStr.length - 79);\r\n        lineStr = '…' + lineStr.substring(trimStart);\r\n        ci -= trimStart - 1;\r\n    }\r\n    if (lineStr.length > 80)\r\n        lineStr = lineStr.substring(0, 79) + '…';\r\n    // Include previous line in context if pointing at line start\r\n    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {\r\n        // Regexp won't match if start is trimmed\r\n        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);\r\n        if (prev.length > 80)\r\n            prev = prev.substring(0, 79) + '…\\n';\r\n        lineStr = prev + lineStr;\r\n    }\r\n    if (/[^ ]/.test(lineStr)) {\r\n        let count = 1;\r\n        const end = error.linePos[1];\r\n        if (end && end.line === line && end.col > col) {\r\n            count = Math.min(end.col - col, 80 - ci);\r\n        }\r\n        const pointer = ' '.repeat(ci) + '^'.repeat(count);\r\n        error.message += `:\\n\\n${lineStr}\\n${pointer}\\n`;\r\n    }\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/errors.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/yaml/browser/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Composer\": () => (/* reexport safe */ _compose_composer_js__WEBPACK_IMPORTED_MODULE_0__.Composer),\n/* harmony export */   \"Document\": () => (/* reexport safe */ _doc_Document_js__WEBPACK_IMPORTED_MODULE_1__.Document),\n/* harmony export */   \"Schema\": () => (/* reexport safe */ _schema_Schema_js__WEBPACK_IMPORTED_MODULE_2__.Schema),\n/* harmony export */   \"YAMLError\": () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.YAMLError),\n/* harmony export */   \"YAMLParseError\": () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.YAMLParseError),\n/* harmony export */   \"YAMLWarning\": () => (/* reexport safe */ _errors_js__WEBPACK_IMPORTED_MODULE_3__.YAMLWarning),\n/* harmony export */   \"Alias\": () => (/* reexport safe */ _nodes_Alias_js__WEBPACK_IMPORTED_MODULE_4__.Alias),\n/* harmony export */   \"isAlias\": () => (/* reexport safe */ _nodes_Node_js__WEBPACK_IMPORTED_MODULE_5__.isAlias),\n/* harmony export */   \"isCollection\": () => (/* reexport safe */ _nodes_Node_js__WEBPACK_IMPORTED_MODULE_5__.isCollection),\n/* harmony export */   \"isDocument\": () => (/* reexport safe */ _nodes_Node_js__WEBPACK_IMPORTED_MODULE_5__.isDocument),\n/* harmony export */   \"isMap\": () => (/* reexport safe */ _nodes_Node_js__WEBPACK_IMPORTED_MODULE_5__.isMap),\n/* harmony export */   \"isNode\": () => (/* reexport safe */ _nodes_Node_js__WEBPACK_IMPORTED_MODULE_5__.isNode),\n/* harmony export */   \"isPair\": () => (/* reexport safe */ _nodes_Node_js__WEBPACK_IMPORTED_MODULE_5__.isPair),\n/* harmony export */   \"isScalar\": () => (/* reexport safe */ _nodes_Node_js__WEBPACK_IMPORTED_MODULE_5__.isScalar),\n/* harmony export */   \"isSeq\": () => (/* reexport safe */ _nodes_Node_js__WEBPACK_IMPORTED_MODULE_5__.isSeq),\n/* harmony export */   \"Pair\": () => (/* reexport safe */ _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_6__.Pair),\n/* harmony export */   \"Scalar\": () => (/* reexport safe */ _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_7__.Scalar),\n/* harmony export */   \"YAMLMap\": () => (/* reexport safe */ _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_8__.YAMLMap),\n/* harmony export */   \"YAMLSeq\": () => (/* reexport safe */ _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_9__.YAMLSeq),\n/* harmony export */   \"defaultOptions\": () => (/* reexport safe */ _options_js__WEBPACK_IMPORTED_MODULE_10__.defaultOptions),\n/* harmony export */   \"CST\": () => (/* reexport module object */ _parse_cst_js__WEBPACK_IMPORTED_MODULE_11__),\n/* harmony export */   \"Lexer\": () => (/* reexport safe */ _parse_lexer_js__WEBPACK_IMPORTED_MODULE_12__.Lexer),\n/* harmony export */   \"LineCounter\": () => (/* reexport safe */ _parse_line_counter_js__WEBPACK_IMPORTED_MODULE_13__.LineCounter),\n/* harmony export */   \"Parser\": () => (/* reexport safe */ _parse_parser_js__WEBPACK_IMPORTED_MODULE_14__.Parser),\n/* harmony export */   \"parse\": () => (/* reexport safe */ _public_api_js__WEBPACK_IMPORTED_MODULE_15__.parse),\n/* harmony export */   \"parseAllDocuments\": () => (/* reexport safe */ _public_api_js__WEBPACK_IMPORTED_MODULE_15__.parseAllDocuments),\n/* harmony export */   \"parseDocument\": () => (/* reexport safe */ _public_api_js__WEBPACK_IMPORTED_MODULE_15__.parseDocument),\n/* harmony export */   \"stringify\": () => (/* reexport safe */ _public_api_js__WEBPACK_IMPORTED_MODULE_15__.stringify),\n/* harmony export */   \"visit\": () => (/* reexport safe */ _visit_js__WEBPACK_IMPORTED_MODULE_16__.visit)\n/* harmony export */ });\n/* harmony import */ var _compose_composer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose/composer.js */ \"./node_modules/yaml/browser/dist/compose/composer.js\");\n/* harmony import */ var _doc_Document_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./doc/Document.js */ \"./node_modules/yaml/browser/dist/doc/Document.js\");\n/* harmony import */ var _schema_Schema_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema/Schema.js */ \"./node_modules/yaml/browser/dist/schema/Schema.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/yaml/browser/dist/errors.js\");\n/* harmony import */ var _nodes_Alias_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nodes/Alias.js */ \"./node_modules/yaml/browser/dist/nodes/Alias.js\");\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./nodes/Pair.js */ \"./node_modules/yaml/browser/dist/nodes/Pair.js\");\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./nodes/YAMLMap.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLMap.js\");\n/* harmony import */ var _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./nodes/YAMLSeq.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLSeq.js\");\n/* harmony import */ var _options_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./options.js */ \"./node_modules/yaml/browser/dist/options.js\");\n/* harmony import */ var _parse_cst_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./parse/cst.js */ \"./node_modules/yaml/browser/dist/parse/cst.js\");\n/* harmony import */ var _parse_lexer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./parse/lexer.js */ \"./node_modules/yaml/browser/dist/parse/lexer.js\");\n/* harmony import */ var _parse_line_counter_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./parse/line-counter.js */ \"./node_modules/yaml/browser/dist/parse/line-counter.js\");\n/* harmony import */ var _parse_parser_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./parse/parser.js */ \"./node_modules/yaml/browser/dist/parse/parser.js\");\n/* harmony import */ var _public_api_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./public-api.js */ \"./node_modules/yaml/browser/dist/public-api.js\");\n/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./visit.js */ \"./node_modules/yaml/browser/dist/visit.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/index.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/log.js":
/*!***********************************************!*\
  !*** ./node_modules/yaml/browser/dist/log.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"debug\": () => (/* binding */ debug),\n/* harmony export */   \"warn\": () => (/* binding */ warn)\n/* harmony export */ });\nfunction debug(logLevel, ...messages) {\r\n    if (logLevel === 'debug')\r\n        console.log(...messages);\r\n}\r\nfunction warn(logLevel, warning) {\r\n    if (logLevel === 'debug' || logLevel === 'warn') {\r\n        if (typeof process !== 'undefined' && process.emitWarning)\r\n            process.emitWarning(warning);\r\n        else\r\n            console.warn(warning);\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/log.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/nodes/Alias.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/browser/dist/nodes/Alias.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Alias\": () => (/* binding */ Alias)\n/* harmony export */ });\n/* harmony import */ var _doc_anchors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../doc/anchors.js */ \"./node_modules/yaml/browser/dist/doc/anchors.js\");\n/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../visit.js */ \"./node_modules/yaml/browser/dist/visit.js\");\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n\r\n\r\n\r\n\r\nclass Alias extends _Node_js__WEBPACK_IMPORTED_MODULE_2__.NodeBase {\r\n    constructor(source) {\r\n        super(_Node_js__WEBPACK_IMPORTED_MODULE_2__.ALIAS);\r\n        this.source = source;\r\n        Object.defineProperty(this, 'tag', {\r\n            set() {\r\n                throw new Error('Alias nodes cannot have tags');\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Resolve the value of this alias within `doc`, finding the last\r\n     * instance of the `source` anchor before this node.\r\n     */\r\n    resolve(doc) {\r\n        let found = undefined;\r\n        (0,_visit_js__WEBPACK_IMPORTED_MODULE_1__.visit)(doc, {\r\n            Node: (_key, node) => {\r\n                if (node === this)\r\n                    return _visit_js__WEBPACK_IMPORTED_MODULE_1__.visit.BREAK;\r\n                if (node.anchor === this.source)\r\n                    found = node;\r\n            }\r\n        });\r\n        return found;\r\n    }\r\n    toJSON(_arg, ctx) {\r\n        if (!ctx)\r\n            return { source: this.source };\r\n        const { anchors, doc, maxAliasCount } = ctx;\r\n        const source = this.resolve(doc);\r\n        if (!source) {\r\n            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\r\n            throw new ReferenceError(msg);\r\n        }\r\n        const data = anchors.get(source);\r\n        /* istanbul ignore if */\r\n        if (!data || data.res === undefined) {\r\n            const msg = 'This should not happen: Alias anchor was not resolved?';\r\n            throw new ReferenceError(msg);\r\n        }\r\n        if (maxAliasCount >= 0) {\r\n            data.count += 1;\r\n            if (data.aliasCount === 0)\r\n                data.aliasCount = getAliasCount(doc, source, anchors);\r\n            if (data.count * data.aliasCount > maxAliasCount) {\r\n                const msg = 'Excessive alias count indicates a resource exhaustion attack';\r\n                throw new ReferenceError(msg);\r\n            }\r\n        }\r\n        return data.res;\r\n    }\r\n    toString(ctx, _onComment, _onChompKeep) {\r\n        const src = `*${this.source}`;\r\n        if (ctx) {\r\n            (0,_doc_anchors_js__WEBPACK_IMPORTED_MODULE_0__.anchorIsValid)(this.source);\r\n            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {\r\n                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;\r\n                throw new Error(msg);\r\n            }\r\n            if (ctx.implicitKey)\r\n                return `${src} `;\r\n        }\r\n        return src;\r\n    }\r\n}\r\nfunction getAliasCount(doc, node, anchors) {\r\n    if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isAlias)(node)) {\r\n        const source = node.resolve(doc);\r\n        const anchor = anchors && source && anchors.get(source);\r\n        return anchor ? anchor.count * anchor.aliasCount : 0;\r\n    }\r\n    else if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isCollection)(node)) {\r\n        let count = 0;\r\n        for (const item of node.items) {\r\n            const c = getAliasCount(doc, item, anchors);\r\n            if (c > count)\r\n                count = c;\r\n        }\r\n        return count;\r\n    }\r\n    else if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isPair)(node)) {\r\n        const kc = getAliasCount(doc, node.key, anchors);\r\n        const vc = getAliasCount(doc, node.value, anchors);\r\n        return Math.max(kc, vc);\r\n    }\r\n    return 1;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/nodes/Alias.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/nodes/Collection.js":
/*!************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/nodes/Collection.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Collection\": () => (/* binding */ Collection),\n/* harmony export */   \"collectionFromPath\": () => (/* binding */ collectionFromPath),\n/* harmony export */   \"isEmptyPath\": () => (/* binding */ isEmptyPath)\n/* harmony export */ });\n/* harmony import */ var _doc_createNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../doc/createNode.js */ \"./node_modules/yaml/browser/dist/doc/createNode.js\");\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n\r\n\r\n\r\nfunction collectionFromPath(schema, path, value) {\r\n    let v = value;\r\n    for (let i = path.length - 1; i >= 0; --i) {\r\n        const k = path[i];\r\n        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {\r\n            const a = [];\r\n            a[k] = v;\r\n            v = a;\r\n        }\r\n        else {\r\n            v = new Map([[k, v]]);\r\n        }\r\n    }\r\n    return (0,_doc_createNode_js__WEBPACK_IMPORTED_MODULE_0__.createNode)(v, undefined, {\r\n        aliasDuplicateObjects: false,\r\n        keepUndefined: false,\r\n        onAnchor: () => {\r\n            throw new Error('This should not happen, please report a bug.');\r\n        },\r\n        schema,\r\n        sourceObjects: new Map()\r\n    });\r\n}\r\n// null, undefined, or an empty non-string iterable (e.g. [])\r\nconst isEmptyPath = (path) => path == null ||\r\n    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);\r\nclass Collection extends _Node_js__WEBPACK_IMPORTED_MODULE_1__.NodeBase {\r\n    constructor(type, schema) {\r\n        super(type);\r\n        Object.defineProperty(this, 'schema', {\r\n            value: schema,\r\n            configurable: true,\r\n            enumerable: false,\r\n            writable: true\r\n        });\r\n    }\r\n    /**\r\n     * Create a copy of this collection.\r\n     *\r\n     * @param schema - If defined, overwrites the original's schema\r\n     */\r\n    clone(schema) {\r\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\r\n        if (schema)\r\n            copy.schema = schema;\r\n        copy.items = copy.items.map(it => (0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isNode)(it) || (0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isPair)(it) ? it.clone(schema) : it);\r\n        if (this.range)\r\n            copy.range = this.range.slice();\r\n        return copy;\r\n    }\r\n    /**\r\n     * Adds a value to the collection. For `!!map` and `!!omap` the value must\r\n     * be a Pair instance or a `{ key, value }` object, which may not have a key\r\n     * that already exists in the map.\r\n     */\r\n    addIn(path, value) {\r\n        if (isEmptyPath(path))\r\n            this.add(value);\r\n        else {\r\n            const [key, ...rest] = path;\r\n            const node = this.get(key, true);\r\n            if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isCollection)(node))\r\n                node.addIn(rest, value);\r\n            else if (node === undefined && this.schema)\r\n                this.set(key, collectionFromPath(this.schema, rest, value));\r\n            else\r\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\r\n        }\r\n    }\r\n    /**\r\n     * Removes a value from the collection.\r\n     * @returns `true` if the item was found and removed.\r\n     */\r\n    deleteIn(path) {\r\n        const [key, ...rest] = path;\r\n        if (rest.length === 0)\r\n            return this.delete(key);\r\n        const node = this.get(key, true);\r\n        if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isCollection)(node))\r\n            return node.deleteIn(rest);\r\n        else\r\n            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\r\n    }\r\n    /**\r\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\r\n     * scalar values from their surrounding node; to disable set `keepScalar` to\r\n     * `true` (collections are always returned intact).\r\n     */\r\n    getIn(path, keepScalar) {\r\n        const [key, ...rest] = path;\r\n        const node = this.get(key, true);\r\n        if (rest.length === 0)\r\n            return !keepScalar && (0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isScalar)(node) ? node.value : node;\r\n        else\r\n            return (0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isCollection)(node) ? node.getIn(rest, keepScalar) : undefined;\r\n    }\r\n    hasAllNullValues(allowScalar) {\r\n        return this.items.every(node => {\r\n            if (!(0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isPair)(node))\r\n                return false;\r\n            const n = node.value;\r\n            return (n == null ||\r\n                (allowScalar &&\r\n                    (0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isScalar)(n) &&\r\n                    n.value == null &&\r\n                    !n.commentBefore &&\r\n                    !n.comment &&\r\n                    !n.tag));\r\n        });\r\n    }\r\n    /**\r\n     * Checks if the collection includes a value with the key `key`.\r\n     */\r\n    hasIn(path) {\r\n        const [key, ...rest] = path;\r\n        if (rest.length === 0)\r\n            return this.has(key);\r\n        const node = this.get(key, true);\r\n        return (0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isCollection)(node) ? node.hasIn(rest) : false;\r\n    }\r\n    /**\r\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\r\n     * boolean to add/remove the item from the set.\r\n     */\r\n    setIn(path, value) {\r\n        const [key, ...rest] = path;\r\n        if (rest.length === 0) {\r\n            this.set(key, value);\r\n        }\r\n        else {\r\n            const node = this.get(key, true);\r\n            if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_1__.isCollection)(node))\r\n                node.setIn(rest, value);\r\n            else if (node === undefined && this.schema)\r\n                this.set(key, collectionFromPath(this.schema, rest, value));\r\n            else\r\n                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);\r\n        }\r\n    }\r\n}\r\nCollection.maxFlowStringSingleLineLength = 60;\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/nodes/Collection.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/nodes/Node.js":
/*!******************************************************!*\
  !*** ./node_modules/yaml/browser/dist/nodes/Node.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ALIAS\": () => (/* binding */ ALIAS),\n/* harmony export */   \"DOC\": () => (/* binding */ DOC),\n/* harmony export */   \"MAP\": () => (/* binding */ MAP),\n/* harmony export */   \"NODE_TYPE\": () => (/* binding */ NODE_TYPE),\n/* harmony export */   \"NodeBase\": () => (/* binding */ NodeBase),\n/* harmony export */   \"PAIR\": () => (/* binding */ PAIR),\n/* harmony export */   \"SCALAR\": () => (/* binding */ SCALAR),\n/* harmony export */   \"SEQ\": () => (/* binding */ SEQ),\n/* harmony export */   \"hasAnchor\": () => (/* binding */ hasAnchor),\n/* harmony export */   \"isAlias\": () => (/* binding */ isAlias),\n/* harmony export */   \"isCollection\": () => (/* binding */ isCollection),\n/* harmony export */   \"isDocument\": () => (/* binding */ isDocument),\n/* harmony export */   \"isMap\": () => (/* binding */ isMap),\n/* harmony export */   \"isNode\": () => (/* binding */ isNode),\n/* harmony export */   \"isPair\": () => (/* binding */ isPair),\n/* harmony export */   \"isScalar\": () => (/* binding */ isScalar),\n/* harmony export */   \"isSeq\": () => (/* binding */ isSeq)\n/* harmony export */ });\nconst ALIAS = Symbol.for('yaml.alias');\r\nconst DOC = Symbol.for('yaml.document');\r\nconst MAP = Symbol.for('yaml.map');\r\nconst PAIR = Symbol.for('yaml.pair');\r\nconst SCALAR = Symbol.for('yaml.scalar');\r\nconst SEQ = Symbol.for('yaml.seq');\r\nconst NODE_TYPE = Symbol.for('yaml.node.type');\r\nconst isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;\r\nconst isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;\r\nconst isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;\r\nconst isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;\r\nconst isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;\r\nconst isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;\r\nfunction isCollection(node) {\r\n    if (node && typeof node === 'object')\r\n        switch (node[NODE_TYPE]) {\r\n            case MAP:\r\n            case SEQ:\r\n                return true;\r\n        }\r\n    return false;\r\n}\r\nfunction isNode(node) {\r\n    if (node && typeof node === 'object')\r\n        switch (node[NODE_TYPE]) {\r\n            case ALIAS:\r\n            case MAP:\r\n            case SCALAR:\r\n            case SEQ:\r\n                return true;\r\n        }\r\n    return false;\r\n}\r\nconst hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;\r\nclass NodeBase {\r\n    constructor(type) {\r\n        Object.defineProperty(this, NODE_TYPE, { value: type });\r\n    }\r\n    /** Create a copy of this node.  */\r\n    clone() {\r\n        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));\r\n        if (this.range)\r\n            copy.range = this.range.slice();\r\n        return copy;\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/nodes/Node.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/nodes/Pair.js":
/*!******************************************************!*\
  !*** ./node_modules/yaml/browser/dist/nodes/Pair.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Pair\": () => (/* binding */ Pair),\n/* harmony export */   \"createPair\": () => (/* binding */ createPair)\n/* harmony export */ });\n/* harmony import */ var _doc_createNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../doc/createNode.js */ \"./node_modules/yaml/browser/dist/doc/createNode.js\");\n/* harmony import */ var _stringify_stringifyPair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stringify/stringifyPair.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyPair.js\");\n/* harmony import */ var _addPairToJSMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./addPairToJSMap.js */ \"./node_modules/yaml/browser/dist/nodes/addPairToJSMap.js\");\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n\r\n\r\n\r\n\r\n\r\nfunction createPair(key, value, ctx) {\r\n    const k = (0,_doc_createNode_js__WEBPACK_IMPORTED_MODULE_0__.createNode)(key, undefined, ctx);\r\n    const v = (0,_doc_createNode_js__WEBPACK_IMPORTED_MODULE_0__.createNode)(value, undefined, ctx);\r\n    return new Pair(k, v);\r\n}\r\nclass Pair {\r\n    constructor(key, value = null) {\r\n        Object.defineProperty(this, _Node_js__WEBPACK_IMPORTED_MODULE_3__.NODE_TYPE, { value: _Node_js__WEBPACK_IMPORTED_MODULE_3__.PAIR });\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n    clone(schema) {\r\n        let { key, value } = this;\r\n        if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_3__.isNode)(key))\r\n            key = key.clone(schema);\r\n        if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_3__.isNode)(value))\r\n            value = value.clone(schema);\r\n        return new Pair(key, value);\r\n    }\r\n    toJSON(_, ctx) {\r\n        const pair = ctx && ctx.mapAsMap ? new Map() : {};\r\n        return (0,_addPairToJSMap_js__WEBPACK_IMPORTED_MODULE_2__.addPairToJSMap)(ctx, pair, this);\r\n    }\r\n    toString(ctx, onComment, onChompKeep) {\r\n        return ctx && ctx.doc\r\n            ? (0,_stringify_stringifyPair_js__WEBPACK_IMPORTED_MODULE_1__.stringifyPair)(this, ctx, onComment, onChompKeep)\r\n            : JSON.stringify(this);\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/nodes/Pair.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/nodes/Scalar.js":
/*!********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/nodes/Scalar.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scalar\": () => (/* binding */ Scalar),\n/* harmony export */   \"isScalarValue\": () => (/* binding */ isScalarValue)\n/* harmony export */ });\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _toJS_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toJS.js */ \"./node_modules/yaml/browser/dist/nodes/toJS.js\");\n\r\n\r\n\r\nconst isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');\r\nclass Scalar extends _Node_js__WEBPACK_IMPORTED_MODULE_0__.NodeBase {\r\n    constructor(value) {\r\n        super(_Node_js__WEBPACK_IMPORTED_MODULE_0__.SCALAR);\r\n        this.value = value;\r\n    }\r\n    toJSON(arg, ctx) {\r\n        return ctx && ctx.keep ? this.value : (0,_toJS_js__WEBPACK_IMPORTED_MODULE_1__.toJS)(this.value, arg, ctx);\r\n    }\r\n    toString() {\r\n        return String(this.value);\r\n    }\r\n}\r\nScalar.BLOCK_FOLDED = 'BLOCK_FOLDED';\r\nScalar.BLOCK_LITERAL = 'BLOCK_LITERAL';\r\nScalar.PLAIN = 'PLAIN';\r\nScalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';\r\nScalar.QUOTE_SINGLE = 'QUOTE_SINGLE';\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/nodes/Scalar.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/nodes/YAMLMap.js":
/*!*********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/nodes/YAMLMap.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"YAMLMap\": () => (/* binding */ YAMLMap),\n/* harmony export */   \"findPair\": () => (/* binding */ findPair)\n/* harmony export */ });\n/* harmony import */ var _stringify_stringifyCollection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stringify/stringifyCollection.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyCollection.js\");\n/* harmony import */ var _addPairToJSMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./addPairToJSMap.js */ \"./node_modules/yaml/browser/dist/nodes/addPairToJSMap.js\");\n/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Collection.js */ \"./node_modules/yaml/browser/dist/nodes/Collection.js\");\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _Pair_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Pair.js */ \"./node_modules/yaml/browser/dist/nodes/Pair.js\");\n/* harmony import */ var _Scalar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction findPair(items, key) {\r\n    const k = (0,_Node_js__WEBPACK_IMPORTED_MODULE_3__.isScalar)(key) ? key.value : key;\r\n    for (const it of items) {\r\n        if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_3__.isPair)(it)) {\r\n            if (it.key === key || it.key === k)\r\n                return it;\r\n            if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_3__.isScalar)(it.key) && it.key.value === k)\r\n                return it;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\nclass YAMLMap extends _Collection_js__WEBPACK_IMPORTED_MODULE_2__.Collection {\r\n    constructor(schema) {\r\n        super(_Node_js__WEBPACK_IMPORTED_MODULE_3__.MAP, schema);\r\n        this.items = [];\r\n    }\r\n    static get tagName() {\r\n        return 'tag:yaml.org,2002:map';\r\n    }\r\n    /**\r\n     * Adds a value to the collection.\r\n     *\r\n     * @param overwrite - If not set `true`, using a key that is already in the\r\n     *   collection will throw. Otherwise, overwrites the previous value.\r\n     */\r\n    add(pair, overwrite) {\r\n        let _pair;\r\n        if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_3__.isPair)(pair))\r\n            _pair = pair;\r\n        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\r\n            // In TypeScript, this never happens.\r\n            _pair = new _Pair_js__WEBPACK_IMPORTED_MODULE_4__.Pair(pair, pair.value);\r\n        }\r\n        else\r\n            _pair = new _Pair_js__WEBPACK_IMPORTED_MODULE_4__.Pair(pair.key, pair.value);\r\n        const prev = findPair(this.items, _pair.key);\r\n        const sortEntries = this.schema && this.schema.sortMapEntries;\r\n        if (prev) {\r\n            if (!overwrite)\r\n                throw new Error(`Key ${_pair.key} already set`);\r\n            // For scalars, keep the old node & its comments and anchors\r\n            if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_3__.isScalar)(prev.value) && (0,_Scalar_js__WEBPACK_IMPORTED_MODULE_5__.isScalarValue)(_pair.value))\r\n                prev.value.value = _pair.value;\r\n            else\r\n                prev.value = _pair.value;\r\n        }\r\n        else if (sortEntries) {\r\n            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\r\n            if (i === -1)\r\n                this.items.push(_pair);\r\n            else\r\n                this.items.splice(i, 0, _pair);\r\n        }\r\n        else {\r\n            this.items.push(_pair);\r\n        }\r\n    }\r\n    delete(key) {\r\n        const it = findPair(this.items, key);\r\n        if (!it)\r\n            return false;\r\n        const del = this.items.splice(this.items.indexOf(it), 1);\r\n        return del.length > 0;\r\n    }\r\n    get(key, keepScalar) {\r\n        const it = findPair(this.items, key);\r\n        const node = it && it.value;\r\n        return !keepScalar && (0,_Node_js__WEBPACK_IMPORTED_MODULE_3__.isScalar)(node) ? node.value : node;\r\n    }\r\n    has(key) {\r\n        return !!findPair(this.items, key);\r\n    }\r\n    set(key, value) {\r\n        this.add(new _Pair_js__WEBPACK_IMPORTED_MODULE_4__.Pair(key, value), true);\r\n    }\r\n    /**\r\n     * @param ctx - Conversion context, originally set in Document#toJS()\r\n     * @param {Class} Type - If set, forces the returned collection type\r\n     * @returns Instance of Type, Map, or Object\r\n     */\r\n    toJSON(_, ctx, Type) {\r\n        const map = Type ? new Type() : ctx && ctx.mapAsMap ? new Map() : {};\r\n        if (ctx && ctx.onCreate)\r\n            ctx.onCreate(map);\r\n        for (const item of this.items)\r\n            (0,_addPairToJSMap_js__WEBPACK_IMPORTED_MODULE_1__.addPairToJSMap)(ctx, map, item);\r\n        return map;\r\n    }\r\n    toString(ctx, onComment, onChompKeep) {\r\n        if (!ctx)\r\n            return JSON.stringify(this);\r\n        for (const item of this.items) {\r\n            if (!(0,_Node_js__WEBPACK_IMPORTED_MODULE_3__.isPair)(item))\r\n                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);\r\n        }\r\n        if (!ctx.allNullValues && this.hasAllNullValues(false))\r\n            ctx = Object.assign({}, ctx, { allNullValues: true });\r\n        return (0,_stringify_stringifyCollection_js__WEBPACK_IMPORTED_MODULE_0__.stringifyCollection)(this, ctx, {\r\n            blockItem: n => n.str,\r\n            flowChars: { start: '{', end: '}' },\r\n            itemIndent: ctx.indent || '',\r\n            onChompKeep,\r\n            onComment\r\n        });\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/nodes/YAMLMap.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/nodes/YAMLSeq.js":
/*!*********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/nodes/YAMLSeq.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"YAMLSeq\": () => (/* binding */ YAMLSeq)\n/* harmony export */ });\n/* harmony import */ var _stringify_stringifyCollection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../stringify/stringifyCollection.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyCollection.js\");\n/* harmony import */ var _Collection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Collection.js */ \"./node_modules/yaml/browser/dist/nodes/Collection.js\");\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _Scalar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _toJS_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toJS.js */ \"./node_modules/yaml/browser/dist/nodes/toJS.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass YAMLSeq extends _Collection_js__WEBPACK_IMPORTED_MODULE_1__.Collection {\r\n    constructor(schema) {\r\n        super(_Node_js__WEBPACK_IMPORTED_MODULE_2__.SEQ, schema);\r\n        this.items = [];\r\n    }\r\n    static get tagName() {\r\n        return 'tag:yaml.org,2002:seq';\r\n    }\r\n    add(value) {\r\n        this.items.push(value);\r\n    }\r\n    /**\r\n     * Removes a value from the collection.\r\n     *\r\n     * `key` must contain a representation of an integer for this to succeed.\r\n     * It may be wrapped in a `Scalar`.\r\n     *\r\n     * @returns `true` if the item was found and removed.\r\n     */\r\n    delete(key) {\r\n        const idx = asItemIndex(key);\r\n        if (typeof idx !== 'number')\r\n            return false;\r\n        const del = this.items.splice(idx, 1);\r\n        return del.length > 0;\r\n    }\r\n    /**\r\n     * Returns item at `key`, or `undefined` if not found. By default unwraps\r\n     * scalar values from their surrounding node; to disable set `keepScalar` to\r\n     * `true` (collections are always returned intact).\r\n     *\r\n     * `key` must contain a representation of an integer for this to succeed.\r\n     * It may be wrapped in a `Scalar`.\r\n     */\r\n    get(key, keepScalar) {\r\n        const idx = asItemIndex(key);\r\n        if (typeof idx !== 'number')\r\n            return undefined;\r\n        const it = this.items[idx];\r\n        return !keepScalar && (0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isScalar)(it) ? it.value : it;\r\n    }\r\n    /**\r\n     * Checks if the collection includes a value with the key `key`.\r\n     *\r\n     * `key` must contain a representation of an integer for this to succeed.\r\n     * It may be wrapped in a `Scalar`.\r\n     */\r\n    has(key) {\r\n        const idx = asItemIndex(key);\r\n        return typeof idx === 'number' && idx < this.items.length;\r\n    }\r\n    /**\r\n     * Sets a value in this collection. For `!!set`, `value` needs to be a\r\n     * boolean to add/remove the item from the set.\r\n     *\r\n     * If `key` does not contain a representation of an integer, this will throw.\r\n     * It may be wrapped in a `Scalar`.\r\n     */\r\n    set(key, value) {\r\n        const idx = asItemIndex(key);\r\n        if (typeof idx !== 'number')\r\n            throw new Error(`Expected a valid index, not ${key}.`);\r\n        const prev = this.items[idx];\r\n        if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isScalar)(prev) && (0,_Scalar_js__WEBPACK_IMPORTED_MODULE_3__.isScalarValue)(value))\r\n            prev.value = value;\r\n        else\r\n            this.items[idx] = value;\r\n    }\r\n    toJSON(_, ctx) {\r\n        const seq = [];\r\n        if (ctx && ctx.onCreate)\r\n            ctx.onCreate(seq);\r\n        let i = 0;\r\n        for (const item of this.items)\r\n            seq.push((0,_toJS_js__WEBPACK_IMPORTED_MODULE_4__.toJS)(item, String(i++), ctx));\r\n        return seq;\r\n    }\r\n    toString(ctx, onComment, onChompKeep) {\r\n        if (!ctx)\r\n            return JSON.stringify(this);\r\n        return (0,_stringify_stringifyCollection_js__WEBPACK_IMPORTED_MODULE_0__.stringifyCollection)(this, ctx, {\r\n            blockItem: n => (n.comment ? n.str : `- ${n.str}`),\r\n            flowChars: { start: '[', end: ']' },\r\n            itemIndent: (ctx.indent || '') + '  ',\r\n            onChompKeep,\r\n            onComment\r\n        });\r\n    }\r\n}\r\nfunction asItemIndex(key) {\r\n    let idx = (0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isScalar)(key) ? key.value : key;\r\n    if (idx && typeof idx === 'string')\r\n        idx = Number(idx);\r\n    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0\r\n        ? idx\r\n        : null;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/nodes/YAMLSeq.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/nodes/addPairToJSMap.js":
/*!****************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/nodes/addPairToJSMap.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addPairToJSMap\": () => (/* binding */ addPairToJSMap)\n/* harmony export */ });\n/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../log.js */ \"./node_modules/yaml/browser/dist/log.js\");\n/* harmony import */ var _stringify_stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../stringify/stringify.js */ \"./node_modules/yaml/browser/dist/stringify/stringify.js\");\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _Scalar_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _toJS_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toJS.js */ \"./node_modules/yaml/browser/dist/nodes/toJS.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst MERGE_KEY = '<<';\r\nfunction addPairToJSMap(ctx, map, { key, value }) {\r\n    if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {\r\n        value = (0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isAlias)(value) ? value.resolve(ctx.doc) : value;\r\n        if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isSeq)(value))\r\n            for (const it of value.items)\r\n                mergeToJSMap(ctx, map, it);\r\n        else if (Array.isArray(value))\r\n            for (const it of value)\r\n                mergeToJSMap(ctx, map, it);\r\n        else\r\n            mergeToJSMap(ctx, map, value);\r\n    }\r\n    else {\r\n        const jsKey = (0,_toJS_js__WEBPACK_IMPORTED_MODULE_4__.toJS)(key, '', ctx);\r\n        if (map instanceof Map) {\r\n            map.set(jsKey, (0,_toJS_js__WEBPACK_IMPORTED_MODULE_4__.toJS)(value, jsKey, ctx));\r\n        }\r\n        else if (map instanceof Set) {\r\n            map.add(jsKey);\r\n        }\r\n        else {\r\n            const stringKey = stringifyKey(key, jsKey, ctx);\r\n            const jsValue = (0,_toJS_js__WEBPACK_IMPORTED_MODULE_4__.toJS)(value, stringKey, ctx);\r\n            if (stringKey in map)\r\n                Object.defineProperty(map, stringKey, {\r\n                    value: jsValue,\r\n                    writable: true,\r\n                    enumerable: true,\r\n                    configurable: true\r\n                });\r\n            else\r\n                map[stringKey] = jsValue;\r\n        }\r\n    }\r\n    return map;\r\n}\r\nconst isMergeKey = (key) => key === MERGE_KEY ||\r\n    ((0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isScalar)(key) &&\r\n        key.value === MERGE_KEY &&\r\n        (!key.type || key.type === _Scalar_js__WEBPACK_IMPORTED_MODULE_3__.Scalar.PLAIN));\r\n// If the value associated with a merge key is a single mapping node, each of\r\n// its key/value pairs is inserted into the current mapping, unless the key\r\n// already exists in it. If the value associated with the merge key is a\r\n// sequence, then this sequence is expected to contain mapping nodes and each\r\n// of these nodes is merged in turn according to its order in the sequence.\r\n// Keys in mapping nodes earlier in the sequence override keys specified in\r\n// later mapping nodes. -- http://yaml.org/type/merge.html\r\nfunction mergeToJSMap(ctx, map, value) {\r\n    const source = ctx && (0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isAlias)(value) ? value.resolve(ctx.doc) : value;\r\n    if (!(0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isMap)(source))\r\n        throw new Error('Merge sources must be maps or map aliases');\r\n    const srcMap = source.toJSON(null, ctx, Map);\r\n    for (const [key, value] of srcMap) {\r\n        if (map instanceof Map) {\r\n            if (!map.has(key))\r\n                map.set(key, value);\r\n        }\r\n        else if (map instanceof Set) {\r\n            map.add(key);\r\n        }\r\n        else if (!Object.prototype.hasOwnProperty.call(map, key)) {\r\n            Object.defineProperty(map, key, {\r\n                value,\r\n                writable: true,\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n        }\r\n    }\r\n    return map;\r\n}\r\nfunction stringifyKey(key, jsKey, ctx) {\r\n    if (jsKey === null)\r\n        return '';\r\n    if (typeof jsKey !== 'object')\r\n        return String(jsKey);\r\n    if ((0,_Node_js__WEBPACK_IMPORTED_MODULE_2__.isNode)(key) && ctx && ctx.doc) {\r\n        const strCtx = (0,_stringify_stringify_js__WEBPACK_IMPORTED_MODULE_1__.createStringifyContext)(ctx.doc, {});\r\n        strCtx.anchors = new Set();\r\n        for (const node of ctx.anchors.keys())\r\n            strCtx.anchors.add(node.anchor);\r\n        strCtx.inFlow = true;\r\n        strCtx.inStringifyKey = true;\r\n        const strKey = key.toString(strCtx);\r\n        if (!ctx.mapKeyWarned) {\r\n            let jsonStr = JSON.stringify(strKey);\r\n            if (jsonStr.length > 40)\r\n                jsonStr = jsonStr.substring(0, 36) + '...\"';\r\n            (0,_log_js__WEBPACK_IMPORTED_MODULE_0__.warn)(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);\r\n            ctx.mapKeyWarned = true;\r\n        }\r\n        return strKey;\r\n    }\r\n    return JSON.stringify(jsKey);\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/nodes/addPairToJSMap.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/nodes/toJS.js":
/*!******************************************************!*\
  !*** ./node_modules/yaml/browser/dist/nodes/toJS.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"toJS\": () => (/* binding */ toJS)\n/* harmony export */ });\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n\r\n\r\n/**\r\n * Recursively convert any node or its contents to native JavaScript\r\n *\r\n * @param value - The input value\r\n * @param arg - If `value` defines a `toJSON()` method, use this\r\n *   as its first argument\r\n * @param ctx - Conversion context, originally set in Document#toJS(). If\r\n *   `{ keep: true }` is not set, output should be suitable for JSON\r\n *   stringification.\r\n */\r\nfunction toJS(value, arg, ctx) {\r\n    if (Array.isArray(value))\r\n        return value.map((v, i) => toJS(v, String(i), ctx));\r\n    if (value && typeof value.toJSON === 'function') {\r\n        if (!ctx || !(0,_Node_js__WEBPACK_IMPORTED_MODULE_0__.hasAnchor)(value))\r\n            return value.toJSON(arg, ctx);\r\n        const data = { aliasCount: 0, count: 1, res: undefined };\r\n        ctx.anchors.set(value, data);\r\n        ctx.onCreate = res => {\r\n            data.res = res;\r\n            delete ctx.onCreate;\r\n        };\r\n        const res = value.toJSON(arg, ctx);\r\n        if (ctx.onCreate)\r\n            ctx.onCreate(res);\r\n        return res;\r\n    }\r\n    if (typeof value === 'bigint' && !(ctx && ctx.keep))\r\n        return Number(value);\r\n    return value;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/nodes/toJS.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/options.js":
/*!***************************************************!*\
  !*** ./node_modules/yaml/browser/dist/options.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultOptions\": () => (/* binding */ defaultOptions)\n/* harmony export */ });\n/**\r\n * `yaml` defines document-specific options in three places: as an argument of\r\n * parse, create and stringify calls, in the values of `YAML.defaultOptions`,\r\n * and in the version-dependent `YAML.Document.defaults` object. Values set in\r\n * `YAML.defaultOptions` override version-dependent defaults, and argument\r\n * options override both.\r\n */\r\nconst defaultOptions = {\r\n    intAsBigInt: false,\r\n    keepSourceTokens: false,\r\n    logLevel: 'warn',\r\n    prettyErrors: true,\r\n    strict: true,\r\n    uniqueKeys: true,\r\n    version: '1.2'\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/options.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/parse/cst-scalar.js":
/*!************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/parse/cst-scalar.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createScalarToken\": () => (/* binding */ createScalarToken),\n/* harmony export */   \"resolveAsScalar\": () => (/* binding */ resolveAsScalar),\n/* harmony export */   \"setScalarValue\": () => (/* binding */ setScalarValue)\n/* harmony export */ });\n/* harmony import */ var _compose_resolve_block_scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../compose/resolve-block-scalar.js */ \"./node_modules/yaml/browser/dist/compose/resolve-block-scalar.js\");\n/* harmony import */ var _compose_resolve_flow_scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../compose/resolve-flow-scalar.js */ \"./node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors.js */ \"./node_modules/yaml/browser/dist/errors.js\");\n/* harmony import */ var _stringify_stringifyString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../stringify/stringifyString.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyString.js\");\n\r\n\r\n\r\n\r\n\r\nfunction resolveAsScalar(token, strict = true, onError) {\r\n    if (token) {\r\n        const _onError = (pos, code, message) => {\r\n            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\r\n            if (onError)\r\n                onError(offset, code, message);\r\n            else\r\n                throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.YAMLParseError([offset, offset + 1], code, message);\r\n        };\r\n        switch (token.type) {\r\n            case 'scalar':\r\n            case 'single-quoted-scalar':\r\n            case 'double-quoted-scalar':\r\n                return (0,_compose_resolve_flow_scalar_js__WEBPACK_IMPORTED_MODULE_1__.resolveFlowScalar)(token, strict, _onError);\r\n            case 'block-scalar':\r\n                return (0,_compose_resolve_block_scalar_js__WEBPACK_IMPORTED_MODULE_0__.resolveBlockScalar)(token, strict, _onError);\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Create a new scalar token with `value`\r\n *\r\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\r\n * as this function does not support any schema operations and won't check for such conflicts.\r\n *\r\n * @param value The string representation of the value, which will have its content properly indented.\r\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\r\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\r\n * @param context.indent The indent level of the token.\r\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\r\n * @param context.offset The offset position of the token.\r\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\r\n */\r\nfunction createScalarToken(value, context) {\r\n    var _a;\r\n    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;\r\n    const source = (0,_stringify_stringifyString_js__WEBPACK_IMPORTED_MODULE_3__.stringifyString)({ type, value }, {\r\n        implicitKey,\r\n        indent: indent > 0 ? ' '.repeat(indent) : '',\r\n        inFlow,\r\n        options: { blockQuote: true, lineWidth: -1 }\r\n    });\r\n    const end = (_a = context.end) !== null && _a !== void 0 ? _a : [\r\n        { type: 'newline', offset: -1, indent, source: '\\n' }\r\n    ];\r\n    switch (source[0]) {\r\n        case '|':\r\n        case '>': {\r\n            const he = source.indexOf('\\n');\r\n            const head = source.substring(0, he);\r\n            const body = source.substring(he + 1) + '\\n';\r\n            const props = [\r\n                { type: 'block-scalar-header', offset, indent, source: head }\r\n            ];\r\n            if (!addEndtoBlockProps(props, end))\r\n                props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\r\n            return { type: 'block-scalar', offset, indent, props, source: body };\r\n        }\r\n        case '\"':\r\n            return { type: 'double-quoted-scalar', offset, indent, source, end };\r\n        case \"'\":\r\n            return { type: 'single-quoted-scalar', offset, indent, source, end };\r\n        default:\r\n            return { type: 'scalar', offset, indent, source, end };\r\n    }\r\n}\r\n/**\r\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\r\n *\r\n * Best efforts are made to retain any comments previously associated with the `token`,\r\n * though all contents within a collection's `items` will be overwritten.\r\n *\r\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\r\n * as this function does not support any schema operations and won't check for such conflicts.\r\n *\r\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\r\n * @param value The string representation of the value, which will have its content properly indented.\r\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\r\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\r\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\r\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\r\n */\r\nfunction setScalarValue(token, value, context = {}) {\r\n    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;\r\n    let indent = 'indent' in token ? token.indent : null;\r\n    if (afterKey && typeof indent === 'number')\r\n        indent += 2;\r\n    if (!type)\r\n        switch (token.type) {\r\n            case 'single-quoted-scalar':\r\n                type = 'QUOTE_SINGLE';\r\n                break;\r\n            case 'double-quoted-scalar':\r\n                type = 'QUOTE_DOUBLE';\r\n                break;\r\n            case 'block-scalar': {\r\n                const header = token.props[0];\r\n                if (header.type !== 'block-scalar-header')\r\n                    throw new Error('Invalid block scalar header');\r\n                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\r\n                break;\r\n            }\r\n            default:\r\n                type = 'PLAIN';\r\n        }\r\n    const source = (0,_stringify_stringifyString_js__WEBPACK_IMPORTED_MODULE_3__.stringifyString)({ type, value }, {\r\n        implicitKey: implicitKey || indent === null,\r\n        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\r\n        inFlow,\r\n        options: { blockQuote: true, lineWidth: -1 }\r\n    });\r\n    switch (source[0]) {\r\n        case '|':\r\n        case '>':\r\n            setBlockScalarValue(token, source);\r\n            break;\r\n        case '\"':\r\n            setFlowScalarValue(token, source, 'double-quoted-scalar');\r\n            break;\r\n        case \"'\":\r\n            setFlowScalarValue(token, source, 'single-quoted-scalar');\r\n            break;\r\n        default:\r\n            setFlowScalarValue(token, source, 'scalar');\r\n    }\r\n}\r\nfunction setBlockScalarValue(token, source) {\r\n    const he = source.indexOf('\\n');\r\n    const head = source.substring(0, he);\r\n    const body = source.substring(he + 1) + '\\n';\r\n    if (token.type === 'block-scalar') {\r\n        const header = token.props[0];\r\n        if (header.type !== 'block-scalar-header')\r\n            throw new Error('Invalid block scalar header');\r\n        header.source = head;\r\n        token.source = body;\r\n    }\r\n    else {\r\n        const { offset } = token;\r\n        const indent = 'indent' in token ? token.indent : -1;\r\n        const props = [\r\n            { type: 'block-scalar-header', offset, indent, source: head }\r\n        ];\r\n        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))\r\n            props.push({ type: 'newline', offset: -1, indent, source: '\\n' });\r\n        for (const key of Object.keys(token))\r\n            if (key !== 'type' && key !== 'offset')\r\n                delete token[key];\r\n        Object.assign(token, { type: 'block-scalar', indent, props, source: body });\r\n    }\r\n}\r\n/** @returns `true` if last token is a newline */\r\nfunction addEndtoBlockProps(props, end) {\r\n    if (end)\r\n        for (const st of end)\r\n            switch (st.type) {\r\n                case 'space':\r\n                case 'comment':\r\n                    props.push(st);\r\n                    break;\r\n                case 'newline':\r\n                    props.push(st);\r\n                    return true;\r\n            }\r\n    return false;\r\n}\r\nfunction setFlowScalarValue(token, source, type) {\r\n    switch (token.type) {\r\n        case 'scalar':\r\n        case 'double-quoted-scalar':\r\n        case 'single-quoted-scalar':\r\n            token.type = type;\r\n            token.source = source;\r\n            break;\r\n        case 'block-scalar': {\r\n            const end = token.props.slice(1);\r\n            let oa = source.length;\r\n            if (token.props[0].type === 'block-scalar-header')\r\n                oa -= token.props[0].source.length;\r\n            for (const tok of end)\r\n                tok.offset += oa;\r\n            delete token.props;\r\n            Object.assign(token, { type, source, end });\r\n            break;\r\n        }\r\n        case 'block-map':\r\n        case 'block-seq': {\r\n            const offset = token.offset + source.length;\r\n            const nl = { type: 'newline', offset, indent: token.indent, source: '\\n' };\r\n            delete token.items;\r\n            Object.assign(token, { type, source, end: [nl] });\r\n            break;\r\n        }\r\n        default: {\r\n            const indent = 'indent' in token ? token.indent : -1;\r\n            const end = 'end' in token && Array.isArray(token.end)\r\n                ? token.end.filter(st => st.type === 'space' ||\r\n                    st.type === 'comment' ||\r\n                    st.type === 'newline')\r\n                : [];\r\n            for (const key of Object.keys(token))\r\n                if (key !== 'type' && key !== 'offset')\r\n                    delete token[key];\r\n            Object.assign(token, { type, indent, source, end });\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/parse/cst-scalar.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/parse/cst-stringify.js":
/*!***************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/parse/cst-stringify.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stringify\": () => (/* binding */ stringify)\n/* harmony export */ });\n/**\r\n * Stringify a CST document, token, or collection item\r\n *\r\n * Fair warning: This applies no validation whatsoever, and\r\n * simply concatenates the sources in their logical order.\r\n */\r\nconst stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\r\nfunction stringifyToken(token) {\r\n    switch (token.type) {\r\n        case 'block-scalar': {\r\n            let res = '';\r\n            for (const tok of token.props)\r\n                res += stringifyToken(tok);\r\n            return res + token.source;\r\n        }\r\n        case 'block-map':\r\n        case 'block-seq': {\r\n            let res = '';\r\n            for (const item of token.items)\r\n                res += stringifyItem(item);\r\n            return res;\r\n        }\r\n        case 'flow-collection': {\r\n            let res = token.start.source;\r\n            for (const item of token.items)\r\n                res += stringifyItem(item);\r\n            for (const st of token.end)\r\n                res += st.source;\r\n            return res;\r\n        }\r\n        case 'document': {\r\n            let res = stringifyItem(token);\r\n            if (token.end)\r\n                for (const st of token.end)\r\n                    res += st.source;\r\n            return res;\r\n        }\r\n        default: {\r\n            let res = token.source;\r\n            if ('end' in token && token.end)\r\n                for (const st of token.end)\r\n                    res += st.source;\r\n            return res;\r\n        }\r\n    }\r\n}\r\nfunction stringifyItem({ start, key, sep, value }) {\r\n    let res = '';\r\n    for (const st of start)\r\n        res += st.source;\r\n    if (key)\r\n        res += stringifyToken(key);\r\n    if (sep)\r\n        for (const st of sep)\r\n            res += st.source;\r\n    if (value)\r\n        res += stringifyToken(value);\r\n    return res;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/parse/cst-stringify.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/parse/cst-visit.js":
/*!***********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/parse/cst-visit.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"visit\": () => (/* binding */ visit)\n/* harmony export */ });\nconst BREAK = Symbol('break visit');\r\nconst SKIP = Symbol('skip children');\r\nconst REMOVE = Symbol('remove item');\r\n/**\r\n * Apply a visitor to a CST document or item.\r\n *\r\n * Walks through the tree (depth-first) starting from the root, calling a\r\n * `visitor` function with two arguments when entering each item:\r\n *   - `item`: The current item, which included the following members:\r\n *     - `start: SourceToken[]` – Source tokens before the key or value,\r\n *       possibly including its anchor or tag.\r\n *     - `key?: Token | null` – Set for pair values. May then be `null`, if\r\n *       the key before the `:` separator is empty.\r\n *     - `sep?: SourceToken[]` – Source tokens between the key and the value,\r\n *       which should include the `:` map value indicator if `value` is set.\r\n *     - `value?: Token` – The value of a sequence item, or of a map pair.\r\n *   - `path`: The steps from the root to the current node, as an array of\r\n *     `['key' | 'value', number]` tuples.\r\n *\r\n * The return value of the visitor may be used to control the traversal:\r\n *   - `undefined` (default): Do nothing and continue\r\n *   - `visit.SKIP`: Do not visit the children of this token, continue with\r\n *      next sibling\r\n *   - `visit.BREAK`: Terminate traversal completely\r\n *   - `visit.REMOVE`: Remove the current item, then continue with the next one\r\n *   - `number`: Set the index of the next step. This is useful especially if\r\n *     the index of the current token has changed.\r\n *   - `function`: Define the next visitor for this item. After the original\r\n *     visitor is called on item entry, next visitors are called after handling\r\n *     a non-empty `key` and when exiting the item.\r\n */\r\nfunction visit(cst, visitor) {\r\n    if ('type' in cst && cst.type === 'document')\r\n        cst = { start: cst.start, value: cst.value };\r\n    _visit(Object.freeze([]), cst, visitor);\r\n}\r\n// Without the `as symbol` casts, TS declares these in the `visit`\r\n// namespace using `var`, but then complains about that because\r\n// `unique symbol` must be `const`.\r\n/** Terminate visit traversal completely */\r\nvisit.BREAK = BREAK;\r\n/** Do not visit the children of the current item */\r\nvisit.SKIP = SKIP;\r\n/** Remove the current item */\r\nvisit.REMOVE = REMOVE;\r\n/** Find the item at `path` from `cst` as the root */\r\nvisit.itemAtPath = (cst, path) => {\r\n    let item = cst;\r\n    for (const [field, index] of path) {\r\n        const tok = item && item[field];\r\n        if (tok && 'items' in tok) {\r\n            item = tok.items[index];\r\n        }\r\n        else\r\n            return undefined;\r\n    }\r\n    return item;\r\n};\r\n/**\r\n * Get the immediate parent collection of the item at `path` from `cst` as the root.\r\n *\r\n * Throws an error if the collection is not found, which should never happen if the item itself exists.\r\n */\r\nvisit.parentCollection = (cst, path) => {\r\n    const parent = visit.itemAtPath(cst, path.slice(0, -1));\r\n    const field = path[path.length - 1][0];\r\n    const coll = parent && parent[field];\r\n    if (coll && 'items' in coll)\r\n        return coll;\r\n    throw new Error('Parent collection not found');\r\n};\r\nfunction _visit(path, item, visitor) {\r\n    let ctrl = visitor(item, path);\r\n    if (typeof ctrl === 'symbol')\r\n        return ctrl;\r\n    for (const field of ['key', 'value']) {\r\n        const token = item[field];\r\n        if (token && 'items' in token) {\r\n            for (let i = 0; i < token.items.length; ++i) {\r\n                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);\r\n                if (typeof ci === 'number')\r\n                    i = ci - 1;\r\n                else if (ci === BREAK)\r\n                    return BREAK;\r\n                else if (ci === REMOVE) {\r\n                    token.items.splice(i, 1);\r\n                    i -= 1;\r\n                }\r\n            }\r\n            if (typeof ctrl === 'function' && field === 'key')\r\n                ctrl = ctrl(item, path);\r\n        }\r\n    }\r\n    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/parse/cst-visit.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/parse/cst.js":
/*!*****************************************************!*\
  !*** ./node_modules/yaml/browser/dist/parse/cst.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createScalarToken\": () => (/* reexport safe */ _cst_scalar_js__WEBPACK_IMPORTED_MODULE_0__.createScalarToken),\n/* harmony export */   \"resolveAsScalar\": () => (/* reexport safe */ _cst_scalar_js__WEBPACK_IMPORTED_MODULE_0__.resolveAsScalar),\n/* harmony export */   \"setScalarValue\": () => (/* reexport safe */ _cst_scalar_js__WEBPACK_IMPORTED_MODULE_0__.setScalarValue),\n/* harmony export */   \"stringify\": () => (/* reexport safe */ _cst_stringify_js__WEBPACK_IMPORTED_MODULE_1__.stringify),\n/* harmony export */   \"visit\": () => (/* reexport safe */ _cst_visit_js__WEBPACK_IMPORTED_MODULE_2__.visit),\n/* harmony export */   \"BOM\": () => (/* binding */ BOM),\n/* harmony export */   \"DOCUMENT\": () => (/* binding */ DOCUMENT),\n/* harmony export */   \"FLOW_END\": () => (/* binding */ FLOW_END),\n/* harmony export */   \"SCALAR\": () => (/* binding */ SCALAR),\n/* harmony export */   \"isCollection\": () => (/* binding */ isCollection),\n/* harmony export */   \"isScalar\": () => (/* binding */ isScalar),\n/* harmony export */   \"prettyToken\": () => (/* binding */ prettyToken),\n/* harmony export */   \"tokenType\": () => (/* binding */ tokenType)\n/* harmony export */ });\n/* harmony import */ var _cst_scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cst-scalar.js */ \"./node_modules/yaml/browser/dist/parse/cst-scalar.js\");\n/* harmony import */ var _cst_stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cst-stringify.js */ \"./node_modules/yaml/browser/dist/parse/cst-stringify.js\");\n/* harmony import */ var _cst_visit_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cst-visit.js */ \"./node_modules/yaml/browser/dist/parse/cst-visit.js\");\n\r\n\r\n\r\n\r\n/** The byte order mark */\r\nconst BOM = '\\u{FEFF}';\r\n/** Start of doc-mode */\r\nconst DOCUMENT = '\\x02'; // C0: Start of Text\r\n/** Unexpected end of flow-mode */\r\nconst FLOW_END = '\\x18'; // C0: Cancel\r\n/** Next token is a scalar value */\r\nconst SCALAR = '\\x1f'; // C0: Unit Separator\r\n/** @returns `true` if `token` is a flow or block collection */\r\nconst isCollection = (token) => !!token && 'items' in token;\r\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\r\nconst isScalar = (token) => !!token &&\r\n    (token.type === 'scalar' ||\r\n        token.type === 'single-quoted-scalar' ||\r\n        token.type === 'double-quoted-scalar' ||\r\n        token.type === 'block-scalar');\r\n/* istanbul ignore next */\r\n/** Get a printable representation of a lexer token */\r\nfunction prettyToken(token) {\r\n    switch (token) {\r\n        case BOM:\r\n            return '<BOM>';\r\n        case DOCUMENT:\r\n            return '<DOC>';\r\n        case FLOW_END:\r\n            return '<FLOW_END>';\r\n        case SCALAR:\r\n            return '<SCALAR>';\r\n        default:\r\n            return JSON.stringify(token);\r\n    }\r\n}\r\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\r\nfunction tokenType(source) {\r\n    switch (source) {\r\n        case BOM:\r\n            return 'byte-order-mark';\r\n        case DOCUMENT:\r\n            return 'doc-mode';\r\n        case FLOW_END:\r\n            return 'flow-error-end';\r\n        case SCALAR:\r\n            return 'scalar';\r\n        case '---':\r\n            return 'doc-start';\r\n        case '...':\r\n            return 'doc-end';\r\n        case '':\r\n        case '\\n':\r\n        case '\\r\\n':\r\n            return 'newline';\r\n        case '-':\r\n            return 'seq-item-ind';\r\n        case '?':\r\n            return 'explicit-key-ind';\r\n        case ':':\r\n            return 'map-value-ind';\r\n        case '{':\r\n            return 'flow-map-start';\r\n        case '}':\r\n            return 'flow-map-end';\r\n        case '[':\r\n            return 'flow-seq-start';\r\n        case ']':\r\n            return 'flow-seq-end';\r\n        case ',':\r\n            return 'comma';\r\n    }\r\n    switch (source[0]) {\r\n        case ' ':\r\n        case '\\t':\r\n            return 'space';\r\n        case '#':\r\n            return 'comment';\r\n        case '%':\r\n            return 'directive-line';\r\n        case '*':\r\n            return 'alias';\r\n        case '&':\r\n            return 'anchor';\r\n        case '!':\r\n            return 'tag';\r\n        case \"'\":\r\n            return 'single-quoted-scalar';\r\n        case '\"':\r\n            return 'double-quoted-scalar';\r\n        case '|':\r\n        case '>':\r\n            return 'block-scalar-header';\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/parse/cst.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/parse/lexer.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/browser/dist/parse/lexer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Lexer\": () => (/* binding */ Lexer)\n/* harmony export */ });\n/* harmony import */ var _cst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cst.js */ \"./node_modules/yaml/browser/dist/parse/cst.js\");\n\r\n\r\n/*\r\nSTART -> stream\r\n\r\nstream\r\n  directive -> line-end -> stream\r\n  indent + line-end -> stream\r\n  [else] -> line-start\r\n\r\nline-end\r\n  comment -> line-end\r\n  newline -> .\r\n  input-end -> END\r\n\r\nline-start\r\n  doc-start -> doc\r\n  doc-end -> stream\r\n  [else] -> indent -> block-start\r\n\r\nblock-start\r\n  seq-item-start -> block-start\r\n  explicit-key-start -> block-start\r\n  map-value-start -> block-start\r\n  [else] -> doc\r\n\r\ndoc\r\n  line-end -> line-start\r\n  spaces -> doc\r\n  anchor -> doc\r\n  tag -> doc\r\n  flow-start -> flow -> doc\r\n  flow-end -> error -> doc\r\n  seq-item-start -> error -> doc\r\n  explicit-key-start -> error -> doc\r\n  map-value-start -> doc\r\n  alias -> doc\r\n  quote-start -> quoted-scalar -> doc\r\n  block-scalar-header -> line-end -> block-scalar(min) -> line-start\r\n  [else] -> plain-scalar(false, min) -> doc\r\n\r\nflow\r\n  line-end -> flow\r\n  spaces -> flow\r\n  anchor -> flow\r\n  tag -> flow\r\n  flow-start -> flow -> flow\r\n  flow-end -> .\r\n  seq-item-start -> error -> flow\r\n  explicit-key-start -> flow\r\n  map-value-start -> flow\r\n  alias -> flow\r\n  quote-start -> quoted-scalar -> flow\r\n  comma -> flow\r\n  [else] -> plain-scalar(true, 0) -> flow\r\n\r\nquoted-scalar\r\n  quote-end -> .\r\n  [else] -> quoted-scalar\r\n\r\nblock-scalar(min)\r\n  newline + peek(indent < min) -> .\r\n  [else] -> block-scalar(min)\r\n\r\nplain-scalar(is-flow, min)\r\n  scalar-end(is-flow) -> .\r\n  peek(newline + (indent < min)) -> .\r\n  [else] -> plain-scalar(min)\r\n*/\r\nfunction isEmpty(ch) {\r\n    switch (ch) {\r\n        case undefined:\r\n        case ' ':\r\n        case '\\n':\r\n        case '\\r':\r\n        case '\\t':\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nconst hexDigits = '0123456789ABCDEFabcdef'.split('');\r\nconst tagChars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()\".split('');\r\nconst invalidFlowScalarChars = ',[]{}'.split('');\r\nconst invalidAnchorChars = ' ,[]{}\\n\\r\\t'.split('');\r\nconst isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);\r\n/**\r\n * Splits an input string into lexical tokens, i.e. smaller strings that are\r\n * easily identifiable by `tokens.tokenType()`.\r\n *\r\n * Lexing starts always in a \"stream\" context. Incomplete input may be buffered\r\n * until a complete token can be emitted.\r\n *\r\n * In addition to slices of the original input, the following control characters\r\n * may also be emitted:\r\n *\r\n * - `\\x02` (Start of Text): A document starts with the next token\r\n * - `\\x18` (Cancel): Unexpected end of flow-mode (indicates an error)\r\n * - `\\x1f` (Unit Separator): Next token is a scalar value\r\n * - `\\u{FEFF}` (Byte order mark): Emitted separately outside documents\r\n */\r\nclass Lexer {\r\n    constructor() {\r\n        /**\r\n         * Flag indicating whether the end of the current buffer marks the end of\r\n         * all input\r\n         */\r\n        this.atEnd = false;\r\n        /**\r\n         * Explicit indent set in block scalar header, as an offset from the current\r\n         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not\r\n         * explicitly set.\r\n         */\r\n        this.blockScalarIndent = -1;\r\n        /**\r\n         * Block scalars that include a + (keep) chomping indicator in their header\r\n         * include trailing empty lines, which are otherwise excluded from the\r\n         * scalar's contents.\r\n         */\r\n        this.blockScalarKeep = false;\r\n        /** Current input */\r\n        this.buffer = '';\r\n        /**\r\n         * Flag noting whether the map value indicator : can immediately follow this\r\n         * node within a flow context.\r\n         */\r\n        this.flowKey = false;\r\n        /** Count of surrounding flow collection levels. */\r\n        this.flowLevel = 0;\r\n        /**\r\n         * Minimum level of indentation required for next lines to be parsed as a\r\n         * part of the current scalar value.\r\n         */\r\n        this.indentNext = 0;\r\n        /** Indentation level of the current line. */\r\n        this.indentValue = 0;\r\n        /** Position of the next \\n character. */\r\n        this.lineEndPos = null;\r\n        /** Stores the state of the lexer if reaching the end of incpomplete input */\r\n        this.next = null;\r\n        /** A pointer to `buffer`; the current position of the lexer. */\r\n        this.pos = 0;\r\n    }\r\n    /**\r\n     * Generate YAML tokens from the `source` string. If `incomplete`,\r\n     * a part of the last line may be left as a buffer for the next call.\r\n     *\r\n     * @returns A generator of lexical tokens\r\n     */\r\n    *lex(source, incomplete = false) {\r\n        if (source) {\r\n            this.buffer = this.buffer ? this.buffer + source : source;\r\n            this.lineEndPos = null;\r\n        }\r\n        this.atEnd = !incomplete;\r\n        let next = this.next || 'stream';\r\n        while (next && (incomplete || this.hasChars(1)))\r\n            next = yield* this.parseNext(next);\r\n    }\r\n    atLineEnd() {\r\n        let i = this.pos;\r\n        let ch = this.buffer[i];\r\n        while (ch === ' ' || ch === '\\t')\r\n            ch = this.buffer[++i];\r\n        if (!ch || ch === '#' || ch === '\\n')\r\n            return true;\r\n        if (ch === '\\r')\r\n            return this.buffer[i + 1] === '\\n';\r\n        return false;\r\n    }\r\n    charAt(n) {\r\n        return this.buffer[this.pos + n];\r\n    }\r\n    continueScalar(offset) {\r\n        let ch = this.buffer[offset];\r\n        if (this.indentNext > 0) {\r\n            let indent = 0;\r\n            while (ch === ' ')\r\n                ch = this.buffer[++indent + offset];\r\n            if (ch === '\\r') {\r\n                const next = this.buffer[indent + offset + 1];\r\n                if (next === '\\n' || (!next && !this.atEnd))\r\n                    return offset + indent + 1;\r\n            }\r\n            return ch === '\\n' || indent >= this.indentNext || (!ch && !this.atEnd)\r\n                ? offset + indent\r\n                : -1;\r\n        }\r\n        if (ch === '-' || ch === '.') {\r\n            const dt = this.buffer.substr(offset, 3);\r\n            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))\r\n                return -1;\r\n        }\r\n        return offset;\r\n    }\r\n    getLine() {\r\n        let end = this.lineEndPos;\r\n        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {\r\n            end = this.buffer.indexOf('\\n', this.pos);\r\n            this.lineEndPos = end;\r\n        }\r\n        if (end === -1)\r\n            return this.atEnd ? this.buffer.substring(this.pos) : null;\r\n        if (this.buffer[end - 1] === '\\r')\r\n            end -= 1;\r\n        return this.buffer.substring(this.pos, end);\r\n    }\r\n    hasChars(n) {\r\n        return this.pos + n <= this.buffer.length;\r\n    }\r\n    setNext(state) {\r\n        this.buffer = this.buffer.substring(this.pos);\r\n        this.pos = 0;\r\n        this.lineEndPos = null;\r\n        this.next = state;\r\n        return null;\r\n    }\r\n    peek(n) {\r\n        return this.buffer.substr(this.pos, n);\r\n    }\r\n    *parseNext(next) {\r\n        switch (next) {\r\n            case 'stream':\r\n                return yield* this.parseStream();\r\n            case 'line-start':\r\n                return yield* this.parseLineStart();\r\n            case 'block-start':\r\n                return yield* this.parseBlockStart();\r\n            case 'doc':\r\n                return yield* this.parseDocument();\r\n            case 'flow':\r\n                return yield* this.parseFlowCollection();\r\n            case 'quoted-scalar':\r\n                return yield* this.parseQuotedScalar();\r\n            case 'block-scalar':\r\n                return yield* this.parseBlockScalar();\r\n            case 'plain-scalar':\r\n                return yield* this.parsePlainScalar();\r\n        }\r\n    }\r\n    *parseStream() {\r\n        let line = this.getLine();\r\n        if (line === null)\r\n            return this.setNext('stream');\r\n        if (line[0] === _cst_js__WEBPACK_IMPORTED_MODULE_0__.BOM) {\r\n            yield* this.pushCount(1);\r\n            line = line.substring(1);\r\n        }\r\n        if (line[0] === '%') {\r\n            let dirEnd = line.length;\r\n            const cs = line.indexOf('#');\r\n            if (cs !== -1) {\r\n                const ch = line[cs - 1];\r\n                if (ch === ' ' || ch === '\\t')\r\n                    dirEnd = cs - 1;\r\n            }\r\n            while (true) {\r\n                const ch = line[dirEnd - 1];\r\n                if (ch === ' ' || ch === '\\t')\r\n                    dirEnd -= 1;\r\n                else\r\n                    break;\r\n            }\r\n            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));\r\n            yield* this.pushCount(line.length - n); // possible comment\r\n            this.pushNewline();\r\n            return 'stream';\r\n        }\r\n        if (this.atLineEnd()) {\r\n            const sp = yield* this.pushSpaces(true);\r\n            yield* this.pushCount(line.length - sp);\r\n            yield* this.pushNewline();\r\n            return 'stream';\r\n        }\r\n        yield _cst_js__WEBPACK_IMPORTED_MODULE_0__.DOCUMENT;\r\n        return yield* this.parseLineStart();\r\n    }\r\n    *parseLineStart() {\r\n        const ch = this.charAt(0);\r\n        if (!ch && !this.atEnd)\r\n            return this.setNext('line-start');\r\n        if (ch === '-' || ch === '.') {\r\n            if (!this.atEnd && !this.hasChars(4))\r\n                return this.setNext('line-start');\r\n            const s = this.peek(3);\r\n            if (s === '---' && isEmpty(this.charAt(3))) {\r\n                yield* this.pushCount(3);\r\n                this.indentValue = 0;\r\n                this.indentNext = 0;\r\n                return 'doc';\r\n            }\r\n            else if (s === '...' && isEmpty(this.charAt(3))) {\r\n                yield* this.pushCount(3);\r\n                return 'stream';\r\n            }\r\n        }\r\n        this.indentValue = yield* this.pushSpaces(false);\r\n        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))\r\n            this.indentNext = this.indentValue;\r\n        return yield* this.parseBlockStart();\r\n    }\r\n    *parseBlockStart() {\r\n        const [ch0, ch1] = this.peek(2);\r\n        if (!ch1 && !this.atEnd)\r\n            return this.setNext('block-start');\r\n        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {\r\n            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));\r\n            this.indentNext = this.indentValue + 1;\r\n            this.indentValue += n;\r\n            return yield* this.parseBlockStart();\r\n        }\r\n        return 'doc';\r\n    }\r\n    *parseDocument() {\r\n        yield* this.pushSpaces(true);\r\n        const line = this.getLine();\r\n        if (line === null)\r\n            return this.setNext('doc');\r\n        let n = yield* this.pushIndicators();\r\n        switch (line[n]) {\r\n            case '#':\r\n                yield* this.pushCount(line.length - n);\r\n            // fallthrough\r\n            case undefined:\r\n                yield* this.pushNewline();\r\n                return yield* this.parseLineStart();\r\n            case '{':\r\n            case '[':\r\n                yield* this.pushCount(1);\r\n                this.flowKey = false;\r\n                this.flowLevel = 1;\r\n                return 'flow';\r\n            case '}':\r\n            case ']':\r\n                // this is an error\r\n                yield* this.pushCount(1);\r\n                return 'doc';\r\n            case '*':\r\n                yield* this.pushUntil(isNotAnchorChar);\r\n                return 'doc';\r\n            case '\"':\r\n            case \"'\":\r\n                return yield* this.parseQuotedScalar();\r\n            case '|':\r\n            case '>':\r\n                n += yield* this.parseBlockScalarHeader();\r\n                n += yield* this.pushSpaces(true);\r\n                yield* this.pushCount(line.length - n);\r\n                yield* this.pushNewline();\r\n                return yield* this.parseBlockScalar();\r\n            default:\r\n                return yield* this.parsePlainScalar();\r\n        }\r\n    }\r\n    *parseFlowCollection() {\r\n        let nl, sp;\r\n        let indent = -1;\r\n        do {\r\n            nl = yield* this.pushNewline();\r\n            sp = yield* this.pushSpaces(true);\r\n            if (nl > 0)\r\n                this.indentValue = indent = sp;\r\n        } while (nl + sp > 0);\r\n        const line = this.getLine();\r\n        if (line === null)\r\n            return this.setNext('flow');\r\n        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||\r\n            (indent === 0 &&\r\n                (line.startsWith('---') || line.startsWith('...')) &&\r\n                isEmpty(line[3]))) {\r\n            // Allowing for the terminal ] or } at the same (rather than greater)\r\n            // indent level as the initial [ or { is technically invalid, but\r\n            // failing here would be surprising to users.\r\n            const atFlowEndMarker = indent === this.indentNext - 1 &&\r\n                this.flowLevel === 1 &&\r\n                (line[0] === ']' || line[0] === '}');\r\n            if (!atFlowEndMarker) {\r\n                // this is an error\r\n                this.flowLevel = 0;\r\n                yield _cst_js__WEBPACK_IMPORTED_MODULE_0__.FLOW_END;\r\n                return yield* this.parseLineStart();\r\n            }\r\n        }\r\n        let n = 0;\r\n        while (line[n] === ',') {\r\n            n += yield* this.pushCount(1);\r\n            n += yield* this.pushSpaces(true);\r\n            this.flowKey = false;\r\n        }\r\n        n += yield* this.pushIndicators();\r\n        switch (line[n]) {\r\n            case undefined:\r\n                return 'flow';\r\n            case '#':\r\n                yield* this.pushCount(line.length - n);\r\n                return 'flow';\r\n            case '{':\r\n            case '[':\r\n                yield* this.pushCount(1);\r\n                this.flowKey = false;\r\n                this.flowLevel += 1;\r\n                return 'flow';\r\n            case '}':\r\n            case ']':\r\n                yield* this.pushCount(1);\r\n                this.flowKey = true;\r\n                this.flowLevel -= 1;\r\n                return this.flowLevel ? 'flow' : 'doc';\r\n            case '*':\r\n                yield* this.pushUntil(isNotAnchorChar);\r\n                return 'flow';\r\n            case '\"':\r\n            case \"'\":\r\n                this.flowKey = true;\r\n                return yield* this.parseQuotedScalar();\r\n            case ':': {\r\n                const next = this.charAt(1);\r\n                if (this.flowKey || isEmpty(next) || next === ',') {\r\n                    yield* this.pushCount(1);\r\n                    yield* this.pushSpaces(true);\r\n                    return 'flow';\r\n                }\r\n            }\r\n            // fallthrough\r\n            default:\r\n                this.flowKey = false;\r\n                return yield* this.parsePlainScalar();\r\n        }\r\n    }\r\n    *parseQuotedScalar() {\r\n        const quote = this.charAt(0);\r\n        let end = this.buffer.indexOf(quote, this.pos + 1);\r\n        if (quote === \"'\") {\r\n            while (end !== -1 && this.buffer[end + 1] === \"'\")\r\n                end = this.buffer.indexOf(\"'\", end + 2);\r\n        }\r\n        else {\r\n            // double-quote\r\n            while (end !== -1) {\r\n                let n = 0;\r\n                while (this.buffer[end - 1 - n] === '\\\\')\r\n                    n += 1;\r\n                if (n % 2 === 0)\r\n                    break;\r\n                end = this.buffer.indexOf('\"', end + 1);\r\n            }\r\n        }\r\n        // Only looking for newlines within the quotes\r\n        const qb = this.buffer.substring(0, end);\r\n        let nl = qb.indexOf('\\n', this.pos);\r\n        if (nl !== -1) {\r\n            while (nl !== -1) {\r\n                const cs = this.continueScalar(nl + 1);\r\n                if (cs === -1)\r\n                    break;\r\n                nl = qb.indexOf('\\n', cs);\r\n            }\r\n            if (nl !== -1) {\r\n                // this is an error caused by an unexpected unindent\r\n                end = nl - (qb[nl - 1] === '\\r' ? 2 : 1);\r\n            }\r\n        }\r\n        if (end === -1) {\r\n            if (!this.atEnd)\r\n                return this.setNext('quoted-scalar');\r\n            end = this.buffer.length;\r\n        }\r\n        yield* this.pushToIndex(end + 1, false);\r\n        return this.flowLevel ? 'flow' : 'doc';\r\n    }\r\n    *parseBlockScalarHeader() {\r\n        this.blockScalarIndent = -1;\r\n        this.blockScalarKeep = false;\r\n        let i = this.pos;\r\n        while (true) {\r\n            const ch = this.buffer[++i];\r\n            if (ch === '+')\r\n                this.blockScalarKeep = true;\r\n            else if (ch > '0' && ch <= '9')\r\n                this.blockScalarIndent = Number(ch) - 1;\r\n            else if (ch !== '-')\r\n                break;\r\n        }\r\n        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');\r\n    }\r\n    *parseBlockScalar() {\r\n        let nl = this.pos - 1; // may be -1 if this.pos === 0\r\n        let indent = 0;\r\n        let ch;\r\n        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {\r\n            switch (ch) {\r\n                case ' ':\r\n                    indent += 1;\r\n                    break;\r\n                case '\\n':\r\n                    nl = i;\r\n                    indent = 0;\r\n                    break;\r\n                case '\\r': {\r\n                    const next = this.buffer[i + 1];\r\n                    if (!next && !this.atEnd)\r\n                        return this.setNext('block-scalar');\r\n                    if (next === '\\n')\r\n                        break;\r\n                } // fallthrough\r\n                default:\r\n                    break loop;\r\n            }\r\n        }\r\n        if (!ch && !this.atEnd)\r\n            return this.setNext('block-scalar');\r\n        if (indent >= this.indentNext) {\r\n            if (this.blockScalarIndent === -1)\r\n                this.indentNext = indent;\r\n            else\r\n                this.indentNext += this.blockScalarIndent;\r\n            do {\r\n                const cs = this.continueScalar(nl + 1);\r\n                if (cs === -1)\r\n                    break;\r\n                nl = this.buffer.indexOf('\\n', cs);\r\n            } while (nl !== -1);\r\n            if (nl === -1) {\r\n                if (!this.atEnd)\r\n                    return this.setNext('block-scalar');\r\n                nl = this.buffer.length;\r\n            }\r\n        }\r\n        if (!this.blockScalarKeep) {\r\n            do {\r\n                let i = nl - 1;\r\n                let ch = this.buffer[i];\r\n                if (ch === '\\r')\r\n                    ch = this.buffer[--i];\r\n                while (ch === ' ' || ch === '\\t')\r\n                    ch = this.buffer[--i];\r\n                if (ch === '\\n' && i >= this.pos)\r\n                    nl = i;\r\n                else\r\n                    break;\r\n            } while (true);\r\n        }\r\n        yield _cst_js__WEBPACK_IMPORTED_MODULE_0__.SCALAR;\r\n        yield* this.pushToIndex(nl + 1, true);\r\n        return yield* this.parseLineStart();\r\n    }\r\n    *parsePlainScalar() {\r\n        const inFlow = this.flowLevel > 0;\r\n        let end = this.pos - 1;\r\n        let i = this.pos - 1;\r\n        let ch;\r\n        while ((ch = this.buffer[++i])) {\r\n            if (ch === ':') {\r\n                const next = this.buffer[i + 1];\r\n                if (isEmpty(next) || (inFlow && next === ','))\r\n                    break;\r\n                end = i;\r\n            }\r\n            else if (isEmpty(ch)) {\r\n                let next = this.buffer[i + 1];\r\n                if (ch === '\\r') {\r\n                    if (next === '\\n') {\r\n                        i += 1;\r\n                        ch = '\\n';\r\n                        next = this.buffer[i + 1];\r\n                    }\r\n                    else\r\n                        end = i;\r\n                }\r\n                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))\r\n                    break;\r\n                if (ch === '\\n') {\r\n                    const cs = this.continueScalar(i + 1);\r\n                    if (cs === -1)\r\n                        break;\r\n                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'\r\n                }\r\n            }\r\n            else {\r\n                if (inFlow && invalidFlowScalarChars.includes(ch))\r\n                    break;\r\n                end = i;\r\n            }\r\n        }\r\n        if (!ch && !this.atEnd)\r\n            return this.setNext('plain-scalar');\r\n        yield _cst_js__WEBPACK_IMPORTED_MODULE_0__.SCALAR;\r\n        yield* this.pushToIndex(end + 1, true);\r\n        return inFlow ? 'flow' : 'doc';\r\n    }\r\n    *pushCount(n) {\r\n        if (n > 0) {\r\n            yield this.buffer.substr(this.pos, n);\r\n            this.pos += n;\r\n            return n;\r\n        }\r\n        return 0;\r\n    }\r\n    *pushToIndex(i, allowEmpty) {\r\n        const s = this.buffer.slice(this.pos, i);\r\n        if (s) {\r\n            yield s;\r\n            this.pos += s.length;\r\n            return s.length;\r\n        }\r\n        else if (allowEmpty)\r\n            yield '';\r\n        return 0;\r\n    }\r\n    *pushIndicators() {\r\n        switch (this.charAt(0)) {\r\n            case '!':\r\n                return ((yield* this.pushTag()) +\r\n                    (yield* this.pushSpaces(true)) +\r\n                    (yield* this.pushIndicators()));\r\n            case '&':\r\n                return ((yield* this.pushUntil(isNotAnchorChar)) +\r\n                    (yield* this.pushSpaces(true)) +\r\n                    (yield* this.pushIndicators()));\r\n            case ':':\r\n            case '?': // this is an error outside flow collections\r\n            case '-': // this is an error\r\n                if (isEmpty(this.charAt(1))) {\r\n                    if (this.flowLevel === 0)\r\n                        this.indentNext = this.indentValue + 1;\r\n                    return ((yield* this.pushCount(1)) +\r\n                        (yield* this.pushSpaces(true)) +\r\n                        (yield* this.pushIndicators()));\r\n                }\r\n        }\r\n        return 0;\r\n    }\r\n    *pushTag() {\r\n        if (this.charAt(1) === '<') {\r\n            let i = this.pos + 2;\r\n            let ch = this.buffer[i];\r\n            while (!isEmpty(ch) && ch !== '>')\r\n                ch = this.buffer[++i];\r\n            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);\r\n        }\r\n        else {\r\n            let i = this.pos + 1;\r\n            let ch = this.buffer[i];\r\n            while (ch) {\r\n                if (tagChars.includes(ch))\r\n                    ch = this.buffer[++i];\r\n                else if (ch === '%' &&\r\n                    hexDigits.includes(this.buffer[i + 1]) &&\r\n                    hexDigits.includes(this.buffer[i + 2])) {\r\n                    ch = this.buffer[(i += 3)];\r\n                }\r\n                else\r\n                    break;\r\n            }\r\n            return yield* this.pushToIndex(i, false);\r\n        }\r\n    }\r\n    *pushNewline() {\r\n        const ch = this.buffer[this.pos];\r\n        if (ch === '\\n')\r\n            return yield* this.pushCount(1);\r\n        else if (ch === '\\r' && this.charAt(1) === '\\n')\r\n            return yield* this.pushCount(2);\r\n        else\r\n            return 0;\r\n    }\r\n    *pushSpaces(allowTabs) {\r\n        let i = this.pos - 1;\r\n        let ch;\r\n        do {\r\n            ch = this.buffer[++i];\r\n        } while (ch === ' ' || (allowTabs && ch === '\\t'));\r\n        const n = i - this.pos;\r\n        if (n > 0) {\r\n            yield this.buffer.substr(this.pos, n);\r\n            this.pos = i;\r\n        }\r\n        return n;\r\n    }\r\n    *pushUntil(test) {\r\n        let i = this.pos;\r\n        let ch = this.buffer[i];\r\n        while (!test(ch))\r\n            ch = this.buffer[++i];\r\n        return yield* this.pushToIndex(i, false);\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/parse/lexer.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/parse/line-counter.js":
/*!**************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/parse/line-counter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LineCounter\": () => (/* binding */ LineCounter)\n/* harmony export */ });\n/**\r\n * Tracks newlines during parsing in order to provide an efficient API for\r\n * determining the one-indexed `{ line, col }` position for any offset\r\n * within the input.\r\n */\r\nclass LineCounter {\r\n    constructor() {\r\n        this.lineStarts = [];\r\n        /**\r\n         * Should be called in ascending order. Otherwise, call\r\n         * `lineCounter.lineStarts.sort()` before calling `linePos()`.\r\n         */\r\n        this.addNewLine = (offset) => this.lineStarts.push(offset);\r\n        /**\r\n         * Performs a binary search and returns the 1-indexed { line, col }\r\n         * position of `offset`. If `line === 0`, `addNewLine` has never been\r\n         * called or `offset` is before the first known newline.\r\n         */\r\n        this.linePos = (offset) => {\r\n            let low = 0;\r\n            let high = this.lineStarts.length;\r\n            while (low < high) {\r\n                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)\r\n                if (this.lineStarts[mid] < offset)\r\n                    low = mid + 1;\r\n                else\r\n                    high = mid;\r\n            }\r\n            if (this.lineStarts[low] === offset)\r\n                return { line: low + 1, col: 1 };\r\n            if (low === 0)\r\n                return { line: 0, col: offset };\r\n            const start = this.lineStarts[low - 1];\r\n            return { line: low, col: offset - start + 1 };\r\n        };\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/parse/line-counter.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/parse/parser.js":
/*!********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/parse/parser.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Parser\": () => (/* binding */ Parser)\n/* harmony export */ });\n/* harmony import */ var _cst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cst.js */ \"./node_modules/yaml/browser/dist/parse/cst.js\");\n/* harmony import */ var _lexer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lexer.js */ \"./node_modules/yaml/browser/dist/parse/lexer.js\");\n\r\n\r\n\r\nfunction includesToken(list, type) {\r\n    for (let i = 0; i < list.length; ++i)\r\n        if (list[i].type === type)\r\n            return true;\r\n    return false;\r\n}\r\nfunction includesNonEmpty(list) {\r\n    for (let i = 0; i < list.length; ++i) {\r\n        switch (list[i].type) {\r\n            case 'space':\r\n            case 'comment':\r\n            case 'newline':\r\n                break;\r\n            default:\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction isFlowToken(token) {\r\n    switch (token === null || token === void 0 ? void 0 : token.type) {\r\n        case 'alias':\r\n        case 'scalar':\r\n        case 'single-quoted-scalar':\r\n        case 'double-quoted-scalar':\r\n        case 'flow-collection':\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getPrevProps(parent) {\r\n    switch (parent.type) {\r\n        case 'document':\r\n            return parent.start;\r\n        case 'block-map': {\r\n            const it = parent.items[parent.items.length - 1];\r\n            return it.sep || it.start;\r\n        }\r\n        case 'block-seq':\r\n            return parent.items[parent.items.length - 1].start;\r\n        /* istanbul ignore next should not happen */\r\n        default:\r\n            return [];\r\n    }\r\n}\r\n/** Note: May modify input array */\r\nfunction getFirstKeyStartProps(prev) {\r\n    var _a;\r\n    if (prev.length === 0)\r\n        return [];\r\n    let i = prev.length;\r\n    loop: while (--i >= 0) {\r\n        switch (prev[i].type) {\r\n            case 'doc-start':\r\n            case 'explicit-key-ind':\r\n            case 'map-value-ind':\r\n            case 'seq-item-ind':\r\n            case 'newline':\r\n                break loop;\r\n        }\r\n    }\r\n    while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === 'space') {\r\n        /* loop */\r\n    }\r\n    return prev.splice(i, prev.length);\r\n}\r\nfunction fixFlowSeqItems(fc) {\r\n    if (fc.start.type === 'flow-seq-start') {\r\n        for (const it of fc.items) {\r\n            if (it.sep &&\r\n                !it.value &&\r\n                !includesToken(it.start, 'explicit-key-ind') &&\r\n                !includesToken(it.sep, 'map-value-ind')) {\r\n                if (it.key)\r\n                    it.value = it.key;\r\n                delete it.key;\r\n                if (isFlowToken(it.value)) {\r\n                    if (it.value.end)\r\n                        Array.prototype.push.apply(it.value.end, it.sep);\r\n                    else\r\n                        it.value.end = it.sep;\r\n                }\r\n                else\r\n                    Array.prototype.push.apply(it.start, it.sep);\r\n                delete it.sep;\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * A YAML concrete syntax tree (CST) parser\r\n *\r\n * ```ts\r\n * const src: string = ...\r\n * for (const token of new Parser().parse(src)) {\r\n *   // token: Token\r\n * }\r\n * ```\r\n *\r\n * To use the parser with a user-provided lexer:\r\n *\r\n * ```ts\r\n * function* parse(source: string, lexer: Lexer) {\r\n *   const parser = new Parser()\r\n *   for (const lexeme of lexer.lex(source))\r\n *     yield* parser.next(lexeme)\r\n *   yield* parser.end()\r\n * }\r\n *\r\n * const src: string = ...\r\n * const lexer = new Lexer()\r\n * for (const token of parse(src, lexer)) {\r\n *   // token: Token\r\n * }\r\n * ```\r\n */\r\nclass Parser {\r\n    /**\r\n     * @param onNewLine - If defined, called separately with the start position of\r\n     *   each new line (in `parse()`, including the start of input).\r\n     */\r\n    constructor(onNewLine) {\r\n        /** If true, space and sequence indicators count as indentation */\r\n        this.atNewLine = true;\r\n        /** If true, next token is a scalar value */\r\n        this.atScalar = false;\r\n        /** Current indentation level */\r\n        this.indent = 0;\r\n        /** Current offset since the start of parsing */\r\n        this.offset = 0;\r\n        /** On the same line with a block map key */\r\n        this.onKeyLine = false;\r\n        /** Top indicates the node that's currently being built */\r\n        this.stack = [];\r\n        /** The source of the current token, set in parse() */\r\n        this.source = '';\r\n        /** The type of the current token, set in parse() */\r\n        this.type = '';\r\n        // Must be defined after `next()`\r\n        this.lexer = new _lexer_js__WEBPACK_IMPORTED_MODULE_1__.Lexer();\r\n        this.onNewLine = onNewLine;\r\n    }\r\n    /**\r\n     * Parse `source` as a YAML stream.\r\n     * If `incomplete`, a part of the last line may be left as a buffer for the next call.\r\n     *\r\n     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\r\n     *\r\n     * @returns A generator of tokens representing each directive, document, and other structure.\r\n     */\r\n    *parse(source, incomplete = false) {\r\n        if (this.onNewLine && this.offset === 0)\r\n            this.onNewLine(0);\r\n        for (const lexeme of this.lexer.lex(source, incomplete))\r\n            yield* this.next(lexeme);\r\n        if (!incomplete)\r\n            yield* this.end();\r\n    }\r\n    /**\r\n     * Advance the parser by the `source` of one lexical token.\r\n     */\r\n    *next(source) {\r\n        this.source = source;\r\n        if (this.atScalar) {\r\n            this.atScalar = false;\r\n            yield* this.step();\r\n            this.offset += source.length;\r\n            return;\r\n        }\r\n        const type = (0,_cst_js__WEBPACK_IMPORTED_MODULE_0__.tokenType)(source);\r\n        if (!type) {\r\n            const message = `Not a YAML token: ${source}`;\r\n            yield* this.pop({ type: 'error', offset: this.offset, message, source });\r\n            this.offset += source.length;\r\n        }\r\n        else if (type === 'scalar') {\r\n            this.atNewLine = false;\r\n            this.atScalar = true;\r\n            this.type = 'scalar';\r\n        }\r\n        else {\r\n            this.type = type;\r\n            yield* this.step();\r\n            switch (type) {\r\n                case 'newline':\r\n                    this.atNewLine = true;\r\n                    this.indent = 0;\r\n                    if (this.onNewLine)\r\n                        this.onNewLine(this.offset + source.length);\r\n                    break;\r\n                case 'space':\r\n                    if (this.atNewLine && source[0] === ' ')\r\n                        this.indent += source.length;\r\n                    break;\r\n                case 'explicit-key-ind':\r\n                case 'map-value-ind':\r\n                case 'seq-item-ind':\r\n                    if (this.atNewLine)\r\n                        this.indent += source.length;\r\n                    break;\r\n                case 'doc-mode':\r\n                    return;\r\n                default:\r\n                    this.atNewLine = false;\r\n            }\r\n            this.offset += source.length;\r\n        }\r\n    }\r\n    /** Call at end of input to push out any remaining constructions */\r\n    *end() {\r\n        while (this.stack.length > 0)\r\n            yield* this.pop();\r\n    }\r\n    get sourceToken() {\r\n        const st = {\r\n            type: this.type,\r\n            offset: this.offset,\r\n            indent: this.indent,\r\n            source: this.source\r\n        };\r\n        return st;\r\n    }\r\n    *step() {\r\n        const top = this.peek(1);\r\n        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\r\n            while (this.stack.length > 0)\r\n                yield* this.pop();\r\n            this.stack.push({\r\n                type: 'doc-end',\r\n                offset: this.offset,\r\n                source: this.source\r\n            });\r\n            return;\r\n        }\r\n        if (!top)\r\n            return yield* this.stream();\r\n        switch (top.type) {\r\n            case 'document':\r\n                return yield* this.document(top);\r\n            case 'alias':\r\n            case 'scalar':\r\n            case 'single-quoted-scalar':\r\n            case 'double-quoted-scalar':\r\n                return yield* this.scalar(top);\r\n            case 'block-scalar':\r\n                return yield* this.blockScalar(top);\r\n            case 'block-map':\r\n                return yield* this.blockMap(top);\r\n            case 'block-seq':\r\n                return yield* this.blockSequence(top);\r\n            case 'flow-collection':\r\n                return yield* this.flowCollection(top);\r\n            case 'doc-end':\r\n                return yield* this.documentEnd(top);\r\n        }\r\n        /* istanbul ignore next should not happen */\r\n        yield* this.pop();\r\n    }\r\n    peek(n) {\r\n        return this.stack[this.stack.length - n];\r\n    }\r\n    *pop(error) {\r\n        const token = error || this.stack.pop();\r\n        /* istanbul ignore if should not happen */\r\n        if (!token) {\r\n            const message = 'Tried to pop an empty stack';\r\n            yield { type: 'error', offset: this.offset, source: '', message };\r\n        }\r\n        else if (this.stack.length === 0) {\r\n            yield token;\r\n        }\r\n        else {\r\n            const top = this.peek(1);\r\n            // For these, parent indent is needed instead of own\r\n            if (token.type === 'block-scalar' || token.type === 'flow-collection')\r\n                token.indent = 'indent' in top ? top.indent : -1;\r\n            if (token.type === 'flow-collection')\r\n                fixFlowSeqItems(token);\r\n            switch (top.type) {\r\n                case 'document':\r\n                    top.value = token;\r\n                    break;\r\n                case 'block-scalar':\r\n                    top.props.push(token); // error\r\n                    break;\r\n                case 'block-map': {\r\n                    const it = top.items[top.items.length - 1];\r\n                    if (it.value) {\r\n                        top.items.push({ start: [], key: token, sep: [] });\r\n                        this.onKeyLine = true;\r\n                        return;\r\n                    }\r\n                    else if (it.sep) {\r\n                        it.value = token;\r\n                    }\r\n                    else {\r\n                        Object.assign(it, { key: token, sep: [] });\r\n                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');\r\n                        return;\r\n                    }\r\n                    break;\r\n                }\r\n                case 'block-seq': {\r\n                    const it = top.items[top.items.length - 1];\r\n                    if (it.value)\r\n                        top.items.push({ start: [], value: token });\r\n                    else\r\n                        it.value = token;\r\n                    break;\r\n                }\r\n                case 'flow-collection': {\r\n                    const it = top.items[top.items.length - 1];\r\n                    if (!it || it.value)\r\n                        top.items.push({ start: [], key: token, sep: [] });\r\n                    else if (it.sep)\r\n                        it.value = token;\r\n                    else\r\n                        Object.assign(it, { key: token, sep: [] });\r\n                    return;\r\n                }\r\n                /* istanbul ignore next should not happen */\r\n                default:\r\n                    yield* this.pop();\r\n                    yield* this.pop(token);\r\n            }\r\n            if ((top.type === 'document' ||\r\n                top.type === 'block-map' ||\r\n                top.type === 'block-seq') &&\r\n                (token.type === 'block-map' || token.type === 'block-seq')) {\r\n                const last = token.items[token.items.length - 1];\r\n                if (last &&\r\n                    !last.sep &&\r\n                    !last.value &&\r\n                    last.start.length > 0 &&\r\n                    !includesNonEmpty(last.start) &&\r\n                    (token.indent === 0 ||\r\n                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\r\n                    if (top.type === 'document')\r\n                        top.end = last.start;\r\n                    else\r\n                        top.items.push({ start: last.start });\r\n                    token.items.splice(-1, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    *stream() {\r\n        switch (this.type) {\r\n            case 'directive-line':\r\n                yield { type: 'directive', offset: this.offset, source: this.source };\r\n                return;\r\n            case 'byte-order-mark':\r\n            case 'space':\r\n            case 'comment':\r\n            case 'newline':\r\n                yield this.sourceToken;\r\n                return;\r\n            case 'doc-mode':\r\n            case 'doc-start': {\r\n                const doc = {\r\n                    type: 'document',\r\n                    offset: this.offset,\r\n                    start: []\r\n                };\r\n                if (this.type === 'doc-start')\r\n                    doc.start.push(this.sourceToken);\r\n                this.stack.push(doc);\r\n                return;\r\n            }\r\n        }\r\n        yield {\r\n            type: 'error',\r\n            offset: this.offset,\r\n            message: `Unexpected ${this.type} token in YAML stream`,\r\n            source: this.source\r\n        };\r\n    }\r\n    *document(doc) {\r\n        if (doc.value)\r\n            return yield* this.lineEnd(doc);\r\n        switch (this.type) {\r\n            case 'doc-start': {\r\n                if (includesNonEmpty(doc.start)) {\r\n                    yield* this.pop();\r\n                    yield* this.step();\r\n                }\r\n                else\r\n                    doc.start.push(this.sourceToken);\r\n                return;\r\n            }\r\n            case 'anchor':\r\n            case 'tag':\r\n            case 'space':\r\n            case 'comment':\r\n            case 'newline':\r\n                doc.start.push(this.sourceToken);\r\n                return;\r\n        }\r\n        const bv = this.startBlockValue(doc);\r\n        if (bv)\r\n            this.stack.push(bv);\r\n        else {\r\n            yield {\r\n                type: 'error',\r\n                offset: this.offset,\r\n                message: `Unexpected ${this.type} token in YAML document`,\r\n                source: this.source\r\n            };\r\n        }\r\n    }\r\n    *scalar(scalar) {\r\n        if (this.type === 'map-value-ind') {\r\n            const prev = getPrevProps(this.peek(2));\r\n            const start = getFirstKeyStartProps(prev);\r\n            let sep;\r\n            if (scalar.end) {\r\n                sep = scalar.end;\r\n                sep.push(this.sourceToken);\r\n                delete scalar.end;\r\n            }\r\n            else\r\n                sep = [this.sourceToken];\r\n            const map = {\r\n                type: 'block-map',\r\n                offset: scalar.offset,\r\n                indent: scalar.indent,\r\n                items: [{ start, key: scalar, sep }]\r\n            };\r\n            this.onKeyLine = true;\r\n            this.stack[this.stack.length - 1] = map;\r\n        }\r\n        else\r\n            yield* this.lineEnd(scalar);\r\n    }\r\n    *blockScalar(scalar) {\r\n        switch (this.type) {\r\n            case 'space':\r\n            case 'comment':\r\n            case 'newline':\r\n                scalar.props.push(this.sourceToken);\r\n                return;\r\n            case 'scalar':\r\n                scalar.source = this.source;\r\n                // block-scalar source includes trailing newline\r\n                this.atNewLine = true;\r\n                this.indent = 0;\r\n                if (this.onNewLine) {\r\n                    let nl = this.source.indexOf('\\n') + 1;\r\n                    while (nl !== 0) {\r\n                        this.onNewLine(this.offset + nl);\r\n                        nl = this.source.indexOf('\\n', nl) + 1;\r\n                    }\r\n                }\r\n                yield* this.pop();\r\n                break;\r\n            /* istanbul ignore next should not happen */\r\n            default:\r\n                yield* this.pop();\r\n                yield* this.step();\r\n        }\r\n    }\r\n    *blockMap(map) {\r\n        var _a;\r\n        const it = map.items[map.items.length - 1];\r\n        // it.sep is true-ish if pair already has key or : separator\r\n        switch (this.type) {\r\n            case 'newline':\r\n                this.onKeyLine = false;\r\n                if (it.value) {\r\n                    const end = 'end' in it.value ? it.value.end : undefined;\r\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\r\n                    if ((last === null || last === void 0 ? void 0 : last.type) === 'comment')\r\n                        end === null || end === void 0 ? void 0 : end.push(this.sourceToken);\r\n                    else\r\n                        map.items.push({ start: [this.sourceToken] });\r\n                }\r\n                else if (it.sep)\r\n                    it.sep.push(this.sourceToken);\r\n                else\r\n                    it.start.push(this.sourceToken);\r\n                return;\r\n            case 'space':\r\n            case 'comment':\r\n                if (it.value)\r\n                    map.items.push({ start: [this.sourceToken] });\r\n                else if (it.sep)\r\n                    it.sep.push(this.sourceToken);\r\n                else {\r\n                    if (this.atIndentedComment(it.start, map.indent)) {\r\n                        const prev = map.items[map.items.length - 2];\r\n                        const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;\r\n                        if (Array.isArray(end)) {\r\n                            Array.prototype.push.apply(end, it.start);\r\n                            end.push(this.sourceToken);\r\n                            map.items.pop();\r\n                            return;\r\n                        }\r\n                    }\r\n                    it.start.push(this.sourceToken);\r\n                }\r\n                return;\r\n        }\r\n        if (this.indent >= map.indent) {\r\n            const atNextItem = !this.onKeyLine &&\r\n                this.indent === map.indent &&\r\n                (it.sep || includesNonEmpty(it.start));\r\n            switch (this.type) {\r\n                case 'anchor':\r\n                case 'tag':\r\n                    if (atNextItem || it.value) {\r\n                        map.items.push({ start: [this.sourceToken] });\r\n                        this.onKeyLine = true;\r\n                    }\r\n                    else if (it.sep)\r\n                        it.sep.push(this.sourceToken);\r\n                    else\r\n                        it.start.push(this.sourceToken);\r\n                    return;\r\n                case 'explicit-key-ind':\r\n                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind'))\r\n                        it.start.push(this.sourceToken);\r\n                    else if (atNextItem || it.value)\r\n                        map.items.push({ start: [this.sourceToken] });\r\n                    else\r\n                        this.stack.push({\r\n                            type: 'block-map',\r\n                            offset: this.offset,\r\n                            indent: this.indent,\r\n                            items: [{ start: [this.sourceToken] }]\r\n                        });\r\n                    this.onKeyLine = true;\r\n                    return;\r\n                case 'map-value-ind':\r\n                    if (!it.sep)\r\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\r\n                    else if (it.value ||\r\n                        (atNextItem && !includesToken(it.start, 'explicit-key-ind')))\r\n                        map.items.push({ start: [], key: null, sep: [this.sourceToken] });\r\n                    else if (includesToken(it.sep, 'map-value-ind'))\r\n                        this.stack.push({\r\n                            type: 'block-map',\r\n                            offset: this.offset,\r\n                            indent: this.indent,\r\n                            items: [{ start: [], key: null, sep: [this.sourceToken] }]\r\n                        });\r\n                    else if (includesToken(it.start, 'explicit-key-ind') &&\r\n                        isFlowToken(it.key) &&\r\n                        !includesToken(it.sep, 'newline')) {\r\n                        const start = getFirstKeyStartProps(it.start);\r\n                        const key = it.key;\r\n                        const sep = it.sep;\r\n                        sep.push(this.sourceToken);\r\n                        // @ts-ignore type guard is wrong here\r\n                        delete it.key, delete it.sep;\r\n                        this.stack.push({\r\n                            type: 'block-map',\r\n                            offset: this.offset,\r\n                            indent: this.indent,\r\n                            items: [{ start, key, sep }]\r\n                        });\r\n                    }\r\n                    else\r\n                        it.sep.push(this.sourceToken);\r\n                    this.onKeyLine = true;\r\n                    return;\r\n                case 'alias':\r\n                case 'scalar':\r\n                case 'single-quoted-scalar':\r\n                case 'double-quoted-scalar': {\r\n                    const fs = this.flowScalar(this.type);\r\n                    if (atNextItem || it.value) {\r\n                        map.items.push({ start: [], key: fs, sep: [] });\r\n                        this.onKeyLine = true;\r\n                    }\r\n                    else if (it.sep) {\r\n                        this.stack.push(fs);\r\n                    }\r\n                    else {\r\n                        Object.assign(it, { key: fs, sep: [] });\r\n                        this.onKeyLine = true;\r\n                    }\r\n                    return;\r\n                }\r\n                default: {\r\n                    const bv = this.startBlockValue(map);\r\n                    if (bv) {\r\n                        if (atNextItem &&\r\n                            bv.type !== 'block-seq' &&\r\n                            includesToken(it.start, 'explicit-key-ind'))\r\n                            map.items.push({ start: [] });\r\n                        this.stack.push(bv);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        yield* this.pop();\r\n        yield* this.step();\r\n    }\r\n    *blockSequence(seq) {\r\n        var _a;\r\n        const it = seq.items[seq.items.length - 1];\r\n        switch (this.type) {\r\n            case 'newline':\r\n                if (it.value) {\r\n                    const end = 'end' in it.value ? it.value.end : undefined;\r\n                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;\r\n                    if ((last === null || last === void 0 ? void 0 : last.type) === 'comment')\r\n                        end === null || end === void 0 ? void 0 : end.push(this.sourceToken);\r\n                    else\r\n                        seq.items.push({ start: [this.sourceToken] });\r\n                }\r\n                else\r\n                    it.start.push(this.sourceToken);\r\n                return;\r\n            case 'space':\r\n            case 'comment':\r\n                if (it.value)\r\n                    seq.items.push({ start: [this.sourceToken] });\r\n                else {\r\n                    if (this.atIndentedComment(it.start, seq.indent)) {\r\n                        const prev = seq.items[seq.items.length - 2];\r\n                        const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;\r\n                        if (Array.isArray(end)) {\r\n                            Array.prototype.push.apply(end, it.start);\r\n                            end.push(this.sourceToken);\r\n                            seq.items.pop();\r\n                            return;\r\n                        }\r\n                    }\r\n                    it.start.push(this.sourceToken);\r\n                }\r\n                return;\r\n            case 'anchor':\r\n            case 'tag':\r\n                if (it.value || this.indent <= seq.indent)\r\n                    break;\r\n                it.start.push(this.sourceToken);\r\n                return;\r\n            case 'seq-item-ind':\r\n                if (this.indent !== seq.indent)\r\n                    break;\r\n                if (it.value || includesToken(it.start, 'seq-item-ind'))\r\n                    seq.items.push({ start: [this.sourceToken] });\r\n                else\r\n                    it.start.push(this.sourceToken);\r\n                return;\r\n        }\r\n        if (this.indent > seq.indent) {\r\n            const bv = this.startBlockValue(seq);\r\n            if (bv) {\r\n                this.stack.push(bv);\r\n                return;\r\n            }\r\n        }\r\n        yield* this.pop();\r\n        yield* this.step();\r\n    }\r\n    *flowCollection(fc) {\r\n        const it = fc.items[fc.items.length - 1];\r\n        if (this.type === 'flow-error-end') {\r\n            let top;\r\n            do {\r\n                yield* this.pop();\r\n                top = this.peek(1);\r\n            } while (top && top.type === 'flow-collection');\r\n        }\r\n        else if (fc.end.length === 0) {\r\n            switch (this.type) {\r\n                case 'comma':\r\n                case 'explicit-key-ind':\r\n                    if (!it || it.sep)\r\n                        fc.items.push({ start: [this.sourceToken] });\r\n                    else\r\n                        it.start.push(this.sourceToken);\r\n                    return;\r\n                case 'map-value-ind':\r\n                    if (!it || it.value)\r\n                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });\r\n                    else if (it.sep)\r\n                        it.sep.push(this.sourceToken);\r\n                    else\r\n                        Object.assign(it, { key: null, sep: [this.sourceToken] });\r\n                    return;\r\n                case 'space':\r\n                case 'comment':\r\n                case 'newline':\r\n                case 'anchor':\r\n                case 'tag':\r\n                    if (!it || it.value)\r\n                        fc.items.push({ start: [this.sourceToken] });\r\n                    else if (it.sep)\r\n                        it.sep.push(this.sourceToken);\r\n                    else\r\n                        it.start.push(this.sourceToken);\r\n                    return;\r\n                case 'alias':\r\n                case 'scalar':\r\n                case 'single-quoted-scalar':\r\n                case 'double-quoted-scalar': {\r\n                    const fs = this.flowScalar(this.type);\r\n                    if (!it || it.value)\r\n                        fc.items.push({ start: [], key: fs, sep: [] });\r\n                    else if (it.sep)\r\n                        this.stack.push(fs);\r\n                    else\r\n                        Object.assign(it, { key: fs, sep: [] });\r\n                    return;\r\n                }\r\n                case 'flow-map-end':\r\n                case 'flow-seq-end':\r\n                    fc.end.push(this.sourceToken);\r\n                    return;\r\n            }\r\n            const bv = this.startBlockValue(fc);\r\n            /* istanbul ignore else should not happen */\r\n            if (bv)\r\n                this.stack.push(bv);\r\n            else {\r\n                yield* this.pop();\r\n                yield* this.step();\r\n            }\r\n        }\r\n        else {\r\n            const parent = this.peek(2);\r\n            if (parent.type === 'block-map' &&\r\n                (this.type === 'map-value-ind' ||\r\n                    (this.type === 'newline' &&\r\n                        !parent.items[parent.items.length - 1].sep))) {\r\n                yield* this.pop();\r\n                yield* this.step();\r\n            }\r\n            else if (this.type === 'map-value-ind' &&\r\n                parent.type !== 'flow-collection') {\r\n                const prev = getPrevProps(parent);\r\n                const start = getFirstKeyStartProps(prev);\r\n                fixFlowSeqItems(fc);\r\n                const sep = fc.end.splice(1, fc.end.length);\r\n                sep.push(this.sourceToken);\r\n                const map = {\r\n                    type: 'block-map',\r\n                    offset: fc.offset,\r\n                    indent: fc.indent,\r\n                    items: [{ start, key: fc, sep }]\r\n                };\r\n                this.onKeyLine = true;\r\n                this.stack[this.stack.length - 1] = map;\r\n            }\r\n            else {\r\n                yield* this.lineEnd(fc);\r\n            }\r\n        }\r\n    }\r\n    flowScalar(type) {\r\n        if (this.onNewLine) {\r\n            let nl = this.source.indexOf('\\n') + 1;\r\n            while (nl !== 0) {\r\n                this.onNewLine(this.offset + nl);\r\n                nl = this.source.indexOf('\\n', nl) + 1;\r\n            }\r\n        }\r\n        return {\r\n            type,\r\n            offset: this.offset,\r\n            indent: this.indent,\r\n            source: this.source\r\n        };\r\n    }\r\n    startBlockValue(parent) {\r\n        switch (this.type) {\r\n            case 'alias':\r\n            case 'scalar':\r\n            case 'single-quoted-scalar':\r\n            case 'double-quoted-scalar':\r\n                return this.flowScalar(this.type);\r\n            case 'block-scalar-header':\r\n                return {\r\n                    type: 'block-scalar',\r\n                    offset: this.offset,\r\n                    indent: this.indent,\r\n                    props: [this.sourceToken],\r\n                    source: ''\r\n                };\r\n            case 'flow-map-start':\r\n            case 'flow-seq-start':\r\n                return {\r\n                    type: 'flow-collection',\r\n                    offset: this.offset,\r\n                    indent: this.indent,\r\n                    start: this.sourceToken,\r\n                    items: [],\r\n                    end: []\r\n                };\r\n            case 'seq-item-ind':\r\n                return {\r\n                    type: 'block-seq',\r\n                    offset: this.offset,\r\n                    indent: this.indent,\r\n                    items: [{ start: [this.sourceToken] }]\r\n                };\r\n            case 'explicit-key-ind': {\r\n                this.onKeyLine = true;\r\n                const prev = getPrevProps(parent);\r\n                const start = getFirstKeyStartProps(prev);\r\n                start.push(this.sourceToken);\r\n                return {\r\n                    type: 'block-map',\r\n                    offset: this.offset,\r\n                    indent: this.indent,\r\n                    items: [{ start }]\r\n                };\r\n            }\r\n            case 'map-value-ind': {\r\n                this.onKeyLine = true;\r\n                const prev = getPrevProps(parent);\r\n                const start = getFirstKeyStartProps(prev);\r\n                return {\r\n                    type: 'block-map',\r\n                    offset: this.offset,\r\n                    indent: this.indent,\r\n                    items: [{ start, key: null, sep: [this.sourceToken] }]\r\n                };\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    atIndentedComment(start, indent) {\r\n        if (this.type !== 'comment')\r\n            return false;\r\n        if (this.indent <= indent)\r\n            return false;\r\n        return start.every(st => st.type === 'newline' || st.type === 'space');\r\n    }\r\n    *documentEnd(docEnd) {\r\n        if (this.type !== 'doc-mode') {\r\n            if (docEnd.end)\r\n                docEnd.end.push(this.sourceToken);\r\n            else\r\n                docEnd.end = [this.sourceToken];\r\n            if (this.type === 'newline')\r\n                yield* this.pop();\r\n        }\r\n    }\r\n    *lineEnd(token) {\r\n        switch (this.type) {\r\n            case 'comma':\r\n            case 'doc-start':\r\n            case 'doc-end':\r\n            case 'flow-seq-end':\r\n            case 'flow-map-end':\r\n            case 'map-value-ind':\r\n                yield* this.pop();\r\n                yield* this.step();\r\n                break;\r\n            case 'newline':\r\n                this.onKeyLine = false;\r\n            // fallthrough\r\n            case 'space':\r\n            case 'comment':\r\n            default:\r\n                // all other values are errors\r\n                if (token.end)\r\n                    token.end.push(this.sourceToken);\r\n                else\r\n                    token.end = [this.sourceToken];\r\n                if (this.type === 'newline')\r\n                    yield* this.pop();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/parse/parser.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/public-api.js":
/*!******************************************************!*\
  !*** ./node_modules/yaml/browser/dist/public-api.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"parseAllDocuments\": () => (/* binding */ parseAllDocuments),\n/* harmony export */   \"parseDocument\": () => (/* binding */ parseDocument),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var _compose_composer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compose/composer.js */ \"./node_modules/yaml/browser/dist/compose/composer.js\");\n/* harmony import */ var _doc_Document_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./doc/Document.js */ \"./node_modules/yaml/browser/dist/doc/Document.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"./node_modules/yaml/browser/dist/errors.js\");\n/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./log.js */ \"./node_modules/yaml/browser/dist/log.js\");\n/* harmony import */ var _parse_line_counter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse/line-counter.js */ \"./node_modules/yaml/browser/dist/parse/line-counter.js\");\n/* harmony import */ var _parse_parser_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse/parser.js */ \"./node_modules/yaml/browser/dist/parse/parser.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction parseOptions(options) {\r\n    const prettyErrors = !options || options.prettyErrors !== false;\r\n    const lineCounter = (options && options.lineCounter) ||\r\n        (prettyErrors && new _parse_line_counter_js__WEBPACK_IMPORTED_MODULE_4__.LineCounter()) ||\r\n        null;\r\n    return { lineCounter, prettyErrors };\r\n}\r\n/**\r\n * Parse the input as a stream of YAML documents.\r\n *\r\n * Documents should be separated from each other by `...` or `---` marker lines.\r\n *\r\n * @returns If an empty `docs` array is returned, it will be of type\r\n *   EmptyStream and contain additional stream information. In\r\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\r\n */\r\nfunction parseAllDocuments(source, options = {}) {\r\n    const { lineCounter, prettyErrors } = parseOptions(options);\r\n    const parser = new _parse_parser_js__WEBPACK_IMPORTED_MODULE_5__.Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);\r\n    const composer = new _compose_composer_js__WEBPACK_IMPORTED_MODULE_0__.Composer(options);\r\n    const docs = Array.from(composer.compose(parser.parse(source)));\r\n    if (prettyErrors && lineCounter)\r\n        for (const doc of docs) {\r\n            doc.errors.forEach((0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.prettifyError)(source, lineCounter));\r\n            doc.warnings.forEach((0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.prettifyError)(source, lineCounter));\r\n        }\r\n    if (docs.length > 0)\r\n        return docs;\r\n    return Object.assign([], { empty: true }, composer.streamInfo());\r\n}\r\n/** Parse an input string into a single YAML.Document */\r\nfunction parseDocument(source, options = {}) {\r\n    const { lineCounter, prettyErrors } = parseOptions(options);\r\n    const parser = new _parse_parser_js__WEBPACK_IMPORTED_MODULE_5__.Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);\r\n    const composer = new _compose_composer_js__WEBPACK_IMPORTED_MODULE_0__.Composer(options);\r\n    // `doc` is always set by compose.end(true) at the very latest\r\n    let doc = null;\r\n    for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\r\n        if (!doc)\r\n            doc = _doc;\r\n        else if (doc.options.logLevel !== 'silent') {\r\n            doc.errors.push(new _errors_js__WEBPACK_IMPORTED_MODULE_2__.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\r\n            break;\r\n        }\r\n    }\r\n    if (prettyErrors && lineCounter) {\r\n        doc.errors.forEach((0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.prettifyError)(source, lineCounter));\r\n        doc.warnings.forEach((0,_errors_js__WEBPACK_IMPORTED_MODULE_2__.prettifyError)(source, lineCounter));\r\n    }\r\n    return doc;\r\n}\r\nfunction parse(src, reviver, options) {\r\n    let _reviver = undefined;\r\n    if (typeof reviver === 'function') {\r\n        _reviver = reviver;\r\n    }\r\n    else if (options === undefined && reviver && typeof reviver === 'object') {\r\n        options = reviver;\r\n    }\r\n    const doc = parseDocument(src, options);\r\n    if (!doc)\r\n        return null;\r\n    doc.warnings.forEach(warning => (0,_log_js__WEBPACK_IMPORTED_MODULE_3__.warn)(doc.options.logLevel, warning));\r\n    if (doc.errors.length > 0) {\r\n        if (doc.options.logLevel !== 'silent')\r\n            throw doc.errors[0];\r\n        else\r\n            doc.errors = [];\r\n    }\r\n    return doc.toJS(Object.assign({ reviver: _reviver }, options));\r\n}\r\nfunction stringify(value, replacer, options) {\r\n    let _replacer = null;\r\n    if (typeof replacer === 'function' || Array.isArray(replacer)) {\r\n        _replacer = replacer;\r\n    }\r\n    else if (options === undefined && replacer) {\r\n        options = replacer;\r\n    }\r\n    if (typeof options === 'string')\r\n        options = options.length;\r\n    if (typeof options === 'number') {\r\n        const indent = Math.round(options);\r\n        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };\r\n    }\r\n    if (value === undefined) {\r\n        const { keepUndefined } = options || replacer || {};\r\n        if (!keepUndefined)\r\n            return undefined;\r\n    }\r\n    return new _doc_Document_js__WEBPACK_IMPORTED_MODULE_1__.Document(value, _replacer, options).toString(options);\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/public-api.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/Schema.js":
/*!*********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/Schema.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Schema\": () => (/* binding */ Schema)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _common_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common/map.js */ \"./node_modules/yaml/browser/dist/schema/common/map.js\");\n/* harmony import */ var _common_seq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common/seq.js */ \"./node_modules/yaml/browser/dist/schema/common/seq.js\");\n/* harmony import */ var _common_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/string.js */ \"./node_modules/yaml/browser/dist/schema/common/string.js\");\n/* harmony import */ var _tags_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tags.js */ \"./node_modules/yaml/browser/dist/schema/tags.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nconst sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;\r\nclass Schema {\r\n    constructor({ customTags, merge, resolveKnownTags, schema, sortMapEntries }) {\r\n        this.merge = !!merge;\r\n        this.name = schema || 'core';\r\n        this.knownTags = resolveKnownTags ? _tags_js__WEBPACK_IMPORTED_MODULE_4__.coreKnownTags : {};\r\n        this.tags = (0,_tags_js__WEBPACK_IMPORTED_MODULE_4__.getTags)(customTags, this.name);\r\n        Object.defineProperty(this, _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.MAP, { value: _common_map_js__WEBPACK_IMPORTED_MODULE_1__.map });\r\n        Object.defineProperty(this, _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.SCALAR, { value: _common_string_js__WEBPACK_IMPORTED_MODULE_3__.string });\r\n        Object.defineProperty(this, _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.SEQ, { value: _common_seq_js__WEBPACK_IMPORTED_MODULE_2__.seq });\r\n        // Used by createMap()\r\n        this.sortMapEntries =\r\n            sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;\r\n    }\r\n    clone() {\r\n        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));\r\n        copy.tags = this.tags.slice();\r\n        return copy;\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/Schema.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/common/map.js":
/*!*************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/common/map.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"map\": () => (/* binding */ map)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../nodes/Pair.js */ \"./node_modules/yaml/browser/dist/nodes/Pair.js\");\n/* harmony import */ var _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../nodes/YAMLMap.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLMap.js\");\n\r\n\r\n\r\n\r\nfunction createMap(schema, obj, ctx) {\r\n    const { keepUndefined, replacer } = ctx;\r\n    const map = new _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__.YAMLMap(schema);\r\n    const add = (key, value) => {\r\n        if (typeof replacer === 'function')\r\n            value = replacer.call(obj, key, value);\r\n        else if (Array.isArray(replacer) && !replacer.includes(key))\r\n            return;\r\n        if (value !== undefined || keepUndefined)\r\n            map.items.push((0,_nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__.createPair)(key, value, ctx));\r\n    };\r\n    if (obj instanceof Map) {\r\n        for (const [key, value] of obj)\r\n            add(key, value);\r\n    }\r\n    else if (obj && typeof obj === 'object') {\r\n        for (const key of Object.keys(obj))\r\n            add(key, obj[key]);\r\n    }\r\n    if (typeof schema.sortMapEntries === 'function') {\r\n        map.items.sort(schema.sortMapEntries);\r\n    }\r\n    return map;\r\n}\r\nconst map = {\r\n    collection: 'map',\r\n    createNode: createMap,\r\n    default: true,\r\n    nodeClass: _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__.YAMLMap,\r\n    tag: 'tag:yaml.org,2002:map',\r\n    resolve(map, onError) {\r\n        if (!(0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isMap)(map))\r\n            onError('Expected a mapping for this tag');\r\n        return map;\r\n    }\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/common/map.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/common/null.js":
/*!**************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/common/null.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"nullTag\": () => (/* binding */ nullTag)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n\r\n\r\nconst nullTag = {\r\n    identify: value => value == null,\r\n    createNode: () => new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar(null),\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:null',\r\n    test: /^(?:~|[Nn]ull|NULL)?$/,\r\n    resolve: () => new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar(null),\r\n    stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/common/null.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/common/seq.js":
/*!*************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/common/seq.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"seq\": () => (/* binding */ seq)\n/* harmony export */ });\n/* harmony import */ var _doc_createNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../doc/createNode.js */ \"./node_modules/yaml/browser/dist/doc/createNode.js\");\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../nodes/YAMLSeq.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLSeq.js\");\n\r\n\r\n\r\n\r\nfunction createSeq(schema, obj, ctx) {\r\n    const { replacer } = ctx;\r\n    const seq = new _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_2__.YAMLSeq(schema);\r\n    if (obj && Symbol.iterator in Object(obj)) {\r\n        let i = 0;\r\n        for (let it of obj) {\r\n            if (typeof replacer === 'function') {\r\n                const key = obj instanceof Set ? it : String(i++);\r\n                it = replacer.call(obj, key, it);\r\n            }\r\n            seq.items.push((0,_doc_createNode_js__WEBPACK_IMPORTED_MODULE_0__.createNode)(it, undefined, ctx));\r\n        }\r\n    }\r\n    return seq;\r\n}\r\nconst seq = {\r\n    collection: 'seq',\r\n    createNode: createSeq,\r\n    default: true,\r\n    nodeClass: _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_2__.YAMLSeq,\r\n    tag: 'tag:yaml.org,2002:seq',\r\n    resolve(seq, onError) {\r\n        if (!(0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isSeq)(seq))\r\n            onError('Expected a sequence for this tag');\r\n        return seq;\r\n    }\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/common/seq.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/common/string.js":
/*!****************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/common/string.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"string\": () => (/* binding */ string)\n/* harmony export */ });\n/* harmony import */ var _stringify_stringifyString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stringify/stringifyString.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyString.js\");\n\r\n\r\nconst string = {\r\n    identify: value => typeof value === 'string',\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:str',\r\n    resolve: str => str,\r\n    stringify(item, ctx, onComment, onChompKeep) {\r\n        ctx = Object.assign({ actualString: true }, ctx);\r\n        return (0,_stringify_stringifyString_js__WEBPACK_IMPORTED_MODULE_0__.stringifyString)(item, ctx, onComment, onChompKeep);\r\n    }\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/common/string.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/core/bool.js":
/*!************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/core/bool.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"boolTag\": () => (/* binding */ boolTag)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n\r\n\r\nconst boolTag = {\r\n    identify: value => typeof value === 'boolean',\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:bool',\r\n    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,\r\n    resolve: str => new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar(str[0] === 't' || str[0] === 'T'),\r\n    stringify({ source, value }, ctx) {\r\n        if (source && boolTag.test.test(source)) {\r\n            const sv = source[0] === 't' || source[0] === 'T';\r\n            if (value === sv)\r\n                return source;\r\n        }\r\n        return value ? ctx.options.trueStr : ctx.options.falseStr;\r\n    }\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/core/bool.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/core/float.js":
/*!*************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/core/float.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"float\": () => (/* binding */ float),\n/* harmony export */   \"floatExp\": () => (/* binding */ floatExp),\n/* harmony export */   \"floatNaN\": () => (/* binding */ floatNaN)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyNumber.js\");\n\r\n\r\n\r\nconst floatNaN = {\r\n    identify: value => typeof value === 'number',\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:float',\r\n    test: /^(?:[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN))$/,\r\n    resolve: str => str.slice(-3).toLowerCase() === 'nan'\r\n        ? NaN\r\n        : str[0] === '-'\r\n            ? Number.NEGATIVE_INFINITY\r\n            : Number.POSITIVE_INFINITY,\r\n    stringify: _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_1__.stringifyNumber\r\n};\r\nconst floatExp = {\r\n    identify: value => typeof value === 'number',\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:float',\r\n    format: 'EXP',\r\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+(?:\\.[0-9]*)?)[eE][-+]?[0-9]+$/,\r\n    resolve: str => parseFloat(str),\r\n    stringify: ({ value }) => Number(value).toExponential()\r\n};\r\nconst float = {\r\n    identify: value => typeof value === 'number',\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:float',\r\n    test: /^[-+]?(?:\\.[0-9]+|[0-9]+\\.[0-9]*)$/,\r\n    resolve(str) {\r\n        const node = new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar(parseFloat(str));\r\n        const dot = str.indexOf('.');\r\n        if (dot !== -1 && str[str.length - 1] === '0')\r\n            node.minFractionDigits = str.length - dot - 1;\r\n        return node;\r\n    },\r\n    stringify: _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_1__.stringifyNumber\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/core/float.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/core/int.js":
/*!***********************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/core/int.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"int\": () => (/* binding */ int),\n/* harmony export */   \"intHex\": () => (/* binding */ intHex),\n/* harmony export */   \"intOct\": () => (/* binding */ intOct)\n/* harmony export */ });\n/* harmony import */ var _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyNumber.js\");\n\r\n\r\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\r\nconst intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));\r\nfunction intStringify(node, radix, prefix) {\r\n    const { value } = node;\r\n    if (intIdentify(value) && value >= 0)\r\n        return prefix + value.toString(radix);\r\n    return (0,_stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_0__.stringifyNumber)(node);\r\n}\r\nconst intOct = {\r\n    identify: value => intIdentify(value) && value >= 0,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:int',\r\n    format: 'OCT',\r\n    test: /^0o[0-7]+$/,\r\n    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),\r\n    stringify: node => intStringify(node, 8, '0o')\r\n};\r\nconst int = {\r\n    identify: intIdentify,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:int',\r\n    test: /^[-+]?[0-9]+$/,\r\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\r\n    stringify: _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_0__.stringifyNumber\r\n};\r\nconst intHex = {\r\n    identify: value => intIdentify(value) && value >= 0,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:int',\r\n    format: 'HEX',\r\n    test: /^0x[0-9a-fA-F]+$/,\r\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\r\n    stringify: node => intStringify(node, 16, '0x')\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/core/int.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/core/schema.js":
/*!**************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/core/schema.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"schema\": () => (/* binding */ schema)\n/* harmony export */ });\n/* harmony import */ var _common_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/map.js */ \"./node_modules/yaml/browser/dist/schema/common/map.js\");\n/* harmony import */ var _common_null_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/null.js */ \"./node_modules/yaml/browser/dist/schema/common/null.js\");\n/* harmony import */ var _common_seq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/seq.js */ \"./node_modules/yaml/browser/dist/schema/common/seq.js\");\n/* harmony import */ var _common_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/string.js */ \"./node_modules/yaml/browser/dist/schema/common/string.js\");\n/* harmony import */ var _bool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bool.js */ \"./node_modules/yaml/browser/dist/schema/core/bool.js\");\n/* harmony import */ var _float_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./float.js */ \"./node_modules/yaml/browser/dist/schema/core/float.js\");\n/* harmony import */ var _int_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./int.js */ \"./node_modules/yaml/browser/dist/schema/core/int.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst schema = [\r\n    _common_map_js__WEBPACK_IMPORTED_MODULE_0__.map,\r\n    _common_seq_js__WEBPACK_IMPORTED_MODULE_2__.seq,\r\n    _common_string_js__WEBPACK_IMPORTED_MODULE_3__.string,\r\n    _common_null_js__WEBPACK_IMPORTED_MODULE_1__.nullTag,\r\n    _bool_js__WEBPACK_IMPORTED_MODULE_4__.boolTag,\r\n    _int_js__WEBPACK_IMPORTED_MODULE_6__.intOct,\r\n    _int_js__WEBPACK_IMPORTED_MODULE_6__.int,\r\n    _int_js__WEBPACK_IMPORTED_MODULE_6__.intHex,\r\n    _float_js__WEBPACK_IMPORTED_MODULE_5__.floatNaN,\r\n    _float_js__WEBPACK_IMPORTED_MODULE_5__.floatExp,\r\n    _float_js__WEBPACK_IMPORTED_MODULE_5__.float\r\n];\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/core/schema.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/json/schema.js":
/*!**************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/json/schema.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"schema\": () => (/* binding */ schema)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _common_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/map.js */ \"./node_modules/yaml/browser/dist/schema/common/map.js\");\n/* harmony import */ var _common_seq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/seq.js */ \"./node_modules/yaml/browser/dist/schema/common/seq.js\");\n\r\n\r\n\r\n\r\nfunction intIdentify(value) {\r\n    return typeof value === 'bigint' || Number.isInteger(value);\r\n}\r\nconst stringifyJSON = ({ value }) => JSON.stringify(value);\r\nconst jsonScalars = [\r\n    {\r\n        identify: value => typeof value === 'string',\r\n        default: true,\r\n        tag: 'tag:yaml.org,2002:str',\r\n        resolve: str => str,\r\n        stringify: stringifyJSON\r\n    },\r\n    {\r\n        identify: value => value == null,\r\n        createNode: () => new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar(null),\r\n        default: true,\r\n        tag: 'tag:yaml.org,2002:null',\r\n        test: /^null$/,\r\n        resolve: () => null,\r\n        stringify: stringifyJSON\r\n    },\r\n    {\r\n        identify: value => typeof value === 'boolean',\r\n        default: true,\r\n        tag: 'tag:yaml.org,2002:bool',\r\n        test: /^true|false$/,\r\n        resolve: str => str === 'true',\r\n        stringify: stringifyJSON\r\n    },\r\n    {\r\n        identify: intIdentify,\r\n        default: true,\r\n        tag: 'tag:yaml.org,2002:int',\r\n        test: /^-?(?:0|[1-9][0-9]*)$/,\r\n        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),\r\n        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)\r\n    },\r\n    {\r\n        identify: value => typeof value === 'number',\r\n        default: true,\r\n        tag: 'tag:yaml.org,2002:float',\r\n        test: /^-?(?:0|[1-9][0-9]*)(?:\\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,\r\n        resolve: str => parseFloat(str),\r\n        stringify: stringifyJSON\r\n    }\r\n];\r\nconst jsonError = {\r\n    default: true,\r\n    tag: '',\r\n    test: /^/,\r\n    resolve(str, onError) {\r\n        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);\r\n        return str;\r\n    }\r\n};\r\nconst schema = [_common_map_js__WEBPACK_IMPORTED_MODULE_1__.map, _common_seq_js__WEBPACK_IMPORTED_MODULE_2__.seq].concat(jsonScalars, jsonError);\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/json/schema.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/tags.js":
/*!*******************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/tags.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"coreKnownTags\": () => (/* binding */ coreKnownTags),\n/* harmony export */   \"getTags\": () => (/* binding */ getTags)\n/* harmony export */ });\n/* harmony import */ var _common_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/map.js */ \"./node_modules/yaml/browser/dist/schema/common/map.js\");\n/* harmony import */ var _common_null_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common/null.js */ \"./node_modules/yaml/browser/dist/schema/common/null.js\");\n/* harmony import */ var _common_seq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./common/seq.js */ \"./node_modules/yaml/browser/dist/schema/common/seq.js\");\n/* harmony import */ var _common_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./common/string.js */ \"./node_modules/yaml/browser/dist/schema/common/string.js\");\n/* harmony import */ var _core_bool_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/bool.js */ \"./node_modules/yaml/browser/dist/schema/core/bool.js\");\n/* harmony import */ var _core_float_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/float.js */ \"./node_modules/yaml/browser/dist/schema/core/float.js\");\n/* harmony import */ var _core_int_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/int.js */ \"./node_modules/yaml/browser/dist/schema/core/int.js\");\n/* harmony import */ var _core_schema_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/schema.js */ \"./node_modules/yaml/browser/dist/schema/core/schema.js\");\n/* harmony import */ var _json_schema_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./json/schema.js */ \"./node_modules/yaml/browser/dist/schema/json/schema.js\");\n/* harmony import */ var _yaml_1_1_binary_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./yaml-1.1/binary.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js\");\n/* harmony import */ var _yaml_1_1_omap_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./yaml-1.1/omap.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js\");\n/* harmony import */ var _yaml_1_1_pairs_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./yaml-1.1/pairs.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js\");\n/* harmony import */ var _yaml_1_1_schema_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./yaml-1.1/schema.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js\");\n/* harmony import */ var _yaml_1_1_set_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./yaml-1.1/set.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/set.js\");\n/* harmony import */ var _yaml_1_1_timestamp_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./yaml-1.1/timestamp.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst schemas = {\r\n    core: _core_schema_js__WEBPACK_IMPORTED_MODULE_7__.schema,\r\n    failsafe: [_common_map_js__WEBPACK_IMPORTED_MODULE_0__.map, _common_seq_js__WEBPACK_IMPORTED_MODULE_2__.seq, _common_string_js__WEBPACK_IMPORTED_MODULE_3__.string],\r\n    json: _json_schema_js__WEBPACK_IMPORTED_MODULE_8__.schema,\r\n    yaml11: _yaml_1_1_schema_js__WEBPACK_IMPORTED_MODULE_12__.schema,\r\n    'yaml-1.1': _yaml_1_1_schema_js__WEBPACK_IMPORTED_MODULE_12__.schema\r\n};\r\nconst tagsByName = {\r\n    binary: _yaml_1_1_binary_js__WEBPACK_IMPORTED_MODULE_9__.binary,\r\n    bool: _core_bool_js__WEBPACK_IMPORTED_MODULE_4__.boolTag,\r\n    float: _core_float_js__WEBPACK_IMPORTED_MODULE_5__.float,\r\n    floatExp: _core_float_js__WEBPACK_IMPORTED_MODULE_5__.floatExp,\r\n    floatNaN: _core_float_js__WEBPACK_IMPORTED_MODULE_5__.floatNaN,\r\n    floatTime: _yaml_1_1_timestamp_js__WEBPACK_IMPORTED_MODULE_14__.floatTime,\r\n    int: _core_int_js__WEBPACK_IMPORTED_MODULE_6__.int,\r\n    intHex: _core_int_js__WEBPACK_IMPORTED_MODULE_6__.intHex,\r\n    intOct: _core_int_js__WEBPACK_IMPORTED_MODULE_6__.intOct,\r\n    intTime: _yaml_1_1_timestamp_js__WEBPACK_IMPORTED_MODULE_14__.intTime,\r\n    map: _common_map_js__WEBPACK_IMPORTED_MODULE_0__.map,\r\n    null: _common_null_js__WEBPACK_IMPORTED_MODULE_1__.nullTag,\r\n    omap: _yaml_1_1_omap_js__WEBPACK_IMPORTED_MODULE_10__.omap,\r\n    pairs: _yaml_1_1_pairs_js__WEBPACK_IMPORTED_MODULE_11__.pairs,\r\n    seq: _common_seq_js__WEBPACK_IMPORTED_MODULE_2__.seq,\r\n    set: _yaml_1_1_set_js__WEBPACK_IMPORTED_MODULE_13__.set,\r\n    timestamp: _yaml_1_1_timestamp_js__WEBPACK_IMPORTED_MODULE_14__.timestamp\r\n};\r\nconst coreKnownTags = {\r\n    'tag:yaml.org,2002:binary': _yaml_1_1_binary_js__WEBPACK_IMPORTED_MODULE_9__.binary,\r\n    'tag:yaml.org,2002:omap': _yaml_1_1_omap_js__WEBPACK_IMPORTED_MODULE_10__.omap,\r\n    'tag:yaml.org,2002:pairs': _yaml_1_1_pairs_js__WEBPACK_IMPORTED_MODULE_11__.pairs,\r\n    'tag:yaml.org,2002:set': _yaml_1_1_set_js__WEBPACK_IMPORTED_MODULE_13__.set,\r\n    'tag:yaml.org,2002:timestamp': _yaml_1_1_timestamp_js__WEBPACK_IMPORTED_MODULE_14__.timestamp\r\n};\r\nfunction getTags(customTags, schemaName) {\r\n    let tags = schemas[schemaName];\r\n    if (!tags) {\r\n        if (Array.isArray(customTags))\r\n            tags = [];\r\n        else {\r\n            const keys = Object.keys(schemas)\r\n                .filter(key => key !== 'yaml11')\r\n                .map(key => JSON.stringify(key))\r\n                .join(', ');\r\n            throw new Error(`Unknown schema \"${schemaName}\"; use one of ${keys} or define customTags array`);\r\n        }\r\n    }\r\n    if (Array.isArray(customTags)) {\r\n        for (const tag of customTags)\r\n            tags = tags.concat(tag);\r\n    }\r\n    else if (typeof customTags === 'function') {\r\n        tags = customTags(tags.slice());\r\n    }\r\n    return tags.map(tag => {\r\n        if (typeof tag !== 'string')\r\n            return tag;\r\n        const tagObj = tagsByName[tag];\r\n        if (tagObj)\r\n            return tagObj;\r\n        const keys = Object.keys(tagsByName)\r\n            .map(key => JSON.stringify(key))\r\n            .join(', ');\r\n        throw new Error(`Unknown custom tag \"${tag}\"; use one of ${keys}`);\r\n    });\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/tags.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js":
/*!******************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"binary\": () => (/* binding */ binary)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _stringify_stringifyString_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stringify/stringifyString.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyString.js\");\n\r\n\r\n\r\nconst binary = {\r\n    identify: value => value instanceof Uint8Array,\r\n    default: false,\r\n    tag: 'tag:yaml.org,2002:binary',\r\n    /**\r\n     * Returns a Buffer in node and an Uint8Array in browsers\r\n     *\r\n     * To use the resulting buffer as an image, you'll want to do something like:\r\n     *\r\n     *   const blob = new Blob([buffer], { type: 'image/jpeg' })\r\n     *   document.querySelector('#photo').src = URL.createObjectURL(blob)\r\n     */\r\n    resolve(src, onError) {\r\n        if (typeof Buffer === 'function') {\r\n            return Buffer.from(src, 'base64');\r\n        }\r\n        else if (typeof atob === 'function') {\r\n            // On IE 11, atob() can't handle newlines\r\n            const str = atob(src.replace(/[\\n\\r]/g, ''));\r\n            const buffer = new Uint8Array(str.length);\r\n            for (let i = 0; i < str.length; ++i)\r\n                buffer[i] = str.charCodeAt(i);\r\n            return buffer;\r\n        }\r\n        else {\r\n            onError('This environment does not support reading binary tags; either Buffer or atob is required');\r\n            return src;\r\n        }\r\n    },\r\n    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {\r\n        const buf = value; // checked earlier by binary.identify()\r\n        let str;\r\n        if (typeof Buffer === 'function') {\r\n            str =\r\n                buf instanceof Buffer\r\n                    ? buf.toString('base64')\r\n                    : Buffer.from(buf.buffer).toString('base64');\r\n        }\r\n        else if (typeof btoa === 'function') {\r\n            let s = '';\r\n            for (let i = 0; i < buf.length; ++i)\r\n                s += String.fromCharCode(buf[i]);\r\n            str = btoa(s);\r\n        }\r\n        else {\r\n            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');\r\n        }\r\n        if (!type)\r\n            type = _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.BLOCK_LITERAL;\r\n        if (type !== _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.QUOTE_DOUBLE) {\r\n            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);\r\n            const n = Math.ceil(str.length / lineWidth);\r\n            const lines = new Array(n);\r\n            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {\r\n                lines[i] = str.substr(o, lineWidth);\r\n            }\r\n            str = lines.join(type === _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.BLOCK_LITERAL ? '\\n' : ' ');\r\n        }\r\n        return (0,_stringify_stringifyString_js__WEBPACK_IMPORTED_MODULE_1__.stringifyString)({ comment, type, value: str }, ctx, onComment, onChompKeep);\r\n    }\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js":
/*!****************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"falseTag\": () => (/* binding */ falseTag),\n/* harmony export */   \"trueTag\": () => (/* binding */ trueTag)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n\r\n\r\nfunction boolStringify({ value, source }, ctx) {\r\n    const boolObj = value ? trueTag : falseTag;\r\n    if (source && boolObj.test.test(source))\r\n        return source;\r\n    return value ? ctx.options.trueStr : ctx.options.falseStr;\r\n}\r\nconst trueTag = {\r\n    identify: value => value === true,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:bool',\r\n    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,\r\n    resolve: () => new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar(true),\r\n    stringify: boolStringify\r\n};\r\nconst falseTag = {\r\n    identify: value => value === false,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:bool',\r\n    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,\r\n    resolve: () => new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar(false),\r\n    stringify: boolStringify\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/yaml-1.1/float.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/yaml-1.1/float.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"float\": () => (/* binding */ float),\n/* harmony export */   \"floatExp\": () => (/* binding */ floatExp),\n/* harmony export */   \"floatNaN\": () => (/* binding */ floatNaN)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyNumber.js\");\n\r\n\r\n\r\nconst floatNaN = {\r\n    identify: value => typeof value === 'number',\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:float',\r\n    test: /^[-+]?\\.(?:inf|Inf|INF|nan|NaN|NAN)$/,\r\n    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'\r\n        ? NaN\r\n        : str[0] === '-'\r\n            ? Number.NEGATIVE_INFINITY\r\n            : Number.POSITIVE_INFINITY,\r\n    stringify: _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_1__.stringifyNumber\r\n};\r\nconst floatExp = {\r\n    identify: value => typeof value === 'number',\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:float',\r\n    format: 'EXP',\r\n    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\\.[0-9_]*)?[eE][-+]?[0-9]+$/,\r\n    resolve: (str) => parseFloat(str.replace(/_/g, '')),\r\n    stringify: ({ value }) => Number(value).toExponential()\r\n};\r\nconst float = {\r\n    identify: value => typeof value === 'number',\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:float',\r\n    test: /^[-+]?(?:[0-9][0-9_]*)?\\.[0-9_]*$/,\r\n    resolve(str) {\r\n        const node = new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar(parseFloat(str.replace(/_/g, '')));\r\n        const dot = str.indexOf('.');\r\n        if (dot !== -1) {\r\n            const f = str.substring(dot + 1).replace(/_/g, '');\r\n            if (f[f.length - 1] === '0')\r\n                node.minFractionDigits = f.length;\r\n        }\r\n        return node;\r\n    },\r\n    stringify: _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_1__.stringifyNumber\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/yaml-1.1/float.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/yaml-1.1/int.js":
/*!***************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/yaml-1.1/int.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"int\": () => (/* binding */ int),\n/* harmony export */   \"intBin\": () => (/* binding */ intBin),\n/* harmony export */   \"intHex\": () => (/* binding */ intHex),\n/* harmony export */   \"intOct\": () => (/* binding */ intOct)\n/* harmony export */ });\n/* harmony import */ var _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyNumber.js\");\n\r\n\r\nconst intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);\r\nfunction intResolve(str, offset, radix, { intAsBigInt }) {\r\n    const sign = str[0];\r\n    if (sign === '-' || sign === '+')\r\n        offset += 1;\r\n    str = str.substring(offset).replace(/_/g, '');\r\n    if (intAsBigInt) {\r\n        switch (radix) {\r\n            case 2:\r\n                str = `0b${str}`;\r\n                break;\r\n            case 8:\r\n                str = `0o${str}`;\r\n                break;\r\n            case 16:\r\n                str = `0x${str}`;\r\n                break;\r\n        }\r\n        const n = BigInt(str);\r\n        return sign === '-' ? BigInt(-1) * n : n;\r\n    }\r\n    const n = parseInt(str, radix);\r\n    return sign === '-' ? -1 * n : n;\r\n}\r\nfunction intStringify(node, radix, prefix) {\r\n    const { value } = node;\r\n    if (intIdentify(value)) {\r\n        const str = value.toString(radix);\r\n        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;\r\n    }\r\n    return (0,_stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_0__.stringifyNumber)(node);\r\n}\r\nconst intBin = {\r\n    identify: intIdentify,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:int',\r\n    format: 'BIN',\r\n    test: /^[-+]?0b[0-1_]+$/,\r\n    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),\r\n    stringify: node => intStringify(node, 2, '0b')\r\n};\r\nconst intOct = {\r\n    identify: intIdentify,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:int',\r\n    format: 'OCT',\r\n    test: /^[-+]?0[0-7_]+$/,\r\n    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),\r\n    stringify: node => intStringify(node, 8, '0')\r\n};\r\nconst int = {\r\n    identify: intIdentify,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:int',\r\n    test: /^[-+]?[0-9][0-9_]*$/,\r\n    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),\r\n    stringify: _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_0__.stringifyNumber\r\n};\r\nconst intHex = {\r\n    identify: intIdentify,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:int',\r\n    format: 'HEX',\r\n    test: /^[-+]?0x[0-9a-fA-F_]+$/,\r\n    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),\r\n    stringify: node => intStringify(node, 16, '0x')\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/yaml-1.1/int.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js":
/*!****************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"YAMLOMap\": () => (/* binding */ YAMLOMap),\n/* harmony export */   \"omap\": () => (/* binding */ omap)\n/* harmony export */ });\n/* harmony import */ var _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/YAMLSeq.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLSeq.js\");\n/* harmony import */ var _nodes_toJS_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../nodes/toJS.js */ \"./node_modules/yaml/browser/dist/nodes/toJS.js\");\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../nodes/YAMLMap.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLMap.js\");\n/* harmony import */ var _pairs_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pairs.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nclass YAMLOMap extends _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_0__.YAMLSeq {\r\n    constructor() {\r\n        super();\r\n        this.add = _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_3__.YAMLMap.prototype.add.bind(this);\r\n        this.delete = _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_3__.YAMLMap.prototype[\"delete\"].bind(this);\r\n        this.get = _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_3__.YAMLMap.prototype.get.bind(this);\r\n        this.has = _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_3__.YAMLMap.prototype.has.bind(this);\r\n        this.set = _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_3__.YAMLMap.prototype.set.bind(this);\r\n        this.tag = YAMLOMap.tag;\r\n    }\r\n    /**\r\n     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,\r\n     * but TypeScript won't allow widening the signature of a child method.\r\n     */\r\n    toJSON(_, ctx) {\r\n        if (!ctx)\r\n            return super.toJSON(_);\r\n        const map = new Map();\r\n        if (ctx && ctx.onCreate)\r\n            ctx.onCreate(map);\r\n        for (const pair of this.items) {\r\n            let key, value;\r\n            if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isPair)(pair)) {\r\n                key = (0,_nodes_toJS_js__WEBPACK_IMPORTED_MODULE_1__.toJS)(pair.key, '', ctx);\r\n                value = (0,_nodes_toJS_js__WEBPACK_IMPORTED_MODULE_1__.toJS)(pair.value, key, ctx);\r\n            }\r\n            else {\r\n                key = (0,_nodes_toJS_js__WEBPACK_IMPORTED_MODULE_1__.toJS)(pair, '', ctx);\r\n            }\r\n            if (map.has(key))\r\n                throw new Error('Ordered maps must not include duplicate keys');\r\n            map.set(key, value);\r\n        }\r\n        return map;\r\n    }\r\n}\r\nYAMLOMap.tag = 'tag:yaml.org,2002:omap';\r\nconst omap = {\r\n    collection: 'seq',\r\n    identify: value => value instanceof Map,\r\n    nodeClass: YAMLOMap,\r\n    default: false,\r\n    tag: 'tag:yaml.org,2002:omap',\r\n    resolve(seq, onError) {\r\n        const pairs = (0,_pairs_js__WEBPACK_IMPORTED_MODULE_4__.resolvePairs)(seq, onError);\r\n        const seenKeys = [];\r\n        for (const { key } of pairs.items) {\r\n            if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_2__.isScalar)(key)) {\r\n                if (seenKeys.includes(key.value)) {\r\n                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);\r\n                }\r\n                else {\r\n                    seenKeys.push(key.value);\r\n                }\r\n            }\r\n        }\r\n        return Object.assign(new YAMLOMap(), pairs);\r\n    },\r\n    createNode(schema, iterable, ctx) {\r\n        const pairs = (0,_pairs_js__WEBPACK_IMPORTED_MODULE_4__.createPairs)(schema, iterable, ctx);\r\n        const omap = new YAMLOMap();\r\n        omap.items = pairs.items;\r\n        return omap;\r\n    }\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js":
/*!*****************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createPairs\": () => (/* binding */ createPairs),\n/* harmony export */   \"pairs\": () => (/* binding */ pairs),\n/* harmony export */   \"resolvePairs\": () => (/* binding */ resolvePairs)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../nodes/Pair.js */ \"./node_modules/yaml/browser/dist/nodes/Pair.js\");\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../nodes/YAMLSeq.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLSeq.js\");\n\r\n\r\n\r\n\r\n\r\nfunction resolvePairs(seq, onError) {\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isSeq)(seq)) {\r\n        for (let i = 0; i < seq.items.length; ++i) {\r\n            let item = seq.items[i];\r\n            if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isPair)(item))\r\n                continue;\r\n            else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isMap)(item)) {\r\n                if (item.items.length > 1)\r\n                    onError('Each pair must have its own sequence indicator');\r\n                const pair = item.items[0] || new _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__.Pair(new _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_2__.Scalar(null));\r\n                if (item.commentBefore)\r\n                    pair.key.commentBefore = pair.key.commentBefore\r\n                        ? `${item.commentBefore}\\n${pair.key.commentBefore}`\r\n                        : item.commentBefore;\r\n                if (item.comment) {\r\n                    const cn = pair.value || pair.key;\r\n                    cn.comment = cn.comment\r\n                        ? `${item.comment}\\n${cn.comment}`\r\n                        : item.comment;\r\n                }\r\n                item = pair;\r\n            }\r\n            seq.items[i] = (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isPair)(item) ? item : new _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__.Pair(item);\r\n        }\r\n    }\r\n    else\r\n        onError('Expected a sequence for this tag');\r\n    return seq;\r\n}\r\nfunction createPairs(schema, iterable, ctx) {\r\n    const { replacer } = ctx;\r\n    const pairs = new _nodes_YAMLSeq_js__WEBPACK_IMPORTED_MODULE_3__.YAMLSeq(schema);\r\n    pairs.tag = 'tag:yaml.org,2002:pairs';\r\n    let i = 0;\r\n    if (iterable && Symbol.iterator in Object(iterable))\r\n        for (let it of iterable) {\r\n            if (typeof replacer === 'function')\r\n                it = replacer.call(iterable, String(i++), it);\r\n            let key, value;\r\n            if (Array.isArray(it)) {\r\n                if (it.length === 2) {\r\n                    key = it[0];\r\n                    value = it[1];\r\n                }\r\n                else\r\n                    throw new TypeError(`Expected [key, value] tuple: ${it}`);\r\n            }\r\n            else if (it && it instanceof Object) {\r\n                const keys = Object.keys(it);\r\n                if (keys.length === 1) {\r\n                    key = keys[0];\r\n                    value = it[key];\r\n                }\r\n                else\r\n                    throw new TypeError(`Expected { key: value } tuple: ${it}`);\r\n            }\r\n            else {\r\n                key = it;\r\n            }\r\n            pairs.items.push((0,_nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__.createPair)(key, value, ctx));\r\n        }\r\n    return pairs;\r\n}\r\nconst pairs = {\r\n    collection: 'seq',\r\n    default: false,\r\n    tag: 'tag:yaml.org,2002:pairs',\r\n    resolve: resolvePairs,\r\n    createNode: createPairs\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js":
/*!******************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"schema\": () => (/* binding */ schema)\n/* harmony export */ });\n/* harmony import */ var _common_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/map.js */ \"./node_modules/yaml/browser/dist/schema/common/map.js\");\n/* harmony import */ var _common_null_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/null.js */ \"./node_modules/yaml/browser/dist/schema/common/null.js\");\n/* harmony import */ var _common_seq_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/seq.js */ \"./node_modules/yaml/browser/dist/schema/common/seq.js\");\n/* harmony import */ var _common_string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/string.js */ \"./node_modules/yaml/browser/dist/schema/common/string.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./binary.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js\");\n/* harmony import */ var _bool_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./bool.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js\");\n/* harmony import */ var _float_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./float.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/float.js\");\n/* harmony import */ var _int_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./int.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/int.js\");\n/* harmony import */ var _omap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./omap.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js\");\n/* harmony import */ var _pairs_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pairs.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js\");\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./set.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/set.js\");\n/* harmony import */ var _timestamp_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./timestamp.js */ \"./node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst schema = [\r\n    _common_map_js__WEBPACK_IMPORTED_MODULE_0__.map,\r\n    _common_seq_js__WEBPACK_IMPORTED_MODULE_2__.seq,\r\n    _common_string_js__WEBPACK_IMPORTED_MODULE_3__.string,\r\n    _common_null_js__WEBPACK_IMPORTED_MODULE_1__.nullTag,\r\n    _bool_js__WEBPACK_IMPORTED_MODULE_5__.trueTag,\r\n    _bool_js__WEBPACK_IMPORTED_MODULE_5__.falseTag,\r\n    _int_js__WEBPACK_IMPORTED_MODULE_7__.intBin,\r\n    _int_js__WEBPACK_IMPORTED_MODULE_7__.intOct,\r\n    _int_js__WEBPACK_IMPORTED_MODULE_7__.int,\r\n    _int_js__WEBPACK_IMPORTED_MODULE_7__.intHex,\r\n    _float_js__WEBPACK_IMPORTED_MODULE_6__.floatNaN,\r\n    _float_js__WEBPACK_IMPORTED_MODULE_6__.floatExp,\r\n    _float_js__WEBPACK_IMPORTED_MODULE_6__.float,\r\n    _binary_js__WEBPACK_IMPORTED_MODULE_4__.binary,\r\n    _omap_js__WEBPACK_IMPORTED_MODULE_8__.omap,\r\n    _pairs_js__WEBPACK_IMPORTED_MODULE_9__.pairs,\r\n    _set_js__WEBPACK_IMPORTED_MODULE_10__.set,\r\n    _timestamp_js__WEBPACK_IMPORTED_MODULE_11__.intTime,\r\n    _timestamp_js__WEBPACK_IMPORTED_MODULE_11__.floatTime,\r\n    _timestamp_js__WEBPACK_IMPORTED_MODULE_11__.timestamp\r\n];\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/yaml-1.1/set.js":
/*!***************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/yaml-1.1/set.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"YAMLSet\": () => (/* binding */ YAMLSet),\n/* harmony export */   \"set\": () => (/* binding */ set)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../nodes/Pair.js */ \"./node_modules/yaml/browser/dist/nodes/Pair.js\");\n/* harmony import */ var _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../nodes/YAMLMap.js */ \"./node_modules/yaml/browser/dist/nodes/YAMLMap.js\");\n\r\n\r\n\r\n\r\nclass YAMLSet extends _nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__.YAMLMap {\r\n    constructor(schema) {\r\n        super(schema);\r\n        this.tag = YAMLSet.tag;\r\n    }\r\n    add(key) {\r\n        let pair;\r\n        if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isPair)(key))\r\n            pair = key;\r\n        else if (typeof key === 'object' &&\r\n            'key' in key &&\r\n            'value' in key &&\r\n            key.value === null)\r\n            pair = new _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__.Pair(key.key, null);\r\n        else\r\n            pair = new _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__.Pair(key, null);\r\n        const prev = (0,_nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__.findPair)(this.items, pair.key);\r\n        if (!prev)\r\n            this.items.push(pair);\r\n    }\r\n    get(key, keepPair) {\r\n        const pair = (0,_nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__.findPair)(this.items, key);\r\n        return !keepPair && (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isPair)(pair)\r\n            ? (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isScalar)(pair.key)\r\n                ? pair.key.value\r\n                : pair.key\r\n            : pair;\r\n    }\r\n    set(key, value) {\r\n        if (typeof value !== 'boolean')\r\n            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);\r\n        const prev = (0,_nodes_YAMLMap_js__WEBPACK_IMPORTED_MODULE_2__.findPair)(this.items, key);\r\n        if (prev && !value) {\r\n            this.items.splice(this.items.indexOf(prev), 1);\r\n        }\r\n        else if (!prev && value) {\r\n            this.items.push(new _nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__.Pair(key));\r\n        }\r\n    }\r\n    toJSON(_, ctx) {\r\n        return super.toJSON(_, ctx, Set);\r\n    }\r\n    toString(ctx, onComment, onChompKeep) {\r\n        if (!ctx)\r\n            return JSON.stringify(this);\r\n        if (this.hasAllNullValues(true))\r\n            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);\r\n        else\r\n            throw new Error('Set items must all have null values');\r\n    }\r\n}\r\nYAMLSet.tag = 'tag:yaml.org,2002:set';\r\nconst set = {\r\n    collection: 'map',\r\n    identify: value => value instanceof Set,\r\n    nodeClass: YAMLSet,\r\n    default: false,\r\n    tag: 'tag:yaml.org,2002:set',\r\n    resolve(map, onError) {\r\n        if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isMap)(map)) {\r\n            if (map.hasAllNullValues(true))\r\n                return Object.assign(new YAMLSet(), map);\r\n            else\r\n                onError('Set items must all have null values');\r\n        }\r\n        else\r\n            onError('Expected a mapping for this tag');\r\n        return map;\r\n    },\r\n    createNode(schema, iterable, ctx) {\r\n        const { replacer } = ctx;\r\n        const set = new YAMLSet(schema);\r\n        if (iterable && Symbol.iterator in Object(iterable))\r\n            for (let value of iterable) {\r\n                if (typeof replacer === 'function')\r\n                    value = replacer.call(iterable, value, value);\r\n                set.items.push((0,_nodes_Pair_js__WEBPACK_IMPORTED_MODULE_1__.createPair)(value, null, ctx));\r\n            }\r\n        return set;\r\n    }\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/yaml-1.1/set.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"floatTime\": () => (/* binding */ floatTime),\n/* harmony export */   \"intTime\": () => (/* binding */ intTime),\n/* harmony export */   \"timestamp\": () => (/* binding */ timestamp)\n/* harmony export */ });\n/* harmony import */ var _stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../stringify/stringifyNumber.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyNumber.js\");\n\r\n\r\n/** Internal types handle bigint as number, because TS can't figure it out. */\r\nfunction parseSexagesimal(str, asBigInt) {\r\n    const sign = str[0];\r\n    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;\r\n    const num = (n) => asBigInt ? BigInt(n) : Number(n);\r\n    const res = parts\r\n        .replace(/_/g, '')\r\n        .split(':')\r\n        .reduce((res, p) => res * num(60) + num(p), num(0));\r\n    return (sign === '-' ? num(-1) * res : res);\r\n}\r\n/**\r\n * hhhh:mm:ss.sss\r\n *\r\n * Internal types handle bigint as number, because TS can't figure it out.\r\n */\r\nfunction stringifySexagesimal(node) {\r\n    let { value } = node;\r\n    let num = (n) => n;\r\n    if (typeof value === 'bigint')\r\n        num = n => BigInt(n);\r\n    else if (isNaN(value) || !isFinite(value))\r\n        return (0,_stringify_stringifyNumber_js__WEBPACK_IMPORTED_MODULE_0__.stringifyNumber)(node);\r\n    let sign = '';\r\n    if (value < 0) {\r\n        sign = '-';\r\n        value *= num(-1);\r\n    }\r\n    const _60 = num(60);\r\n    const parts = [value % _60]; // seconds, including ms\r\n    if (value < 60) {\r\n        parts.unshift(0); // at least one : is required\r\n    }\r\n    else {\r\n        value = (value - parts[0]) / _60;\r\n        parts.unshift(value % _60); // minutes\r\n        if (value >= 60) {\r\n            value = (value - parts[0]) / _60;\r\n            parts.unshift(value); // hours\r\n        }\r\n    }\r\n    return (sign +\r\n        parts\r\n            .map(n => (n < 10 ? '0' + String(n) : String(n)))\r\n            .join(':')\r\n            .replace(/000000\\d*$/, '') // % 60 may introduce error\r\n    );\r\n}\r\nconst intTime = {\r\n    identify: value => typeof value === 'bigint' || Number.isInteger(value),\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:int',\r\n    format: 'TIME',\r\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,\r\n    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),\r\n    stringify: stringifySexagesimal\r\n};\r\nconst floatTime = {\r\n    identify: value => typeof value === 'number',\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:float',\r\n    format: 'TIME',\r\n    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*$/,\r\n    resolve: str => parseSexagesimal(str, false),\r\n    stringify: stringifySexagesimal\r\n};\r\nconst timestamp = {\r\n    identify: value => value instanceof Date,\r\n    default: true,\r\n    tag: 'tag:yaml.org,2002:timestamp',\r\n    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part\r\n    // may be omitted altogether, resulting in a date format. In such a case, the time part is\r\n    // assumed to be 00:00:00Z (start of day, UTC).\r\n    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd\r\n        '(?:' + // time is optional\r\n        '(?:t|T|[ \\\\t]+)' + // t | T | whitespace\r\n        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?\r\n        '(?:[ \\\\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30\r\n        ')?$'),\r\n    resolve(str) {\r\n        const match = str.match(timestamp.test);\r\n        if (!match)\r\n            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');\r\n        const [, year, month, day, hour, minute, second] = match.map(Number);\r\n        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;\r\n        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);\r\n        const tz = match[8];\r\n        if (tz && tz !== 'Z') {\r\n            let d = parseSexagesimal(tz, false);\r\n            if (Math.abs(d) < 30)\r\n                d *= 60;\r\n            date -= 60000 * d;\r\n        }\r\n        return new Date(date);\r\n    },\r\n    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\\.000Z$/, '')\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/stringify/foldFlowLines.js":
/*!*******************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/stringify/foldFlowLines.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FOLD_BLOCK\": () => (/* binding */ FOLD_BLOCK),\n/* harmony export */   \"FOLD_FLOW\": () => (/* binding */ FOLD_FLOW),\n/* harmony export */   \"FOLD_QUOTED\": () => (/* binding */ FOLD_QUOTED),\n/* harmony export */   \"foldFlowLines\": () => (/* binding */ foldFlowLines)\n/* harmony export */ });\nconst FOLD_FLOW = 'flow';\r\nconst FOLD_BLOCK = 'block';\r\nconst FOLD_QUOTED = 'quoted';\r\n/**\r\n * Tries to keep input at up to `lineWidth` characters, splitting only on spaces\r\n * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are\r\n * terminated with `\\n` and started with `indent`.\r\n */\r\nfunction foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {\r\n    if (!lineWidth || lineWidth < 0)\r\n        return text;\r\n    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);\r\n    if (text.length <= endStep)\r\n        return text;\r\n    const folds = [];\r\n    const escapedFolds = {};\r\n    let end = lineWidth - indent.length;\r\n    if (typeof indentAtStart === 'number') {\r\n        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))\r\n            folds.push(0);\r\n        else\r\n            end = lineWidth - indentAtStart;\r\n    }\r\n    let split = undefined;\r\n    let prev = undefined;\r\n    let overflow = false;\r\n    let i = -1;\r\n    let escStart = -1;\r\n    let escEnd = -1;\r\n    if (mode === FOLD_BLOCK) {\r\n        i = consumeMoreIndentedLines(text, i);\r\n        if (i !== -1)\r\n            end = i + endStep;\r\n    }\r\n    for (let ch; (ch = text[(i += 1)]);) {\r\n        if (mode === FOLD_QUOTED && ch === '\\\\') {\r\n            escStart = i;\r\n            switch (text[i + 1]) {\r\n                case 'x':\r\n                    i += 3;\r\n                    break;\r\n                case 'u':\r\n                    i += 5;\r\n                    break;\r\n                case 'U':\r\n                    i += 9;\r\n                    break;\r\n                default:\r\n                    i += 1;\r\n            }\r\n            escEnd = i;\r\n        }\r\n        if (ch === '\\n') {\r\n            if (mode === FOLD_BLOCK)\r\n                i = consumeMoreIndentedLines(text, i);\r\n            end = i + endStep;\r\n            split = undefined;\r\n        }\r\n        else {\r\n            if (ch === ' ' &&\r\n                prev &&\r\n                prev !== ' ' &&\r\n                prev !== '\\n' &&\r\n                prev !== '\\t') {\r\n                // space surrounded by non-space can be replaced with newline + indent\r\n                const next = text[i + 1];\r\n                if (next && next !== ' ' && next !== '\\n' && next !== '\\t')\r\n                    split = i;\r\n            }\r\n            if (i >= end) {\r\n                if (split) {\r\n                    folds.push(split);\r\n                    end = split + endStep;\r\n                    split = undefined;\r\n                }\r\n                else if (mode === FOLD_QUOTED) {\r\n                    // white-space collected at end may stretch past lineWidth\r\n                    while (prev === ' ' || prev === '\\t') {\r\n                        prev = ch;\r\n                        ch = text[(i += 1)];\r\n                        overflow = true;\r\n                    }\r\n                    // Account for newline escape, but don't break preceding escape\r\n                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;\r\n                    // Bail out if lineWidth & minContentWidth are shorter than an escape string\r\n                    if (escapedFolds[j])\r\n                        return text;\r\n                    folds.push(j);\r\n                    escapedFolds[j] = true;\r\n                    end = j + endStep;\r\n                    split = undefined;\r\n                }\r\n                else {\r\n                    overflow = true;\r\n                }\r\n            }\r\n        }\r\n        prev = ch;\r\n    }\r\n    if (overflow && onOverflow)\r\n        onOverflow();\r\n    if (folds.length === 0)\r\n        return text;\r\n    if (onFold)\r\n        onFold();\r\n    let res = text.slice(0, folds[0]);\r\n    for (let i = 0; i < folds.length; ++i) {\r\n        const fold = folds[i];\r\n        const end = folds[i + 1] || text.length;\r\n        if (fold === 0)\r\n            res = `\\n${indent}${text.slice(0, end)}`;\r\n        else {\r\n            if (mode === FOLD_QUOTED && escapedFolds[fold])\r\n                res += `${text[fold]}\\\\`;\r\n            res += `\\n${indent}${text.slice(fold + 1, end)}`;\r\n        }\r\n    }\r\n    return res;\r\n}\r\n/**\r\n * Presumes `i + 1` is at the start of a line\r\n * @returns index of last newline in more-indented block\r\n */\r\nfunction consumeMoreIndentedLines(text, i) {\r\n    let ch = text[i + 1];\r\n    while (ch === ' ' || ch === '\\t') {\r\n        do {\r\n            ch = text[(i += 1)];\r\n        } while (ch && ch !== '\\n');\r\n        ch = text[i + 1];\r\n    }\r\n    return i;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/stringify/foldFlowLines.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/stringify/stringify.js":
/*!***************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/stringify/stringify.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createStringifyContext\": () => (/* binding */ createStringifyContext),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify)\n/* harmony export */ });\n/* harmony import */ var _doc_anchors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../doc/anchors.js */ \"./node_modules/yaml/browser/dist/doc/anchors.js\");\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _stringifyString_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringifyString.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyString.js\");\n\r\n\r\n\r\n\r\nconst createStringifyContext = (doc, options) => ({\r\n    anchors: new Set(),\r\n    doc,\r\n    indent: '',\r\n    indentStep: typeof options.indent === 'number' ? ' '.repeat(options.indent) : '  ',\r\n    options: Object.assign({\r\n        blockQuote: true,\r\n        defaultKeyType: null,\r\n        defaultStringType: 'PLAIN',\r\n        directives: null,\r\n        doubleQuotedAsJSON: false,\r\n        doubleQuotedMinMultiLineLength: 40,\r\n        falseStr: 'false',\r\n        indentSeq: true,\r\n        lineWidth: 80,\r\n        minContentWidth: 20,\r\n        nullStr: 'null',\r\n        simpleKeys: false,\r\n        singleQuote: null,\r\n        trueStr: 'true',\r\n        verifyAliasOrder: true\r\n    }, options)\r\n});\r\nfunction getTagObject(tags, item) {\r\n    if (item.tag) {\r\n        const match = tags.filter(t => t.tag === item.tag);\r\n        if (match.length > 0)\r\n            return match.find(t => t.format === item.format) || match[0];\r\n    }\r\n    let tagObj = undefined;\r\n    let obj;\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isScalar)(item)) {\r\n        obj = item.value;\r\n        const match = tags.filter(t => t.identify && t.identify(obj));\r\n        tagObj =\r\n            match.find(t => t.format === item.format) || match.find(t => !t.format);\r\n    }\r\n    else {\r\n        obj = item;\r\n        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);\r\n    }\r\n    if (!tagObj) {\r\n        // @ts-ignore\r\n        const name = obj && obj.constructor ? obj.constructor.name : typeof obj;\r\n        throw new Error(`Tag not resolved for ${name} value`);\r\n    }\r\n    return tagObj;\r\n}\r\n// needs to be called before value stringifier to allow for circular anchor refs\r\nfunction stringifyProps(node, tagObj, { anchors, doc }) {\r\n    const props = [];\r\n    const anchor = ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isScalar)(node) || (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isCollection)(node)) && node.anchor;\r\n    if (anchor && (0,_doc_anchors_js__WEBPACK_IMPORTED_MODULE_0__.anchorIsValid)(anchor)) {\r\n        anchors.add(anchor);\r\n        props.push(`&${anchor}`);\r\n    }\r\n    if (node.tag) {\r\n        props.push(doc.directives.tagString(node.tag));\r\n    }\r\n    else if (!tagObj.default) {\r\n        props.push(doc.directives.tagString(tagObj.tag));\r\n    }\r\n    return props.join(' ');\r\n}\r\nfunction stringify(item, ctx, onComment, onChompKeep) {\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isPair)(item))\r\n        return item.toString(ctx, onComment, onChompKeep);\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isAlias)(item))\r\n        return item.toString(ctx);\r\n    let tagObj = undefined;\r\n    const node = (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isNode)(item)\r\n        ? item\r\n        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });\r\n    if (!tagObj)\r\n        tagObj = getTagObject(ctx.doc.schema.tags, node);\r\n    const props = stringifyProps(node, tagObj, ctx);\r\n    if (props.length > 0)\r\n        ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\r\n    const str = typeof tagObj.stringify === 'function'\r\n        ? tagObj.stringify(node, ctx, onComment, onChompKeep)\r\n        : (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isScalar)(node)\r\n            ? (0,_stringifyString_js__WEBPACK_IMPORTED_MODULE_2__.stringifyString)(node, ctx, onComment, onChompKeep)\r\n            : node.toString(ctx, onComment, onChompKeep);\r\n    if (!props)\r\n        return str;\r\n    return (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isScalar)(node) || str[0] === '{' || str[0] === '['\r\n        ? `${props} ${str}`\r\n        : `${props}\\n${ctx.indent}${str}`;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/stringify/stringify.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/stringify/stringifyCollection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/stringify/stringifyCollection.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stringifyCollection\": () => (/* binding */ stringifyCollection)\n/* harmony export */ });\n/* harmony import */ var _nodes_Collection_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Collection.js */ \"./node_modules/yaml/browser/dist/nodes/Collection.js\");\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/yaml/browser/dist/stringify/stringify.js\");\n/* harmony import */ var _stringifyComment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringifyComment.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyComment.js\");\n\r\n\r\n\r\n\r\n\r\nfunction stringifyCollection({ comment, flow, items }, ctx, { blockItem, flowChars, itemIndent, onChompKeep, onComment }) {\r\n    const { indent, indentStep } = ctx;\r\n    const inFlow = flow || ctx.inFlow;\r\n    if (inFlow)\r\n        itemIndent += indentStep;\r\n    ctx = Object.assign({}, ctx, { indent: itemIndent, inFlow, type: null });\r\n    let singleLineOutput = true;\r\n    let chompKeep = false; // flag for the preceding node's status\r\n    const nodes = items.reduce((nodes, item, i) => {\r\n        let comment = null;\r\n        if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isNode)(item)) {\r\n            if (!chompKeep && item.spaceBefore)\r\n                nodes.push({ comment: true, str: '' });\r\n            let cb = item.commentBefore;\r\n            if (cb && chompKeep)\r\n                cb = cb.replace(/^\\n+/, '');\r\n            if (cb) {\r\n                if (/^\\n+$/.test(cb))\r\n                    cb = cb.substring(1);\r\n                // This match will always succeed on a non-empty string\r\n                for (const line of cb.match(/^.*$/gm)) {\r\n                    const str = line === ' ' ? '#' : line ? `#${line}` : '';\r\n                    nodes.push({ comment: true, str });\r\n                }\r\n            }\r\n            if (item.comment) {\r\n                comment = item.comment;\r\n                singleLineOutput = false;\r\n            }\r\n        }\r\n        else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isPair)(item)) {\r\n            const ik = (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isNode)(item.key) ? item.key : null;\r\n            if (ik) {\r\n                if (!chompKeep && ik.spaceBefore)\r\n                    nodes.push({ comment: true, str: '' });\r\n                let cb = ik.commentBefore;\r\n                if (cb && chompKeep)\r\n                    cb = cb.replace(/^\\n+/, '');\r\n                if (cb) {\r\n                    if (/^\\n+$/.test(cb))\r\n                        cb = cb.substring(1);\r\n                    // This match will always succeed on a non-empty string\r\n                    for (const line of cb.match(/^.*$/gm)) {\r\n                        const str = line === ' ' ? '#' : line ? `#${line}` : '';\r\n                        nodes.push({ comment: true, str });\r\n                    }\r\n                }\r\n                if (ik.comment)\r\n                    singleLineOutput = false;\r\n            }\r\n            if (inFlow) {\r\n                const iv = (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_1__.isNode)(item.value) ? item.value : null;\r\n                if (iv) {\r\n                    if (iv.comment)\r\n                        comment = iv.comment;\r\n                    if (iv.comment || iv.commentBefore)\r\n                        singleLineOutput = false;\r\n                }\r\n                else if (item.value == null && ik && ik.comment) {\r\n                    comment = ik.comment;\r\n                }\r\n            }\r\n        }\r\n        chompKeep = false;\r\n        let str = (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.stringify)(item, ctx, () => (comment = null), () => (chompKeep = true));\r\n        if (inFlow && i < items.length - 1)\r\n            str += ',';\r\n        str = (0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_3__.addComment)(str, itemIndent, comment);\r\n        if (chompKeep && (comment || inFlow))\r\n            chompKeep = false;\r\n        nodes.push({ comment: false, str });\r\n        return nodes;\r\n    }, []);\r\n    let str;\r\n    if (nodes.length === 0) {\r\n        str = flowChars.start + flowChars.end;\r\n    }\r\n    else if (inFlow) {\r\n        const { start, end } = flowChars;\r\n        const strings = nodes.map(n => n.str);\r\n        let singleLineLength = 2;\r\n        for (const node of nodes) {\r\n            if (node.comment || node.str.includes('\\n')) {\r\n                singleLineOutput = false;\r\n                break;\r\n            }\r\n            singleLineLength += node.str.length + 2;\r\n        }\r\n        if (!singleLineOutput ||\r\n            singleLineLength > _nodes_Collection_js__WEBPACK_IMPORTED_MODULE_0__.Collection.maxFlowStringSingleLineLength) {\r\n            str = start;\r\n            for (const s of strings) {\r\n                str += s ? `\\n${indentStep}${indent}${s}` : '\\n';\r\n            }\r\n            str += `\\n${indent}${end}`;\r\n        }\r\n        else {\r\n            str = `${start} ${strings.join(' ')} ${end}`;\r\n        }\r\n    }\r\n    else {\r\n        const strings = nodes.map(blockItem);\r\n        str = strings.shift() || '';\r\n        for (const s of strings)\r\n            str += s ? `\\n${indent}${s}` : '\\n';\r\n    }\r\n    if (comment) {\r\n        str += '\\n' + (0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_3__.stringifyComment)(comment, indent);\r\n        if (onComment)\r\n            onComment();\r\n    }\r\n    else if (chompKeep && onChompKeep)\r\n        onChompKeep();\r\n    return str;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/stringify/stringifyCollection.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/stringify/stringifyComment.js":
/*!**********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/stringify/stringifyComment.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addComment\": () => (/* binding */ addComment),\n/* harmony export */   \"stringifyComment\": () => (/* binding */ stringifyComment)\n/* harmony export */ });\nconst stringifyComment = (comment, indent) => /^\\n+$/.test(comment)\r\n    ? comment.substring(1)\r\n    : comment.replace(/^(?!$)(?: $)?/gm, `${indent}#`);\r\nfunction addComment(str, indent, comment) {\r\n    return !comment\r\n        ? str\r\n        : comment.includes('\\n')\r\n            ? `${str}\\n` + stringifyComment(comment, indent)\r\n            : str.endsWith(' ')\r\n                ? `${str}#${comment}`\r\n                : `${str} #${comment}`;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/stringify/stringifyComment.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/stringify/stringifyDocument.js":
/*!***********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/stringify/stringifyDocument.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stringifyDocument\": () => (/* binding */ stringifyDocument)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/yaml/browser/dist/stringify/stringify.js\");\n/* harmony import */ var _stringifyComment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringifyComment.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyComment.js\");\n\r\n\r\n\r\n\r\nfunction stringifyDocument(doc, options) {\r\n    const lines = [];\r\n    let hasDirectives = options.directives === true;\r\n    if (options.directives !== false) {\r\n        const dir = doc.directives.toString(doc);\r\n        if (dir) {\r\n            lines.push(dir);\r\n            hasDirectives = true;\r\n        }\r\n        else if (doc.directives.marker)\r\n            hasDirectives = true;\r\n    }\r\n    if (hasDirectives)\r\n        lines.push('---');\r\n    if (doc.commentBefore) {\r\n        if (lines.length !== 1)\r\n            lines.unshift('');\r\n        lines.unshift((0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_2__.stringifyComment)(doc.commentBefore, ''));\r\n    }\r\n    const ctx = (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.createStringifyContext)(doc, options);\r\n    let chompKeep = false;\r\n    let contentComment = null;\r\n    if (doc.contents) {\r\n        if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isNode)(doc.contents)) {\r\n            if (doc.contents.spaceBefore && hasDirectives)\r\n                lines.push('');\r\n            if (doc.contents.commentBefore)\r\n                lines.push((0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_2__.stringifyComment)(doc.contents.commentBefore, ''));\r\n            // top-level block scalars need to be indented if followed by a comment\r\n            ctx.forceBlockIndent = !!doc.comment;\r\n            contentComment = doc.contents.comment;\r\n        }\r\n        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);\r\n        let body = (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(doc.contents, ctx, () => (contentComment = null), onChompKeep);\r\n        if (contentComment)\r\n            body = (0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_2__.addComment)(body, '', contentComment);\r\n        if ((body[0] === '|' || body[0] === '>') &&\r\n            lines[lines.length - 1] === '---') {\r\n            // Top-level block scalars with a preceding doc marker ought to use the\r\n            // same line for their header.\r\n            lines[lines.length - 1] = `--- ${body}`;\r\n        }\r\n        else\r\n            lines.push(body);\r\n    }\r\n    else {\r\n        lines.push((0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(doc.contents, ctx));\r\n    }\r\n    let dc = doc.comment;\r\n    if (dc && chompKeep)\r\n        dc = dc.replace(/^\\n+/, '');\r\n    if (dc) {\r\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')\r\n            lines.push('');\r\n        lines.push((0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_2__.stringifyComment)(dc, ''));\r\n    }\r\n    return lines.join('\\n') + '\\n';\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/stringify/stringifyDocument.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/stringify/stringifyNumber.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/stringify/stringifyNumber.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stringifyNumber\": () => (/* binding */ stringifyNumber)\n/* harmony export */ });\nfunction stringifyNumber({ format, minFractionDigits, tag, value }) {\r\n    if (typeof value === 'bigint')\r\n        return String(value);\r\n    const num = typeof value === 'number' ? value : Number(value);\r\n    if (!isFinite(num))\r\n        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';\r\n    let n = JSON.stringify(value);\r\n    if (!format &&\r\n        minFractionDigits &&\r\n        (!tag || tag === 'tag:yaml.org,2002:float') &&\r\n        /^\\d/.test(n)) {\r\n        let i = n.indexOf('.');\r\n        if (i < 0) {\r\n            i = n.length;\r\n            n += '.';\r\n        }\r\n        let d = minFractionDigits - (n.length - i - 1);\r\n        while (d-- > 0)\r\n            n += '0';\r\n    }\r\n    return n;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/stringify/stringifyNumber.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/stringify/stringifyPair.js":
/*!*******************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/stringify/stringifyPair.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stringifyPair\": () => (/* binding */ stringifyPair)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/yaml/browser/dist/stringify/stringify.js\");\n/* harmony import */ var _stringifyComment_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stringifyComment.js */ \"./node_modules/yaml/browser/dist/stringify/stringifyComment.js\");\n\r\n\r\n\r\n\r\n\r\nfunction stringifyPair({ key, value }, ctx, onComment, onChompKeep) {\r\n    const { allNullValues, doc, indent, indentStep, options: { indentSeq, simpleKeys } } = ctx;\r\n    let keyComment = ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isNode)(key) && key.comment) || null;\r\n    if (simpleKeys) {\r\n        if (keyComment) {\r\n            throw new Error('With simple keys, key nodes cannot have comments');\r\n        }\r\n        if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isCollection)(key)) {\r\n            const msg = 'With simple keys, collection cannot be used as a key value';\r\n            throw new Error(msg);\r\n        }\r\n    }\r\n    let explicitKey = !simpleKeys &&\r\n        (!key ||\r\n            (keyComment && value == null && !ctx.inFlow) ||\r\n            (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isCollection)(key) ||\r\n            ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isScalar)(key)\r\n                ? key.type === _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_1__.Scalar.BLOCK_FOLDED || key.type === _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_1__.Scalar.BLOCK_LITERAL\r\n                : typeof key === 'object'));\r\n    ctx = Object.assign({}, ctx, {\r\n        allNullValues: false,\r\n        implicitKey: !explicitKey && (simpleKeys || !allNullValues),\r\n        indent: indent + indentStep\r\n    });\r\n    let keyCommentDone = false;\r\n    let chompKeep = false;\r\n    let str = (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.stringify)(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));\r\n    if (!explicitKey && !ctx.inFlow && str.length > 1024) {\r\n        if (simpleKeys)\r\n            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');\r\n        explicitKey = true;\r\n    }\r\n    if (ctx.inFlow) {\r\n        if (allNullValues || value == null) {\r\n            if (keyCommentDone && onComment)\r\n                onComment();\r\n            return explicitKey ? `? ${str}` : str;\r\n        }\r\n    }\r\n    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {\r\n        if (keyCommentDone)\r\n            keyComment = null;\r\n        if (chompKeep && !keyComment && onChompKeep)\r\n            onChompKeep();\r\n        return (0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_3__.addComment)(`? ${str}`, ctx.indent, keyComment);\r\n    }\r\n    if (keyCommentDone)\r\n        keyComment = null;\r\n    str = explicitKey\r\n        ? `? ${(0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_3__.addComment)(str, ctx.indent, keyComment)}\\n${indent}:`\r\n        : (0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_3__.addComment)(`${str}:`, ctx.indent, keyComment);\r\n    let vcb = '';\r\n    let valueComment = null;\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isNode)(value)) {\r\n        if (value.spaceBefore)\r\n            vcb = '\\n';\r\n        if (value.commentBefore)\r\n            vcb += `\\n${(0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_3__.stringifyComment)(value.commentBefore, ctx.indent)}`;\r\n        valueComment = value.comment;\r\n    }\r\n    else if (value && typeof value === 'object') {\r\n        value = doc.createNode(value);\r\n    }\r\n    ctx.implicitKey = false;\r\n    if (!explicitKey && !keyComment && (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isScalar)(value))\r\n        ctx.indentAtStart = str.length + 1;\r\n    chompKeep = false;\r\n    if (!indentSeq &&\r\n        indentStep.length >= 2 &&\r\n        !ctx.inFlow &&\r\n        !explicitKey &&\r\n        (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isSeq)(value) &&\r\n        !value.flow &&\r\n        !value.tag &&\r\n        !value.anchor) {\r\n        // If indentSeq === false, consider '- ' as part of indentation where possible\r\n        ctx.indent = ctx.indent.substr(2);\r\n    }\r\n    let valueCommentDone = false;\r\n    const valueStr = (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.stringify)(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));\r\n    let ws = ' ';\r\n    if (vcb || keyComment) {\r\n        ws = valueStr === '' && !ctx.inFlow ? vcb : `${vcb}\\n${ctx.indent}`;\r\n    }\r\n    else if (!explicitKey && (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isCollection)(value)) {\r\n        const flow = valueStr[0] === '[' || valueStr[0] === '{';\r\n        if (!flow || valueStr.includes('\\n'))\r\n            ws = `\\n${ctx.indent}`;\r\n    }\r\n    else if (valueStr === '' || valueStr[0] === '\\n')\r\n        ws = '';\r\n    if (ctx.inFlow) {\r\n        if (valueCommentDone && onComment)\r\n            onComment();\r\n        return str + ws + valueStr;\r\n    }\r\n    else {\r\n        if (valueCommentDone)\r\n            valueComment = null;\r\n        if (chompKeep && !valueComment && onChompKeep)\r\n            onChompKeep();\r\n        return (0,_stringifyComment_js__WEBPACK_IMPORTED_MODULE_3__.addComment)(str + ws + valueStr, ctx.indent, valueComment);\r\n    }\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/stringify/stringifyPair.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/stringify/stringifyString.js":
/*!*********************************************************************!*\
  !*** ./node_modules/yaml/browser/dist/stringify/stringifyString.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"stringifyString\": () => (/* binding */ stringifyString)\n/* harmony export */ });\n/* harmony import */ var _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/Scalar.js */ \"./node_modules/yaml/browser/dist/nodes/Scalar.js\");\n/* harmony import */ var _foldFlowLines_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./foldFlowLines.js */ \"./node_modules/yaml/browser/dist/stringify/foldFlowLines.js\");\n\r\n\r\n\r\nconst getFoldOptions = (ctx) => ({\r\n    indentAtStart: ctx.indentAtStart,\r\n    lineWidth: ctx.options.lineWidth,\r\n    minContentWidth: ctx.options.minContentWidth\r\n});\r\n// Also checks for lines starting with %, as parsing the output as YAML 1.1 will\r\n// presume that's starting a new document.\r\nconst containsDocumentMarker = (str) => /^(%|---|\\.\\.\\.)/m.test(str);\r\nfunction lineLengthOverLimit(str, lineWidth, indentLength) {\r\n    if (!lineWidth || lineWidth < 0)\r\n        return false;\r\n    const limit = lineWidth - indentLength;\r\n    const strLen = str.length;\r\n    if (strLen <= limit)\r\n        return false;\r\n    for (let i = 0, start = 0; i < strLen; ++i) {\r\n        if (str[i] === '\\n') {\r\n            if (i - start > limit)\r\n                return true;\r\n            start = i + 1;\r\n            if (strLen - start <= limit)\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction doubleQuotedString(value, ctx) {\r\n    const json = JSON.stringify(value);\r\n    if (ctx.options.doubleQuotedAsJSON)\r\n        return json;\r\n    const { implicitKey } = ctx;\r\n    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;\r\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\r\n    let str = '';\r\n    let start = 0;\r\n    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {\r\n        if (ch === ' ' && json[i + 1] === '\\\\' && json[i + 2] === 'n') {\r\n            // space before newline needs to be escaped to not be folded\r\n            str += json.slice(start, i) + '\\\\ ';\r\n            i += 1;\r\n            start = i;\r\n            ch = '\\\\';\r\n        }\r\n        if (ch === '\\\\')\r\n            switch (json[i + 1]) {\r\n                case 'u':\r\n                    {\r\n                        str += json.slice(start, i);\r\n                        const code = json.substr(i + 2, 4);\r\n                        switch (code) {\r\n                            case '0000':\r\n                                str += '\\\\0';\r\n                                break;\r\n                            case '0007':\r\n                                str += '\\\\a';\r\n                                break;\r\n                            case '000b':\r\n                                str += '\\\\v';\r\n                                break;\r\n                            case '001b':\r\n                                str += '\\\\e';\r\n                                break;\r\n                            case '0085':\r\n                                str += '\\\\N';\r\n                                break;\r\n                            case '00a0':\r\n                                str += '\\\\_';\r\n                                break;\r\n                            case '2028':\r\n                                str += '\\\\L';\r\n                                break;\r\n                            case '2029':\r\n                                str += '\\\\P';\r\n                                break;\r\n                            default:\r\n                                if (code.substr(0, 2) === '00')\r\n                                    str += '\\\\x' + code.substr(2);\r\n                                else\r\n                                    str += json.substr(i, 6);\r\n                        }\r\n                        i += 5;\r\n                        start = i + 1;\r\n                    }\r\n                    break;\r\n                case 'n':\r\n                    if (implicitKey ||\r\n                        json[i + 2] === '\"' ||\r\n                        json.length < minMultiLineLength) {\r\n                        i += 1;\r\n                    }\r\n                    else {\r\n                        // folding will eat first newline\r\n                        str += json.slice(start, i) + '\\n\\n';\r\n                        while (json[i + 2] === '\\\\' &&\r\n                            json[i + 3] === 'n' &&\r\n                            json[i + 4] !== '\"') {\r\n                            str += '\\n';\r\n                            i += 2;\r\n                        }\r\n                        str += indent;\r\n                        // space after newline needs to be escaped to not be folded\r\n                        if (json[i + 2] === ' ')\r\n                            str += '\\\\';\r\n                        i += 1;\r\n                        start = i + 1;\r\n                    }\r\n                    break;\r\n                default:\r\n                    i += 1;\r\n            }\r\n    }\r\n    str = start ? str + json.slice(start) : json;\r\n    return implicitKey\r\n        ? str\r\n        : (0,_foldFlowLines_js__WEBPACK_IMPORTED_MODULE_1__.foldFlowLines)(str, indent, _foldFlowLines_js__WEBPACK_IMPORTED_MODULE_1__.FOLD_QUOTED, getFoldOptions(ctx));\r\n}\r\nfunction singleQuotedString(value, ctx) {\r\n    if (ctx.options.singleQuote === false ||\r\n        (ctx.implicitKey && value.includes('\\n')) ||\r\n        /[ \\t]\\n|\\n[ \\t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline\r\n    )\r\n        return doubleQuotedString(value, ctx);\r\n    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');\r\n    const res = \"'\" + value.replace(/'/g, \"''\").replace(/\\n+/g, `$&\\n${indent}`) + \"'\";\r\n    return ctx.implicitKey\r\n        ? res\r\n        : (0,_foldFlowLines_js__WEBPACK_IMPORTED_MODULE_1__.foldFlowLines)(res, indent, _foldFlowLines_js__WEBPACK_IMPORTED_MODULE_1__.FOLD_FLOW, getFoldOptions(ctx));\r\n}\r\nfunction quotedString(value, ctx) {\r\n    const { singleQuote } = ctx.options;\r\n    let qs;\r\n    if (singleQuote === false)\r\n        qs = doubleQuotedString;\r\n    else {\r\n        const hasDouble = value.includes('\"');\r\n        const hasSingle = value.includes(\"'\");\r\n        if (hasDouble && !hasSingle)\r\n            qs = singleQuotedString;\r\n        else if (hasSingle && !hasDouble)\r\n            qs = doubleQuotedString;\r\n        else\r\n            qs = singleQuote ? singleQuotedString : doubleQuotedString;\r\n    }\r\n    return qs(value, ctx);\r\n}\r\nfunction blockString({ comment, type, value }, ctx, onComment, onChompKeep) {\r\n    const { lineWidth, blockQuote } = ctx.options;\r\n    // 1. Block can't end in whitespace unless the last line is non-empty.\r\n    // 2. Strings consisting of only whitespace are best rendered explicitly.\r\n    if (!blockQuote || /\\n[\\t ]+$/.test(value) || /^\\s*$/.test(value)) {\r\n        return quotedString(value, ctx);\r\n    }\r\n    const indent = ctx.indent ||\r\n        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');\r\n    const literal = blockQuote === 'literal'\r\n        ? true\r\n        : blockQuote === 'folded' || type === _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.BLOCK_FOLDED\r\n            ? false\r\n            : type === _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.BLOCK_LITERAL\r\n                ? true\r\n                : !lineLengthOverLimit(value, lineWidth, indent.length);\r\n    if (!value)\r\n        return literal ? '|\\n' : '>\\n';\r\n    // determine chomping from whitespace at value end\r\n    let chomp;\r\n    let endStart;\r\n    for (endStart = value.length; endStart > 0; --endStart) {\r\n        const ch = value[endStart - 1];\r\n        if (ch !== '\\n' && ch !== '\\t' && ch !== ' ')\r\n            break;\r\n    }\r\n    let end = value.substring(endStart);\r\n    const endNlPos = end.indexOf('\\n');\r\n    if (endNlPos === -1) {\r\n        chomp = '-'; // strip\r\n    }\r\n    else if (value === end || endNlPos !== end.length - 1) {\r\n        chomp = '+'; // keep\r\n        if (onChompKeep)\r\n            onChompKeep();\r\n    }\r\n    else {\r\n        chomp = ''; // clip\r\n    }\r\n    if (end) {\r\n        value = value.slice(0, -end.length);\r\n        if (end[end.length - 1] === '\\n')\r\n            end = end.slice(0, -1);\r\n        end = end.replace(/\\n+(?!\\n|$)/g, `$&${indent}`);\r\n    }\r\n    // determine indent indicator from whitespace at value start\r\n    let startWithSpace = false;\r\n    let startEnd;\r\n    let startNlPos = -1;\r\n    for (startEnd = 0; startEnd < value.length; ++startEnd) {\r\n        const ch = value[startEnd];\r\n        if (ch === ' ')\r\n            startWithSpace = true;\r\n        else if (ch === '\\n')\r\n            startNlPos = startEnd;\r\n        else\r\n            break;\r\n    }\r\n    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);\r\n    if (start) {\r\n        value = value.substring(start.length);\r\n        start = start.replace(/\\n+/g, `$&${indent}`);\r\n    }\r\n    const indentSize = indent ? '2' : '1'; // root is at -1\r\n    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;\r\n    if (comment) {\r\n        header += ' #' + comment.replace(/ ?[\\r\\n]+/g, ' ');\r\n        if (onComment)\r\n            onComment();\r\n    }\r\n    if (literal) {\r\n        value = value.replace(/\\n+/g, `$&${indent}`);\r\n        return `${header}\\n${indent}${start}${value}${end}`;\r\n    }\r\n    value = value\r\n        .replace(/\\n+/g, '\\n$&')\r\n        .replace(/(?:^|\\n)([\\t ].*)(?:([\\n\\t ]*)\\n(?![\\n\\t ]))?/g, '$1$2') // more-indented lines aren't folded\r\n        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent\r\n        .replace(/\\n+/g, `$&${indent}`);\r\n    const body = (0,_foldFlowLines_js__WEBPACK_IMPORTED_MODULE_1__.foldFlowLines)(`${start}${value}${end}`, indent, _foldFlowLines_js__WEBPACK_IMPORTED_MODULE_1__.FOLD_BLOCK, getFoldOptions(ctx));\r\n    return `${header}\\n${indent}${body}`;\r\n}\r\nfunction plainString(item, ctx, onComment, onChompKeep) {\r\n    var _a;\r\n    const { type, value } = item;\r\n    const { actualString, implicitKey, indent, inFlow } = ctx;\r\n    if ((implicitKey && /[\\n[\\]{},]/.test(value)) ||\r\n        (inFlow && /[[\\]{},]/.test(value))) {\r\n        return quotedString(value, ctx);\r\n    }\r\n    if (!value ||\r\n        /^[\\n\\t ,[\\]{}#&*!|>'\"%@`]|^[?-]$|^[?-][ \\t]|[\\n:][ \\t]|[ \\t]\\n|[\\n\\t ]#|[\\n\\t :]$/.test(value)) {\r\n        // not allowed:\r\n        // - empty string, '-' or '?'\r\n        // - start with an indicator character (except [?:-]) or /[?-] /\r\n        // - '\\n ', ': ' or ' \\n' anywhere\r\n        // - '#' not preceded by a non-space char\r\n        // - end with ' ' or ':'\r\n        return implicitKey || inFlow || value.indexOf('\\n') === -1\r\n            ? quotedString(value, ctx)\r\n            : blockString(item, ctx, onComment, onChompKeep);\r\n    }\r\n    if (!implicitKey &&\r\n        !inFlow &&\r\n        type !== _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.PLAIN &&\r\n        value.indexOf('\\n') !== -1) {\r\n        // Where allowed & type not set explicitly, prefer block style for multiline strings\r\n        return blockString(item, ctx, onComment, onChompKeep);\r\n    }\r\n    if (indent === '' && containsDocumentMarker(value)) {\r\n        ctx.forceBlockIndent = true;\r\n        return blockString(item, ctx, onComment, onChompKeep);\r\n    }\r\n    const str = value.replace(/\\n+/g, `$&\\n${indent}`);\r\n    // Verify that output will be parsed as a string, as e.g. plain numbers and\r\n    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),\r\n    // and others in v1.1.\r\n    if (actualString) {\r\n        for (const tag of ctx.doc.schema.tags) {\r\n            if (tag.default &&\r\n                tag.tag !== 'tag:yaml.org,2002:str' &&\r\n                ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(str)))\r\n                return quotedString(value, ctx);\r\n        }\r\n    }\r\n    return implicitKey\r\n        ? str\r\n        : (0,_foldFlowLines_js__WEBPACK_IMPORTED_MODULE_1__.foldFlowLines)(str, indent, _foldFlowLines_js__WEBPACK_IMPORTED_MODULE_1__.FOLD_FLOW, getFoldOptions(ctx));\r\n}\r\nfunction stringifyString(item, ctx, onComment, onChompKeep) {\r\n    const { implicitKey, inFlow } = ctx;\r\n    const ss = typeof item.value === 'string'\r\n        ? item\r\n        : Object.assign({}, item, { value: String(item.value) });\r\n    let { type } = item;\r\n    if (type !== _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.QUOTE_DOUBLE) {\r\n        // force double quotes on control characters & unpaired surrogates\r\n        if (/[\\x00-\\x08\\x0b-\\x1f\\x7f-\\x9f\\u{D800}-\\u{DFFF}]/u.test(ss.value))\r\n            type = _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.QUOTE_DOUBLE;\r\n    }\r\n    const _stringify = (_type) => {\r\n        switch (_type) {\r\n            case _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.BLOCK_FOLDED:\r\n            case _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.BLOCK_LITERAL:\r\n                return implicitKey || inFlow\r\n                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers\r\n                    : blockString(ss, ctx, onComment, onChompKeep);\r\n            case _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.QUOTE_DOUBLE:\r\n                return doubleQuotedString(ss.value, ctx);\r\n            case _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.QUOTE_SINGLE:\r\n                return singleQuotedString(ss.value, ctx);\r\n            case _nodes_Scalar_js__WEBPACK_IMPORTED_MODULE_0__.Scalar.PLAIN:\r\n                return plainString(ss, ctx, onComment, onChompKeep);\r\n            default:\r\n                return null;\r\n        }\r\n    };\r\n    let res = _stringify(type);\r\n    if (res === null) {\r\n        const { defaultKeyType, defaultStringType } = ctx.options;\r\n        const t = (implicitKey && defaultKeyType) || defaultStringType;\r\n        res = _stringify(t);\r\n        if (res === null)\r\n            throw new Error(`Unsupported default string type ${t}`);\r\n    }\r\n    return res;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/stringify/stringifyString.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/dist/visit.js":
/*!*************************************************!*\
  !*** ./node_modules/yaml/browser/dist/visit.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"visit\": () => (/* binding */ visit)\n/* harmony export */ });\n/* harmony import */ var _nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nodes/Node.js */ \"./node_modules/yaml/browser/dist/nodes/Node.js\");\n\r\n\r\nconst BREAK = Symbol('break visit');\r\nconst SKIP = Symbol('skip children');\r\nconst REMOVE = Symbol('remove node');\r\n/**\r\n * Apply a visitor to an AST node or document.\r\n *\r\n * Walks through the tree (depth-first) starting from `node`, calling a\r\n * `visitor` function with three arguments:\r\n *   - `key`: For sequence values and map `Pair`, the node's index in the\r\n *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.\r\n *     `null` for the root node.\r\n *   - `node`: The current node.\r\n *   - `path`: The ancestry of the current node.\r\n *\r\n * The return value of the visitor may be used to control the traversal:\r\n *   - `undefined` (default): Do nothing and continue\r\n *   - `visit.SKIP`: Do not visit the children of this node, continue with next\r\n *     sibling\r\n *   - `visit.BREAK`: Terminate traversal completely\r\n *   - `visit.REMOVE`: Remove the current node, then continue with the next one\r\n *   - `Node`: Replace the current node, then continue by visiting it\r\n *   - `number`: While iterating the items of a sequence or map, set the index\r\n *     of the next step. This is useful especially if the index of the current\r\n *     node has changed.\r\n *\r\n * If `visitor` is a single function, it will be called with all values\r\n * encountered in the tree, including e.g. `null` values. Alternatively,\r\n * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,\r\n * `Alias` and `Scalar` node. To define the same visitor function for more than\r\n * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)\r\n * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most\r\n * specific defined one will be used for each node.\r\n */\r\nfunction visit(node, visitor) {\r\n    if (typeof visitor === 'object' &&\r\n        (visitor.Collection || visitor.Node || visitor.Value)) {\r\n        visitor = Object.assign({\r\n            Alias: visitor.Node,\r\n            Map: visitor.Node,\r\n            Scalar: visitor.Node,\r\n            Seq: visitor.Node\r\n        }, visitor.Value && {\r\n            Map: visitor.Value,\r\n            Scalar: visitor.Value,\r\n            Seq: visitor.Value\r\n        }, visitor.Collection && {\r\n            Map: visitor.Collection,\r\n            Seq: visitor.Collection\r\n        }, visitor);\r\n    }\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isDocument)(node)) {\r\n        const cd = _visit(null, node.contents, visitor, Object.freeze([node]));\r\n        if (cd === REMOVE)\r\n            node.contents = null;\r\n    }\r\n    else\r\n        _visit(null, node, visitor, Object.freeze([]));\r\n}\r\n// Without the `as symbol` casts, TS declares these in the `visit`\r\n// namespace using `var`, but then complains about that because\r\n// `unique symbol` must be `const`.\r\n/** Terminate visit traversal completely */\r\nvisit.BREAK = BREAK;\r\n/** Do not visit the children of the current node */\r\nvisit.SKIP = SKIP;\r\n/** Remove the current node */\r\nvisit.REMOVE = REMOVE;\r\nfunction _visit(key, node, visitor, path) {\r\n    let ctrl = undefined;\r\n    if (typeof visitor === 'function')\r\n        ctrl = visitor(key, node, path);\r\n    else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isMap)(node)) {\r\n        if (visitor.Map)\r\n            ctrl = visitor.Map(key, node, path);\r\n    }\r\n    else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isSeq)(node)) {\r\n        if (visitor.Seq)\r\n            ctrl = visitor.Seq(key, node, path);\r\n    }\r\n    else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isPair)(node)) {\r\n        if (visitor.Pair)\r\n            ctrl = visitor.Pair(key, node, path);\r\n    }\r\n    else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isScalar)(node)) {\r\n        if (visitor.Scalar)\r\n            ctrl = visitor.Scalar(key, node, path);\r\n    }\r\n    else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isAlias)(node)) {\r\n        if (visitor.Alias)\r\n            ctrl = visitor.Alias(key, node, path);\r\n    }\r\n    if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isNode)(ctrl) || (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isPair)(ctrl)) {\r\n        const parent = path[path.length - 1];\r\n        if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isCollection)(parent)) {\r\n            parent.items[key] = ctrl;\r\n        }\r\n        else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isPair)(parent)) {\r\n            if (key === 'key')\r\n                parent.key = ctrl;\r\n            else\r\n                parent.value = ctrl;\r\n        }\r\n        else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isDocument)(parent)) {\r\n            parent.contents = ctrl;\r\n        }\r\n        else {\r\n            const pt = (0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isAlias)(parent) ? 'alias' : 'scalar';\r\n            throw new Error(`Cannot replace node with ${pt} parent`);\r\n        }\r\n        return _visit(key, ctrl, visitor, path);\r\n    }\r\n    if (typeof ctrl !== 'symbol') {\r\n        if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isCollection)(node)) {\r\n            path = Object.freeze(path.concat(node));\r\n            for (let i = 0; i < node.items.length; ++i) {\r\n                const ci = _visit(i, node.items[i], visitor, path);\r\n                if (typeof ci === 'number')\r\n                    i = ci - 1;\r\n                else if (ci === BREAK)\r\n                    return BREAK;\r\n                else if (ci === REMOVE) {\r\n                    node.items.splice(i, 1);\r\n                    i -= 1;\r\n                }\r\n            }\r\n        }\r\n        else if ((0,_nodes_Node_js__WEBPACK_IMPORTED_MODULE_0__.isPair)(node)) {\r\n            path = Object.freeze(path.concat(node));\r\n            const ck = _visit('key', node.key, visitor, path);\r\n            if (ck === BREAK)\r\n                return BREAK;\r\n            else if (ck === REMOVE)\r\n                node.key = null;\r\n            const cv = _visit('value', node.value, visitor, path);\r\n            if (cv === BREAK)\r\n                return BREAK;\r\n            else if (cv === REMOVE)\r\n                node.value = null;\r\n        }\r\n    }\r\n    return ctrl;\r\n}\r\n\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/dist/visit.js?");

/***/ }),

/***/ "./node_modules/yaml/browser/index.js":
/*!********************************************!*\
  !*** ./node_modules/yaml/browser/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"Alias\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Alias),\n/* harmony export */   \"CST\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.CST),\n/* harmony export */   \"Composer\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Composer),\n/* harmony export */   \"Document\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Document),\n/* harmony export */   \"Lexer\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Lexer),\n/* harmony export */   \"LineCounter\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.LineCounter),\n/* harmony export */   \"Pair\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Pair),\n/* harmony export */   \"Parser\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Parser),\n/* harmony export */   \"Scalar\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Scalar),\n/* harmony export */   \"Schema\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   \"YAMLError\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.YAMLError),\n/* harmony export */   \"YAMLMap\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.YAMLMap),\n/* harmony export */   \"YAMLParseError\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.YAMLParseError),\n/* harmony export */   \"YAMLSeq\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.YAMLSeq),\n/* harmony export */   \"YAMLWarning\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.YAMLWarning),\n/* harmony export */   \"defaultOptions\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.defaultOptions),\n/* harmony export */   \"isAlias\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isAlias),\n/* harmony export */   \"isCollection\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isCollection),\n/* harmony export */   \"isDocument\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isDocument),\n/* harmony export */   \"isMap\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isMap),\n/* harmony export */   \"isNode\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isNode),\n/* harmony export */   \"isPair\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isPair),\n/* harmony export */   \"isScalar\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isScalar),\n/* harmony export */   \"isSeq\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.isSeq),\n/* harmony export */   \"parse\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.parse),\n/* harmony export */   \"parseAllDocuments\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.parseAllDocuments),\n/* harmony export */   \"parseDocument\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.parseDocument),\n/* harmony export */   \"stringify\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.stringify),\n/* harmony export */   \"visit\": () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.visit)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"./node_modules/yaml/browser/dist/index.js\");\n// `export * as default from ...` fails on Webpack v4\r\n// https://github.com/eemeli/yaml/issues/228\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_dist_index_js__WEBPACK_IMPORTED_MODULE_0__);\r\n\r\n\n\n//# sourceURL=webpack://sit-almeida/./node_modules/yaml/browser/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;